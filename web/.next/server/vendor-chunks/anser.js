"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/anser";
exports.ids = ["vendor-chunks/anser"];
exports.modules = {

/***/ "(ssr)/./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\n\n// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011\n\nconst ANSI_COLORS = [\n    [\n        { color: \"0, 0, 0\",        \"class\": \"ansi-black\"   }\n      , { color: \"187, 0, 0\",      \"class\": \"ansi-red\"     }\n      , { color: \"0, 187, 0\",      \"class\": \"ansi-green\"   }\n      , { color: \"187, 187, 0\",    \"class\": \"ansi-yellow\"  }\n      , { color: \"0, 0, 187\",      \"class\": \"ansi-blue\"    }\n      , { color: \"187, 0, 187\",    \"class\": \"ansi-magenta\" }\n      , { color: \"0, 187, 187\",    \"class\": \"ansi-cyan\"    }\n      , { color: \"255,255,255\",    \"class\": \"ansi-white\"   }\n    ]\n  , [\n        { color: \"85, 85, 85\",     \"class\": \"ansi-bright-black\"   }\n      , { color: \"255, 85, 85\",    \"class\": \"ansi-bright-red\"     }\n      , { color: \"0, 255, 0\",      \"class\": \"ansi-bright-green\"   }\n      , { color: \"255, 255, 85\",   \"class\": \"ansi-bright-yellow\"  }\n      , { color: \"85, 85, 255\",    \"class\": \"ansi-bright-blue\"    }\n      , { color: \"255, 85, 255\",   \"class\": \"ansi-bright-magenta\" }\n      , { color: \"85, 255, 255\",   \"class\": \"ansi-bright-cyan\"    }\n      , { color: \"255, 255, 255\",  \"class\": \"ansi-bright-white\"   }\n    ]\n];\n// https://datatracker.ietf.org/doc/html/rfc3986#appendix-A\nconst linkRegex = /(https?:\\/\\/(?:[A-Za-z0-9#;/?:@=+$',_.!~*()[\\]-]|&amp;|%[A-Fa-f0-9]{2})+)/gm;\n\nclass Anser {\n\n    /**\n     * Anser.escapeForHtml\n     * Escape the input HTML.\n     *\n     * This does the minimum escaping of text to make it compliant with HTML.\n     * In particular, the '&','<', and '>' characters are escaped. This should\n     * be run prior to `ansiToHtml`.\n     *\n     * @name Anser.escapeForHtml\n     * @function\n     * @param {String} txt The input text (containing the ANSI snippets).\n     * @returns {String} The escaped html.\n     */\n    static escapeForHtml (txt) {\n        return new Anser().escapeForHtml(txt);\n    }\n\n    /**\n     * Anser.linkify\n     * Adds the links in the HTML.\n     *\n     * This replaces any links in the text with anchor tags that display the\n     * link. You should apply this after you have run `ansiToHtml` on the text.\n     *\n     * @name Anser.linkify\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The HTML containing the <a> tags (unescaped).\n     */\n    static linkify (txt) {\n        return new Anser().linkify(txt);\n    }\n\n    /**\n     * Anser.ansiToHtml\n     * This replaces ANSI terminal escape codes with SPAN tags that wrap the\n     * content.\n     *\n     * This function only interprets ANSI SGR (Select Graphic Rendition) codes\n     * that can be represented in HTML.\n     * For example, cursor movement codes are ignored and hidden from output.\n     * The default style uses colors that are very close to the prescribed\n     * standard. The standard assumes that the text will have a black\n     * background. These colors are set as inline styles on the SPAN tags.\n     *\n     * Another option is to set `use_classes: true` in the options argument.\n     * This will instead set classes on the spans so the colors can be set via\n     * CSS. The class names used are of the format `ansi-*-fg/bg` and\n     * `ansi-bright-*-fg/bg` where `*` is the color name,\n     * i.e black/red/green/yellow/blue/magenta/cyan/white.\n     *\n     * @name Anser.ansiToHtml\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed to the ansiToHTML method.\n     * @returns {String} The HTML output.\n     */\n    static ansiToHtml (txt, options) {\n        return new Anser().ansiToHtml(txt, options);\n    }\n\n    /**\n     * Anser.ansiToJson\n     * Converts ANSI input into JSON output.\n     *\n     * @name Anser.ansiToJson\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed to the ansiToHTML method.\n     * @returns {String} The HTML output.\n     */\n    static ansiToJson (txt, options) {\n        return new Anser().ansiToJson(txt, options);\n    }\n\n    /**\n     * Anser.ansiToText\n     * Converts ANSI input into text output.\n     *\n     * @name Anser.ansiToText\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The text output.\n     */\n    static ansiToText (txt) {\n        return new Anser().ansiToText(txt);\n    }\n\n    /**\n     * Anser\n     * The `Anser` class.\n     *\n     * @name Anser\n     * @function\n     * @returns {Anser}\n     */\n    constructor () {\n        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;\n        this.bright = 0;\n        this.decorations = [];\n    }\n\n    /**\n     * setupPalette\n     * Sets up the palette.\n     *\n     * @name setupPalette\n     * @function\n     */\n    setupPalette () {\n        this.PALETTE_COLORS = [];\n\n        // Index 0..15 : System color\n        for (let i = 0; i < 2; ++i) {\n            for (let j = 0; j < 8; ++j) {\n                this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);\n            }\n        }\n\n        // Index 16..231 : RGB 6x6x6\n        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n        let levels = [0, 95, 135, 175, 215, 255];\n        let format = (r, g, b) => levels[r] + \", \" + levels[g] + \", \" + levels[b];\n        let r, g, b;\n        for (let r = 0; r < 6; ++r) {\n            for (let g = 0; g < 6; ++g) {\n                for (let b = 0; b < 6; ++b) {\n                    this.PALETTE_COLORS.push(format(r, g, b));\n                }\n            }\n        }\n\n        // Index 232..255 : Grayscale\n        let level = 8;\n        for (let i = 0; i < 24; ++i, level += 10) {\n            this.PALETTE_COLORS.push(level + \", \" + level + \", \" + level);\n        }\n    }\n\n    /**\n     * escapeForHtml\n     * Escapes the input text.\n     *\n     * @name escapeForHtml\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The escpaed HTML output.\n     */\n    escapeForHtml (txt) {\n        return txt.replace(/[&<>\\\"]/gm, str =>\n                           str == \"&\" ? \"&amp;\" :\n                               str == '\"' ? \"&quot;\" :\n                               str == \"<\" ? \"&lt;\" :\n                               str == \">\" ? \"&gt;\" : \"\"\n                          );\n    }\n\n    /**\n     * linkify\n     * Adds HTML link elements.\n     *\n     * @name linkify\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The HTML output containing link elements.\n     */\n    linkify (txt) {\n        return txt.replace(linkRegex, str => `<a href=\"${str}\">${str}</a>`);\n    }\n\n    /**\n     * ansiToHtml\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToHtml\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed ot the `process` method.\n     * @returns {String} The HTML output.\n     */\n    ansiToHtml (txt, options) {\n        return this.process(txt, options, true);\n    }\n\n    /**\n     * ansiToJson\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToJson\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed ot the `process` method.\n     * @returns {String} The JSON output.\n     */\n    ansiToJson (txt, options) {\n        options = options || {};\n        options.json = true;\n        options.clearLine = false;\n        return this.process(txt, options, true);\n    }\n\n    /**\n     * ansiToText\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToText\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The text output.\n     */\n    ansiToText (txt) {\n        return this.process(txt, {}, false);\n    }\n\n    /**\n     * process\n     * Processes the input.\n     *\n     * @name process\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options An object passed to `processChunk` method, extended with:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup\n     */\n    process (txt, options, markup) {\n        let self = this;\n        let raw_text_chunks = txt.split(/\\033\\[/);\n        let first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split\n\n        if (options === undefined || options === null) {\n            options = {};\n        }\n        options.clearLine = /\\r/.test(txt); // check for Carriage Return\n        let color_chunks = raw_text_chunks.map(chunk => this.processChunk(chunk, options, markup))\n\n        if (options && options.json) {\n            let first = self.processChunkJson(\"\");\n            first.content = first_chunk;\n            first.clearLine = options.clearLine;\n            color_chunks.unshift(first);\n            if (options.remove_empty) {\n                color_chunks = color_chunks.filter(c => !c.isEmpty());\n            }\n            return color_chunks;\n        } else {\n            color_chunks.unshift(first_chunk);\n        }\n\n        return color_chunks.join(\"\");\n    }\n\n    /**\n     * processChunkJson\n     * Processes the current chunk into json output.\n     *\n     * @name processChunkJson\n     * @function\n     * @param {String} text The input text.\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup If false, the colors will not be parsed.\n     * @return {Object} The result object:\n     *\n     *  - `content` (String): The text.\n     *  - `fg` (String|null): The foreground color.\n     *  - `bg` (String|null): The background color.\n     *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).\n     *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).\n     *  - `clearLine` (Boolean): `true` if a carriageReturn \\r was fount at end of line.\n     *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.\n     *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.\n     *\n     */\n    processChunkJson (text, options, markup) {\n\n        // Are we using classes or styles?\n        options = typeof options == \"undefined\" ? {} : options;\n        let use_classes = options.use_classes = typeof options.use_classes != \"undefined\" && options.use_classes;\n        let key = options.key = use_classes ? \"class\" : \"color\";\n\n        let result = {\n            content: text\n          , fg: null\n          , bg: null\n          , fg_truecolor: null\n          , bg_truecolor: null\n          , isInverted: false\n          , clearLine: options.clearLine\n          , decoration: null\n          , decorations: []\n          , was_processed: false\n          , isEmpty: () => !result.content\n        };\n\n        // Each \"chunk\" is the text after the CSI (ESC + \"[\") and before the next CSI/EOF.\n        //\n        // This regex matches four groups within a chunk.\n        //\n        // The first and third groups match code type.\n        // We supported only SGR command. It has empty first group and \"m\" in third.\n        //\n        // The second group matches all of the number+semicolon command sequences\n        // before the \"m\" (or other trailing) character.\n        // These are the graphics or SGR commands.\n        //\n        // The last group is the text (including newlines) that is colored by\n        // the other group\"s commands.\n        let matches = text.match(/^([!\\x3c-\\x3f]*)([\\d;]*)([\\x20-\\x2c]*[\\x40-\\x7e])([\\s\\S]*)/m);\n\n        if (!matches) return result;\n\n        let orig_txt = result.content = matches[4];\n        let nums = matches[2].split(\";\");\n\n        // We currently support only \"SGR\" (Select Graphic Rendition)\n        // Simply ignore if not a SGR command.\n        if (matches[1] !== \"\" || matches[3] !== \"m\") {\n            return result;\n        }\n\n        if (!markup) {\n            return result;\n        }\n\n        let self = this;\n\n        while (nums.length > 0) {\n            let num_str = nums.shift();\n            let num = parseInt(num_str);\n\n            if (isNaN(num) || num === 0) {\n                self.fg = self.bg = null;\n                self.decorations = [];\n            } else if (num === 1) {\n                self.decorations.push(\"bold\");\n            } else if (num === 2) {\n                self.decorations.push(\"dim\");\n            // Enable code 2 to get string\n            } else if (num === 3) {\n                  self.decorations.push(\"italic\");\n            } else if (num === 4) {\n                self.decorations.push(\"underline\");\n            } else if (num === 5) {\n                self.decorations.push(\"blink\");\n            } else if (num === 7) {\n                self.decorations.push(\"reverse\");\n            } else if (num === 8) {\n                self.decorations.push(\"hidden\");\n            // Enable code 9 to get strikethrough\n            } else if (num === 9) {\n                self.decorations.push(\"strikethrough\");\n            /**\n             * Add several widely used style codes\n             * @see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters\n             */\n            } else if (num === 21) {\n                self.removeDecoration(\"bold\");\n            } else if (num === 22) {\n                self.removeDecoration(\"bold\");\n                self.removeDecoration(\"dim\");\n            } else if (num === 23) {\n                self.removeDecoration(\"italic\");\n            } else if (num === 24) {\n                self.removeDecoration(\"underline\");\n            } else if (num === 25) {\n                self.removeDecoration(\"blink\");\n            } else if (num === 27) {\n                self.removeDecoration(\"reverse\");\n            } else if (num === 28) {\n                self.removeDecoration(\"hidden\");\n            } else if (num === 29) {\n                self.removeDecoration(\"strikethrough\");\n            } else if (num === 39) {\n                self.fg = null;\n            } else if (num === 49) {\n                self.bg = null;\n            // Foreground color\n            } else if ((num >= 30) && (num < 38)) {\n                self.fg = ANSI_COLORS[0][(num % 10)][key];\n            // Foreground bright color\n            } else if ((num >= 90) && (num < 98)) {\n                self.fg = ANSI_COLORS[1][(num % 10)][key];\n            // Background color\n            } else if ((num >= 40) && (num < 48)) {\n                self.bg = ANSI_COLORS[0][(num % 10)][key];\n            // Background bright color\n            } else if ((num >= 100) && (num < 108)) {\n                self.bg = ANSI_COLORS[1][(num % 10)][key];\n            } else if (num === 38 || num === 48) { // extend color (38=fg, 48=bg)\n                let is_foreground = (num === 38);\n                if (nums.length >= 1) {\n                    let mode = nums.shift();\n                    if (mode === \"5\" && nums.length >= 1) { // palette color\n                        let palette_index = parseInt(nums.shift());\n                        if (palette_index >= 0 && palette_index <= 255) {\n                            if (!use_classes) {\n                                if (!this.PALETTE_COLORS) {\n                                    self.setupPalette();\n                                }\n                                if (is_foreground) {\n                                    self.fg = this.PALETTE_COLORS[palette_index];\n                                } else {\n                                    self.bg = this.PALETTE_COLORS[palette_index];\n                                }\n                            } else {\n                                let klass = (palette_index >= 16)\n                                    ? (\"ansi-palette-\" + palette_index)\n                                    : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8][\"class\"];\n                                    if (is_foreground) {\n                                        self.fg = klass;\n                                    } else {\n                                        self.bg = klass;\n                                    }\n                            }\n                        }\n                    } else if(mode === \"2\" && nums.length >= 3) { // true color\n                        let r = parseInt(nums.shift());\n                        let g = parseInt(nums.shift());\n                        let b = parseInt(nums.shift());\n                        if ((r >= 0 && r <= 255) && (g >= 0 && g <= 255) && (b >= 0 && b <= 255)) {\n                            let color = r + \", \" + g + \", \" + b;\n                            if (!use_classes) {\n                                if (is_foreground) {\n                                    self.fg = color;\n                                } else {\n                                    self.bg = color;\n                                }\n                            } else {\n                                if (is_foreground) {\n                                    self.fg = \"ansi-truecolor\";\n                                    self.fg_truecolor = color;\n                                } else {\n                                    self.bg = \"ansi-truecolor\";\n                                    self.bg_truecolor = color;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if ((self.fg === null) && (self.bg === null) && (self.decorations.length === 0)) {\n            return result;\n        } else {\n            let styles = [];\n            let classes = [];\n            let data = {};\n\n            result.fg = self.fg;\n            result.bg = self.bg;\n            result.fg_truecolor = self.fg_truecolor;\n            result.bg_truecolor = self.bg_truecolor;\n            result.decorations = self.decorations;\n            result.decoration = self.decorations.slice(-1).pop() || null;\n            result.was_processed = true;\n\n            return result;\n        }\n    }\n\n    /**\n     * processChunk\n     * Processes the current chunk of text.\n     *\n     * @name processChunk\n     * @function\n     * @param {String} text The input text.\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup If false, the colors will not be parsed.\n     * @return {Object|String} The result (object if `json` is wanted back or string otherwise).\n     */\n    processChunk (text, options, markup) {\n        options = options || {};\n        let jsonChunk = this.processChunkJson(text, options, markup);\n        let use_classes = options.use_classes;\n\n        // \"reverse\" decoration reverses foreground and background colors\n        jsonChunk.decorations = jsonChunk.decorations\n            .filter((decoration) => {\n                if (decoration === \"reverse\") {\n                    // when reversing, missing colors are defaulted to black (bg) and white (fg)\n                    if (!jsonChunk.fg) {\n                      jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? \"class\" : \"color\"];\n                    }\n                    if (!jsonChunk.bg) {\n                      jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? \"class\" : \"color\"];\n                    }\n                    let tmpFg = jsonChunk.fg;\n                    jsonChunk.fg = jsonChunk.bg;\n                    jsonChunk.bg = tmpFg;\n                    let tmpFgTrue = jsonChunk.fg_truecolor;\n                    jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;\n                    jsonChunk.bg_truecolor = tmpFgTrue;\n                    jsonChunk.isInverted = true;\n                    return false;\n                }\n                return true;\n            });\n\n        if (options.json) { return jsonChunk; }\n        if (jsonChunk.isEmpty()) { return \"\"; }\n        if (!jsonChunk.was_processed) { return jsonChunk.content; }\n\n        let colors = [];\n        let decorations = [];\n        let textDecorations = [];\n        let data = {};\n\n        let render_data = data => {\n            let fragments = [];\n            let key;\n            for (key in data) {\n                if (data.hasOwnProperty(key)) {\n                    fragments.push(\"data-\" + key + \"=\\\"\" + this.escapeForHtml(data[key]) + \"\\\"\");\n                }\n            }\n            return fragments.length > 0 ? \" \" + fragments.join(\" \") : \"\";\n        };\n\n        if (jsonChunk.isInverted) {\n          data[\"ansi-is-inverted\"] = \"true\";\n        }\n\n        if (jsonChunk.fg) {\n            if (use_classes) {\n                colors.push(jsonChunk.fg + \"-fg\");\n                if (jsonChunk.fg_truecolor !== null) {\n                    data[\"ansi-truecolor-fg\"] = jsonChunk.fg_truecolor;\n                    jsonChunk.fg_truecolor = null;\n                }\n            } else {\n                colors.push(\"color:rgb(\" + jsonChunk.fg + \")\");\n            }\n        }\n\n        if (jsonChunk.bg) {\n            if (use_classes) {\n                colors.push(jsonChunk.bg + \"-bg\");\n                if (jsonChunk.bg_truecolor !== null) {\n                    data[\"ansi-truecolor-bg\"] = jsonChunk.bg_truecolor;\n                    jsonChunk.bg_truecolor = null;\n                }\n            } else {\n              colors.push(\"background-color:rgb(\" + jsonChunk.bg + \")\");\n            }\n        }\n\n        jsonChunk.decorations.forEach((decoration) => {\n            // use classes\n            if (use_classes) {\n                decorations.push(\"ansi-\" + decoration);\n                return;\n            }\n            // use styles\n            if (decoration === \"bold\") {\n                decorations.push(\"font-weight:bold\");\n            } else if (decoration === \"dim\") {\n                decorations.push(\"opacity:0.5\");\n            } else if (decoration === \"italic\") {\n                decorations.push(\"font-style:italic\");\n            } else if (decoration === \"hidden\") {\n                decorations.push(\"visibility:hidden\");\n            } else if (decoration === \"strikethrough\") {\n                textDecorations.push(\"line-through\");\n            } else {\n                // underline and blink are treated here\n                textDecorations.push(decoration);\n            }\n        });\n\n        if (textDecorations.length) {\n            decorations.push(\"text-decoration:\" + textDecorations.join(\" \"));\n        }\n\n        if (use_classes) {\n            return \"<span class=\\\"\" + colors.concat(decorations).join(\" \") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n        } else {\n            return \"<span style=\\\"\" + colors.concat(decorations).join(\";\") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n        }\n    }\n\n    removeDecoration(decoration) {\n        const index = this.decorations.indexOf(decoration);\n\n        if (index >= 0) {\n            this.decorations.splice(index, 1);\n        }\n    }\n}\n\nmodule.exports = Anser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5zZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsY0FBYyxFQUFFOztBQUV6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktYXBwLWJ1aWxkZXItd2ViLy4vbm9kZV9tb2R1bGVzL2Fuc2VyL2xpYi9pbmRleC5qcz85YTYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGZpbGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBAZHJ1ZHJ1IChodHRwczovL2dpdGh1Yi5jb20vZHJ1ZHJ1L2Fuc2lfdXApLCBNSVQsIDIwMTFcblxuY29uc3QgQU5TSV9DT0xPUlMgPSBbXG4gICAgW1xuICAgICAgICB7IGNvbG9yOiBcIjAsIDAsIDBcIiwgICAgICAgIFwiY2xhc3NcIjogXCJhbnNpLWJsYWNrXCIgICB9XG4gICAgICAsIHsgY29sb3I6IFwiMTg3LCAwLCAwXCIsICAgICAgXCJjbGFzc1wiOiBcImFuc2ktcmVkXCIgICAgIH1cbiAgICAgICwgeyBjb2xvcjogXCIwLCAxODcsIDBcIiwgICAgICBcImNsYXNzXCI6IFwiYW5zaS1ncmVlblwiICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjE4NywgMTg3LCAwXCIsICAgIFwiY2xhc3NcIjogXCJhbnNpLXllbGxvd1wiICB9XG4gICAgICAsIHsgY29sb3I6IFwiMCwgMCwgMTg3XCIsICAgICAgXCJjbGFzc1wiOiBcImFuc2ktYmx1ZVwiICAgIH1cbiAgICAgICwgeyBjb2xvcjogXCIxODcsIDAsIDE4N1wiLCAgICBcImNsYXNzXCI6IFwiYW5zaS1tYWdlbnRhXCIgfVxuICAgICAgLCB7IGNvbG9yOiBcIjAsIDE4NywgMTg3XCIsICAgIFwiY2xhc3NcIjogXCJhbnNpLWN5YW5cIiAgICB9XG4gICAgICAsIHsgY29sb3I6IFwiMjU1LDI1NSwyNTVcIiwgICAgXCJjbGFzc1wiOiBcImFuc2ktd2hpdGVcIiAgIH1cbiAgICBdXG4gICwgW1xuICAgICAgICB7IGNvbG9yOiBcIjg1LCA4NSwgODVcIiwgICAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ibGFja1wiICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjI1NSwgODUsIDg1XCIsICAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1yZWRcIiAgICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjAsIDI1NSwgMFwiLCAgICAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ncmVlblwiICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjI1NSwgMjU1LCA4NVwiLCAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC15ZWxsb3dcIiAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjg1LCA4NSwgMjU1XCIsICAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ibHVlXCIgICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjI1NSwgODUsIDI1NVwiLCAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1tYWdlbnRhXCIgfVxuICAgICAgLCB7IGNvbG9yOiBcIjg1LCAyNTUsIDI1NVwiLCAgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1jeWFuXCIgICAgfVxuICAgICAgLCB7IGNvbG9yOiBcIjI1NSwgMjU1LCAyNTVcIiwgIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC13aGl0ZVwiICAgfVxuICAgIF1cbl07XG4vLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuY29uc3QgbGlua1JlZ2V4ID0gLyhodHRwcz86XFwvXFwvKD86W0EtWmEtejAtOSM7Lz86QD0rJCcsXy4hfiooKVtcXF0tXXwmYW1wO3wlW0EtRmEtZjAtOV17Mn0pKykvZ207XG5cbmNsYXNzIEFuc2VyIHtcblxuICAgIC8qKlxuICAgICAqIEFuc2VyLmVzY2FwZUZvckh0bWxcbiAgICAgKiBFc2NhcGUgdGhlIGlucHV0IEhUTUwuXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgdGhlIG1pbmltdW0gZXNjYXBpbmcgb2YgdGV4dCB0byBtYWtlIGl0IGNvbXBsaWFudCB3aXRoIEhUTUwuXG4gICAgICogSW4gcGFydGljdWxhciwgdGhlICcmJywnPCcsIGFuZCAnPicgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVGhpcyBzaG91bGRcbiAgICAgKiBiZSBydW4gcHJpb3IgdG8gYGFuc2lUb0h0bWxgLlxuICAgICAqXG4gICAgICogQG5hbWUgQW5zZXIuZXNjYXBlRm9ySHRtbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQgKGNvbnRhaW5pbmcgdGhlIEFOU0kgc25pcHBldHMpLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBlc2NhcGVkIGh0bWwuXG4gICAgICovXG4gICAgc3RhdGljIGVzY2FwZUZvckh0bWwgKHR4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuZXNjYXBlRm9ySHRtbCh0eHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuc2VyLmxpbmtpZnlcbiAgICAgKiBBZGRzIHRoZSBsaW5rcyBpbiB0aGUgSFRNTC5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGxpbmtzIGluIHRoZSB0ZXh0IHdpdGggYW5jaG9yIHRhZ3MgdGhhdCBkaXNwbGF5IHRoZVxuICAgICAqIGxpbmsuIFlvdSBzaG91bGQgYXBwbHkgdGhpcyBhZnRlciB5b3UgaGF2ZSBydW4gYGFuc2lUb0h0bWxgIG9uIHRoZSB0ZXh0LlxuICAgICAqXG4gICAgICogQG5hbWUgQW5zZXIubGlua2lmeVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgY29udGFpbmluZyB0aGUgPGE+IHRhZ3MgKHVuZXNjYXBlZCkuXG4gICAgICovXG4gICAgc3RhdGljIGxpbmtpZnkgKHR4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkubGlua2lmeSh0eHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuc2VyLmFuc2lUb0h0bWxcbiAgICAgKiBUaGlzIHJlcGxhY2VzIEFOU0kgdGVybWluYWwgZXNjYXBlIGNvZGVzIHdpdGggU1BBTiB0YWdzIHRoYXQgd3JhcCB0aGVcbiAgICAgKiBjb250ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBvbmx5IGludGVycHJldHMgQU5TSSBTR1IgKFNlbGVjdCBHcmFwaGljIFJlbmRpdGlvbikgY29kZXNcbiAgICAgKiB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBIVE1MLlxuICAgICAqIEZvciBleGFtcGxlLCBjdXJzb3IgbW92ZW1lbnQgY29kZXMgYXJlIGlnbm9yZWQgYW5kIGhpZGRlbiBmcm9tIG91dHB1dC5cbiAgICAgKiBUaGUgZGVmYXVsdCBzdHlsZSB1c2VzIGNvbG9ycyB0aGF0IGFyZSB2ZXJ5IGNsb3NlIHRvIHRoZSBwcmVzY3JpYmVkXG4gICAgICogc3RhbmRhcmQuIFRoZSBzdGFuZGFyZCBhc3N1bWVzIHRoYXQgdGhlIHRleHQgd2lsbCBoYXZlIGEgYmxhY2tcbiAgICAgKiBiYWNrZ3JvdW5kLiBUaGVzZSBjb2xvcnMgYXJlIHNldCBhcyBpbmxpbmUgc3R5bGVzIG9uIHRoZSBTUEFOIHRhZ3MuXG4gICAgICpcbiAgICAgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzZXQgYHVzZV9jbGFzc2VzOiB0cnVlYCBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cbiAgICAgKiBUaGlzIHdpbGwgaW5zdGVhZCBzZXQgY2xhc3NlcyBvbiB0aGUgc3BhbnMgc28gdGhlIGNvbG9ycyBjYW4gYmUgc2V0IHZpYVxuICAgICAqIENTUy4gVGhlIGNsYXNzIG5hbWVzIHVzZWQgYXJlIG9mIHRoZSBmb3JtYXQgYGFuc2ktKi1mZy9iZ2AgYW5kXG4gICAgICogYGFuc2ktYnJpZ2h0LSotZmcvYmdgIHdoZXJlIGAqYCBpcyB0aGUgY29sb3IgbmFtZSxcbiAgICAgKiBpLmUgYmxhY2svcmVkL2dyZWVuL3llbGxvdy9ibHVlL21hZ2VudGEvY3lhbi93aGl0ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIEFuc2VyLmFuc2lUb0h0bWxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgYW5zaVRvSFRNTCBtZXRob2QuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhbnNpVG9IdG1sICh0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmFuc2lUb0h0bWwodHh0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbnNlci5hbnNpVG9Kc29uXG4gICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEpTT04gb3V0cHV0LlxuICAgICAqXG4gICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSnNvblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGFuc2lUb0pzb24gKHR4dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuc2VyLmFuc2lUb1RleHRcbiAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gdGV4dCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBBbnNlci5hbnNpVG9UZXh0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdGV4dCBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGFuc2lUb1RleHQgKHR4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvVGV4dCh0eHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuc2VyXG4gICAgICogVGhlIGBBbnNlcmAgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAbmFtZSBBbnNlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBbnNlcn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMuZmcgPSB0aGlzLmJnID0gdGhpcy5mZ190cnVlY29sb3IgPSB0aGlzLmJnX3RydWVjb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHVwUGFsZXR0ZVxuICAgICAqIFNldHMgdXAgdGhlIHBhbGV0dGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzZXR1cFBhbGV0dGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZXR1cFBhbGV0dGUgKCkge1xuICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTID0gW107XG5cbiAgICAgICAgLy8gSW5kZXggMC4uMTUgOiBTeXN0ZW0gY29sb3JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgKytqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKEFOU0lfQ09MT1JTW2ldW2pdLmNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZGV4IDE2Li4yMzEgOiBSR0IgNng2eDZcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamFzb25tMjMvMjg2ODk4MSNmaWxlLXh0ZXJtLTI1NmNvbG9yLXlhbWxcbiAgICAgICAgbGV0IGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICAgICAgbGV0IGZvcm1hdCA9IChyLCBnLCBiKSA9PiBsZXZlbHNbcl0gKyBcIiwgXCIgKyBsZXZlbHNbZ10gKyBcIiwgXCIgKyBsZXZlbHNbYl07XG4gICAgICAgIGxldCByLCBnLCBiO1xuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IDY7ICsrcikge1xuICAgICAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCA2OyArK2cpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IDY7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTLnB1c2goZm9ybWF0KHIsIGcsIGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmRleCAyMzIuLjI1NSA6IEdyYXlzY2FsZVxuICAgICAgICBsZXQgbGV2ZWwgPSA4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyArK2ksIGxldmVsICs9IDEwKSB7XG4gICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTLnB1c2gobGV2ZWwgKyBcIiwgXCIgKyBsZXZlbCArIFwiLCBcIiArIGxldmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGVzY2FwZUZvckh0bWxcbiAgICAgKiBFc2NhcGVzIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAqXG4gICAgICogQG5hbWUgZXNjYXBlRm9ySHRtbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY3BhZWQgSFRNTCBvdXRwdXQuXG4gICAgICovXG4gICAgZXNjYXBlRm9ySHRtbCAodHh0KSB7XG4gICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvWyY8PlxcXCJdL2dtLCBzdHIgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PSBcIiZcIiA/IFwiJmFtcDtcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09ICdcIicgPyBcIiZxdW90O1wiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT0gXCI8XCIgPyBcIiZsdDtcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09IFwiPlwiID8gXCImZ3Q7XCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbGlua2lmeVxuICAgICAqIEFkZHMgSFRNTCBsaW5rIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQG5hbWUgbGlua2lmeVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0IGNvbnRhaW5pbmcgbGluayBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBsaW5raWZ5ICh0eHQpIHtcbiAgICAgICAgcmV0dXJuIHR4dC5yZXBsYWNlKGxpbmtSZWdleCwgc3RyID0+IGA8YSBocmVmPVwiJHtzdHJ9XCI+JHtzdHJ9PC9hPmApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFuc2lUb0h0bWxcbiAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhbnNpVG9IdG1sXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgb3QgdGhlIGBwcm9jZXNzYCBtZXRob2QuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAqL1xuICAgIGFuc2lUb0h0bWwgKHR4dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYW5zaVRvSnNvblxuICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGFuc2lUb0pzb25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCBvdCB0aGUgYHByb2Nlc3NgIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgYW5zaVRvSnNvbiAodHh0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmpzb24gPSB0cnVlO1xuICAgICAgICBvcHRpb25zLmNsZWFyTGluZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYW5zaVRvVGV4dFxuICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGFuc2lUb1RleHRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cbiAgICAgKi9cbiAgICBhbnNpVG9UZXh0ICh0eHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIHt9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJvY2Vzc1xuICAgICAqIFByb2Nlc3NlcyB0aGUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwcm9jZXNzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIGBwcm9jZXNzQ2h1bmtgIG1ldGhvZCwgZXh0ZW5kZWQgd2l0aDpcbiAgICAgKlxuICAgICAqICAtIGBqc29uYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIG9iamVjdC5cbiAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hcmt1cFxuICAgICAqL1xuICAgIHByb2Nlc3MgKHR4dCwgb3B0aW9ucywgbWFya3VwKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHJhd190ZXh0X2NodW5rcyA9IHR4dC5zcGxpdCgvXFwwMzNcXFsvKTtcbiAgICAgICAgbGV0IGZpcnN0X2NodW5rID0gcmF3X3RleHRfY2h1bmtzLnNoaWZ0KCk7IC8vIHRoZSBmaXJzdCBjaHVuayBpcyBub3QgdGhlIHJlc3VsdCBvZiB0aGUgc3BsaXRcblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmNsZWFyTGluZSA9IC9cXHIvLnRlc3QodHh0KTsgLy8gY2hlY2sgZm9yIENhcnJpYWdlIFJldHVyblxuICAgICAgICBsZXQgY29sb3JfY2h1bmtzID0gcmF3X3RleHRfY2h1bmtzLm1hcChjaHVuayA9PiB0aGlzLnByb2Nlc3NDaHVuayhjaHVuaywgb3B0aW9ucywgbWFya3VwKSlcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24pIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHNlbGYucHJvY2Vzc0NodW5rSnNvbihcIlwiKTtcbiAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdF9jaHVuaztcbiAgICAgICAgICAgIGZpcnN0LmNsZWFyTGluZSA9IG9wdGlvbnMuY2xlYXJMaW5lO1xuICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3QpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlX2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzID0gY29sb3JfY2h1bmtzLmZpbHRlcihjID0+ICFjLmlzRW1wdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sb3JfY2h1bmtzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3RfY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcy5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb2Nlc3NDaHVua0pzb25cbiAgICAgKiBQcm9jZXNzZXMgdGhlIGN1cnJlbnQgY2h1bmsgaW50byBqc29uIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHByb2Nlc3NDaHVua0pzb25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKlxuICAgICAqICAtIGBqc29uYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIG9iamVjdC5cbiAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hcmt1cCBJZiBmYWxzZSwgdGhlIGNvbG9ycyB3aWxsIG5vdCBiZSBwYXJzZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0IG9iamVjdDpcbiAgICAgKlxuICAgICAqICAtIGBjb250ZW50YCAoU3RyaW5nKTogVGhlIHRleHQuXG4gICAgICogIC0gYGZnYCAoU3RyaW5nfG51bGwpOiBUaGUgZm9yZWdyb3VuZCBjb2xvci5cbiAgICAgKiAgLSBgYmdgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAqICAtIGBmZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cbiAgICAgKiAgLSBgYmdfdHJ1ZWNvbG9yYCAoU3RyaW5nfG51bGwpOiBUaGUgYmFja2dyb3VuZCB0cnVlIGNvbG9yIChpZiAxNm0gY29sb3IgaXMgZW5hYmxlZCkuXG4gICAgICogIC0gYGNsZWFyTGluZWAgKEJvb2xlYW4pOiBgdHJ1ZWAgaWYgYSBjYXJyaWFnZVJldHVybiBcXHIgd2FzIGZvdW50IGF0IGVuZCBvZiBsaW5lLlxuICAgICAqICAtIGB3YXNfcHJvY2Vzc2VkYCAoQm9sZWFuKTogYHRydWVgIGlmIHRoZSBjb2xvcnMgd2VyZSBwcm9jZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqICAtIGBpc0VtcHR5YCAoRnVuY3Rpb24pOiBBIGZ1bmN0aW9uIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGNvbnRlbnQgaXMgZW1wdHksIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvY2Vzc0NodW5rSnNvbiAodGV4dCwgb3B0aW9ucywgbWFya3VwKSB7XG5cbiAgICAgICAgLy8gQXJlIHdlIHVzaW5nIGNsYXNzZXMgb3Igc3R5bGVzP1xuICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT0gXCJ1bmRlZmluZWRcIiA/IHt9IDogb3B0aW9ucztcbiAgICAgICAgbGV0IHVzZV9jbGFzc2VzID0gb3B0aW9ucy51c2VfY2xhc3NlcyA9IHR5cGVvZiBvcHRpb25zLnVzZV9jbGFzc2VzICE9IFwidW5kZWZpbmVkXCIgJiYgb3B0aW9ucy51c2VfY2xhc3NlcztcbiAgICAgICAgbGV0IGtleSA9IG9wdGlvbnMua2V5ID0gdXNlX2NsYXNzZXMgPyBcImNsYXNzXCIgOiBcImNvbG9yXCI7XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRcbiAgICAgICAgICAsIGZnOiBudWxsXG4gICAgICAgICAgLCBiZzogbnVsbFxuICAgICAgICAgICwgZmdfdHJ1ZWNvbG9yOiBudWxsXG4gICAgICAgICAgLCBiZ190cnVlY29sb3I6IG51bGxcbiAgICAgICAgICAsIGlzSW52ZXJ0ZWQ6IGZhbHNlXG4gICAgICAgICAgLCBjbGVhckxpbmU6IG9wdGlvbnMuY2xlYXJMaW5lXG4gICAgICAgICAgLCBkZWNvcmF0aW9uOiBudWxsXG4gICAgICAgICAgLCBkZWNvcmF0aW9uczogW11cbiAgICAgICAgICAsIHdhc19wcm9jZXNzZWQ6IGZhbHNlXG4gICAgICAgICAgLCBpc0VtcHR5OiAoKSA9PiAhcmVzdWx0LmNvbnRlbnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFYWNoIFwiY2h1bmtcIiBpcyB0aGUgdGV4dCBhZnRlciB0aGUgQ1NJIChFU0MgKyBcIltcIikgYW5kIGJlZm9yZSB0aGUgbmV4dCBDU0kvRU9GLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIHJlZ2V4IG1hdGNoZXMgZm91ciBncm91cHMgd2l0aGluIGEgY2h1bmsuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgdGhpcmQgZ3JvdXBzIG1hdGNoIGNvZGUgdHlwZS5cbiAgICAgICAgLy8gV2Ugc3VwcG9ydGVkIG9ubHkgU0dSIGNvbW1hbmQuIEl0IGhhcyBlbXB0eSBmaXJzdCBncm91cCBhbmQgXCJtXCIgaW4gdGhpcmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgZ3JvdXAgbWF0Y2hlcyBhbGwgb2YgdGhlIG51bWJlcitzZW1pY29sb24gY29tbWFuZCBzZXF1ZW5jZXNcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBcIm1cIiAob3Igb3RoZXIgdHJhaWxpbmcpIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBncmFwaGljcyBvciBTR1IgY29tbWFuZHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBsYXN0IGdyb3VwIGlzIHRoZSB0ZXh0IChpbmNsdWRpbmcgbmV3bGluZXMpIHRoYXQgaXMgY29sb3JlZCBieVxuICAgICAgICAvLyB0aGUgb3RoZXIgZ3JvdXBcInMgY29tbWFuZHMuXG4gICAgICAgIGxldCBtYXRjaGVzID0gdGV4dC5tYXRjaCgvXihbIVxceDNjLVxceDNmXSopKFtcXGQ7XSopKFtcXHgyMC1cXHgyY10qW1xceDQwLVxceDdlXSkoW1xcc1xcU10qKS9tKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgbGV0IG9yaWdfdHh0ID0gcmVzdWx0LmNvbnRlbnQgPSBtYXRjaGVzWzRdO1xuICAgICAgICBsZXQgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgIC8vIFdlIGN1cnJlbnRseSBzdXBwb3J0IG9ubHkgXCJTR1JcIiAoU2VsZWN0IEdyYXBoaWMgUmVuZGl0aW9uKVxuICAgICAgICAvLyBTaW1wbHkgaWdub3JlIGlmIG5vdCBhIFNHUiBjb21tYW5kLlxuICAgICAgICBpZiAobWF0Y2hlc1sxXSAhPT0gXCJcIiB8fCBtYXRjaGVzWzNdICE9PSBcIm1cIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHdoaWxlIChudW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBudW1fc3RyID0gbnVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgbGV0IG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4obnVtKSB8fCBudW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZnID0gc2VsZi5iZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb25zLnB1c2goXCJib2xkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb25zLnB1c2goXCJkaW1cIik7XG4gICAgICAgICAgICAvLyBFbmFibGUgY29kZSAyIHRvIGdldCBzdHJpbmdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb25zLnB1c2goXCJpdGFsaWNcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcInVuZGVybGluZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA1KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwiYmxpbmtcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gNykge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcInJldmVyc2VcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcImhpZGRlblwiKTtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBjb2RlIDkgdG8gZ2V0IHN0cmlrZXRocm91Z2hcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA5KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwic3RyaWtldGhyb3VnaFwiKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIHNldmVyYWwgd2lkZWx5IHVzZWQgc3R5bGUgY29kZXNcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNTR1JfKFNlbGVjdF9HcmFwaGljX1JlbmRpdGlvbilfcGFyYW1ldGVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJib2xkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDIyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwiYm9sZFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJkaW1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJpdGFsaWNcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJ1bmRlcmxpbmVcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJibGlua1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAyNykge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGVjb3JhdGlvbihcInJldmVyc2VcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJzdHJpa2V0aHJvdWdoXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDM5KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5mZyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJnID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZvcmVncm91bmQgY29sb3JcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKG51bSA+PSAzMCkgJiYgKG51bSA8IDM4KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1swXVsobnVtICUgMTApXVtrZXldO1xuICAgICAgICAgICAgLy8gRm9yZWdyb3VuZCBicmlnaHQgY29sb3JcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKG51bSA+PSA5MCkgJiYgKG51bSA8IDk4KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1sxXVsobnVtICUgMTApXVtrZXldO1xuICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgfSBlbHNlIGlmICgobnVtID49IDQwKSAmJiAobnVtIDwgNDgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5iZyA9IEFOU0lfQ09MT1JTWzBdWyhudW0gJSAxMCldW2tleV07XG4gICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGJyaWdodCBjb2xvclxuICAgICAgICAgICAgfSBlbHNlIGlmICgobnVtID49IDEwMCkgJiYgKG51bSA8IDEwOCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJnID0gQU5TSV9DT0xPUlNbMV1bKG51bSAlIDEwKV1ba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAzOCB8fCBudW0gPT09IDQ4KSB7IC8vIGV4dGVuZCBjb2xvciAoMzg9ZmcsIDQ4PWJnKVxuICAgICAgICAgICAgICAgIGxldCBpc19mb3JlZ3JvdW5kID0gKG51bSA9PT0gMzgpO1xuICAgICAgICAgICAgICAgIGlmIChudW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb2RlID0gbnVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCI1XCIgJiYgbnVtcy5sZW5ndGggPj0gMSkgeyAvLyBwYWxldHRlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFsZXR0ZV9pbmRleCA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFsZXR0ZV9pbmRleCA+PSAwICYmIHBhbGV0dGVfaW5kZXggPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuUEFMRVRURV9DT0xPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0dXBQYWxldHRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IHRoaXMuUEFMRVRURV9DT0xPUlNbcGFsZXR0ZV9pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQga2xhc3MgPSAocGFsZXR0ZV9pbmRleCA+PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwiYW5zaS1wYWxldHRlLVwiICsgcGFsZXR0ZV9pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogQU5TSV9DT0xPUlNbcGFsZXR0ZV9pbmRleCA+IDcgPyAxIDogMF1bcGFsZXR0ZV9pbmRleCAlIDhdW1wiY2xhc3NcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBrbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGtsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG1vZGUgPT09IFwiMlwiICYmIG51bXMubGVuZ3RoID49IDMpIHsgLy8gdHJ1ZSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGIgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyID49IDAgJiYgciA8PSAyNTUpICYmIChnID49IDAgJiYgZyA8PSAyNTUpICYmIChiID49IDAgJiYgYiA8PSAyNTUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gXCJhbnNpLXRydWVjb2xvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZ190cnVlY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBcImFuc2ktdHJ1ZWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnX3RydWVjb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChzZWxmLmZnID09PSBudWxsKSAmJiAoc2VsZi5iZyA9PT0gbnVsbCkgJiYgKHNlbGYuZGVjb3JhdGlvbnMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdHlsZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjbGFzc2VzID0gW107XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xuXG4gICAgICAgICAgICByZXN1bHQuZmcgPSBzZWxmLmZnO1xuICAgICAgICAgICAgcmVzdWx0LmJnID0gc2VsZi5iZztcbiAgICAgICAgICAgIHJlc3VsdC5mZ190cnVlY29sb3IgPSBzZWxmLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgIHJlc3VsdC5iZ190cnVlY29sb3IgPSBzZWxmLmJnX3RydWVjb2xvcjtcbiAgICAgICAgICAgIHJlc3VsdC5kZWNvcmF0aW9ucyA9IHNlbGYuZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXN1bHQuZGVjb3JhdGlvbiA9IHNlbGYuZGVjb3JhdGlvbnMuc2xpY2UoLTEpLnBvcCgpIHx8IG51bGw7XG4gICAgICAgICAgICByZXN1bHQud2FzX3Byb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9jZXNzQ2h1bmtcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGN1cnJlbnQgY2h1bmsgb2YgdGV4dC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHByb2Nlc3NDaHVua1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqXG4gICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8U3RyaW5nfSBUaGUgcmVzdWx0IChvYmplY3QgaWYgYGpzb25gIGlzIHdhbnRlZCBiYWNrIG9yIHN0cmluZyBvdGhlcndpc2UpLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayAodGV4dCwgb3B0aW9ucywgbWFya3VwKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQganNvbkNodW5rID0gdGhpcy5wcm9jZXNzQ2h1bmtKc29uKHRleHQsIG9wdGlvbnMsIG1hcmt1cCk7XG4gICAgICAgIGxldCB1c2VfY2xhc3NlcyA9IG9wdGlvbnMudXNlX2NsYXNzZXM7XG5cbiAgICAgICAgLy8gXCJyZXZlcnNlXCIgZGVjb3JhdGlvbiByZXZlcnNlcyBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9yc1xuICAgICAgICBqc29uQ2h1bmsuZGVjb3JhdGlvbnMgPSBqc29uQ2h1bmsuZGVjb3JhdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKGRlY29yYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdGlvbiA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiByZXZlcnNpbmcsIG1pc3NpbmcgY29sb3JzIGFyZSBkZWZhdWx0ZWQgdG8gYmxhY2sgKGJnKSBhbmQgd2hpdGUgKGZnKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5mZyA9IEFOU0lfQ09MT1JTWzBdWzddW3VzZV9jbGFzc2VzID8gXCJjbGFzc1wiIDogXCJjb2xvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzb25DaHVuay5iZykge1xuICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZyA9IEFOU0lfQ09MT1JTWzBdWzBdW3VzZV9jbGFzc2VzID8gXCJjbGFzc1wiIDogXCJjb2xvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdG1wRmcgPSBqc29uQ2h1bmsuZmc7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5mZyA9IGpzb25DaHVuay5iZztcbiAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmJnID0gdG1wRmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bXBGZ1RydWUgPSBqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yID0ganNvbkNodW5rLmJnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmJnX3RydWVjb2xvciA9IHRtcEZnVHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmlzSW52ZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuanNvbikgeyByZXR1cm4ganNvbkNodW5rOyB9XG4gICAgICAgIGlmIChqc29uQ2h1bmsuaXNFbXB0eSgpKSB7IHJldHVybiBcIlwiOyB9XG4gICAgICAgIGlmICghanNvbkNodW5rLndhc19wcm9jZXNzZWQpIHsgcmV0dXJuIGpzb25DaHVuay5jb250ZW50OyB9XG5cbiAgICAgICAgbGV0IGNvbG9ycyA9IFtdO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHRleHREZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuXG4gICAgICAgIGxldCByZW5kZXJfZGF0YSA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgbGV0IGZyYWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIHRoaXMuZXNjYXBlRm9ySHRtbChkYXRhW2tleV0pICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHMubGVuZ3RoID4gMCA/IFwiIFwiICsgZnJhZ21lbnRzLmpvaW4oXCIgXCIpIDogXCJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoanNvbkNodW5rLmlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICBkYXRhW1wiYW5zaS1pcy1pbnZlcnRlZFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goanNvbkNodW5rLmZnICsgXCItZmdcIik7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZ190cnVlY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFuc2ktdHJ1ZWNvbG9yLWZnXCJdID0ganNvbkNodW5rLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmZnX3RydWVjb2xvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChcImNvbG9yOnJnYihcIiArIGpzb25DaHVuay5mZyArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqc29uQ2h1bmsuYmcpIHtcbiAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKGpzb25DaHVuay5iZyArIFwiLWJnXCIpO1xuICAgICAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1iZ1wiXSA9IGpzb25DaHVuay5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbG9ycy5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuYmcgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBqc29uQ2h1bmsuZGVjb3JhdGlvbnMuZm9yRWFjaCgoZGVjb3JhdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gdXNlIGNsYXNzZXNcbiAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goXCJhbnNpLVwiICsgZGVjb3JhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIHN0eWxlc1xuICAgICAgICAgICAgaWYgKGRlY29yYXRpb24gPT09IFwiYm9sZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcImZvbnQtd2VpZ2h0OmJvbGRcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwiZGltXCIpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwib3BhY2l0eTowLjVcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwiaXRhbGljXCIpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwiZm9udC1zdHlsZTppdGFsaWNcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwidmlzaWJpbGl0eTpoaWRkZW5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwic3RyaWtldGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgdGV4dERlY29yYXRpb25zLnB1c2goXCJsaW5lLXRocm91Z2hcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVuZGVybGluZSBhbmQgYmxpbmsgYXJlIHRyZWF0ZWQgaGVyZVxuICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGV4dERlY29yYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcInRleHQtZGVjb3JhdGlvbjpcIiArIHRleHREZWNvcmF0aW9ucy5qb2luKFwiIFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPVxcXCJcIiArIGNvbG9ycy5jb25jYXQoZGVjb3JhdGlvbnMpLmpvaW4oXCIgXCIpICsgXCJcXFwiXCIgKyByZW5kZXJfZGF0YShkYXRhKSArIFwiPlwiICsganNvbkNodW5rLmNvbnRlbnQgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIGNvbG9ycy5jb25jYXQoZGVjb3JhdGlvbnMpLmpvaW4oXCI7XCIpICsgXCJcXFwiXCIgKyByZW5kZXJfZGF0YShkYXRhKSArIFwiPlwiICsganNvbkNodW5rLmNvbnRlbnQgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZURlY29yYXRpb24oZGVjb3JhdGlvbikge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVjb3JhdGlvbnMuaW5kZXhPZihkZWNvcmF0aW9uKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/anser/lib/index.js\n");

/***/ })

};
;