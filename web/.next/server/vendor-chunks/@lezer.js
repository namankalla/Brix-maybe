"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n    /**\n    Create a new node prop type.\n    */\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n        this.combine = config.combine || null;\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/\nNodeProp.isolate = new NodeProp({ deserialize: value => {\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\")\n            throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    } });\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({ perNode: true });\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n    constructor(\n    /**\n    The inner tree.\n    */\n    tree, \n    /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */\n    overlay, \n    /**\n    The parser used to create this subtree.\n    */\n    parser, \n    /**\n    [Indicates](#common.IterMode.EnterBracketed) that the nested\n    content is delineated with some kind\n    of bracket token.\n    */\n    bracketed = false) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n        this.bracketed = bracketed;\n    }\n    /**\n    @internal\n    */\n    static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */\n    name, \n    /**\n    @internal\n    */\n    props, \n    /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */\n    id, \n    /**\n    @internal\n    */\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */\n    prop(prop) { return this.props[prop.id]; }\n    /**\n    True when this is the top node of a grammar.\n    */\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\n    /**\n    True when this node is produced by a skip rule.\n    */\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\n    /**\n    Indicates whether this is an error node.\n    */\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */\n    constructor(\n    /**\n    The node types in this set, by id.\n    */\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    let value = add[1], prop = add[0];\n                    if (prop.combine && prop.id in newProps)\n                        value = prop.combine(newProps[prop.id], value);\n                    newProps[prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n    /**\n    When set, positions on the boundary of a mounted overlay tree\n    that has its [`bracketed`](#common.NestedParse.bracketed) flag\n    set will enter that tree regardless of side. Only supported in\n    [`enter`](#common.SyntaxNode.enter), not in cursors.\n    */\n    IterMode[IterMode[\"EnterBracketed\"] = 16] = \"EnterBracketed\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */\n    constructor(\n    /**\n    The type of the top node.\n    */\n    type, \n    /**\n    This node's child nodes.\n    */\n    children, \n    /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */\n    positions, \n    /**\n    The total length of this tree\n    */\n    length, \n    /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */\n    resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && (anon || !c.type.isAnonymous))\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */\n    balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */\n    static build(data) { return buildTree(data); }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n    /**\n    Create a tree buffer.\n    */\n    constructor(\n    /**\n    The buffer's content.\n    */\n    buffer, \n    /**\n    The total length of the group of nodes in the buffer.\n    */\n    length, \n    /**\n    The node set used in this buffer.\n    */\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */\n    get type() { return NodeType.none; }\n    /**\n    @internal\n    */\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */\n    slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Side.Before */: return from < pos;\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Side.Around */: return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* Side.After */: return to > pos;\n        case 4 /* Side.DontCare */: return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while (scan) {\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to)\n                break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            }\n            else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() { return this; }\n    get next() { return this.parent; }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        var _a;\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!((mode & IterMode.EnterBracketed) && next instanceof Tree &&\n                    ((_a = MountedTree.get(next)) === null || _a === void 0 ? void 0 : _a.overlay) === null && (start >= pos || start + next.length <= pos)) &&\n                    !checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side, mode);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\n    prop(prop) { return this._tree.prop(prop); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from, enterBracketed = (mode & IterMode.EnterBracketed) && mounted.bracketed;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 || enterBracketed ? from <= rPos : from < rPos) &&\n                    (side < 0 || enterBracketed ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n    }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    /**\n    @internal\n    */\n    toString() { return this._tree.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        for (let found = false; !found;) {\n            found = cur.type.is(before);\n            if (!cur.nextSibling())\n                return result;\n        }\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    constructor(context, _parent, index) {\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\n    prop(prop) { return this.type.prop(prop); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */\n    toString() { return this.context.buffer.childString(this.index); }\n}\nfunction iterStack(heads) {\n    if (!heads.length)\n        return null;\n    let pick = 0, picked = heads[0];\n    for (let i = 1; i < heads.length; i++) {\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next)\n        newHeads[pick] = next;\n    else\n        newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node) {\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() { return iterStack(this.heads); }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {\n        if (scan.index < 0) { // This is an overlay root\n            let parent = scan.parent;\n            (layers || (layers = [inner])).push(parent.resolve(pos, side));\n            scan = parent;\n        }\n        else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */\n    get name() { return this.type.name; }\n    /**\n    @internal\n    */\n    constructor(node, mode = 0) {\n        /**\n        @internal\n        */\n        this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */\n        this.index = 0;\n        this.bufferNode = null;\n        this.mode = mode & ~IterMode.EnterBracketed;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to this node's last child.\n    */\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\n    /**\n    Move to the last child that starts before `pos`.\n    */\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */\n    nextSibling() { return this.sibling(1); }\n    /**\n    Move to this node's previous sibling, if any.\n    */\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */\n    next(enter = true) { return this.move(1, enter); }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */\n    prev(enter = true) { return this.move(-1, enter); }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth)\n                    return;\n                if (this.nextSibling())\n                    break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        if (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else if (depth > 2500 /* CutOff.Depth */) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while (cursor.pos > minPos) {\n            let { id, start, end, size } = cursor;\n            if (size > 4) { // Not a leaf\n                cursor.next();\n            }\n            else if (stopAt > -1 && start < stopAt) {\n                break;\n            }\n            else {\n                if (stopAt < 0)\n                    stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ || fork.size == -4 /* SpecialRecord.LookAhead */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */\n    constructor(\n    /**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */\n    from, \n    /**\n    The end of the unchanged range.\n    */\n    to, \n    /**\n    The tree that this fragment is based on.\n    */\n    tree, \n    /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, bracketed, target, from) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.bracketed = bracketed;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some(r => r.from >= r.to))\n        throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, bracketed, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.bracketed = bracketed;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser, inner.bracketed);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered;;) {\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            }\n            else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */;\n            }\n            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&\n                (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) {\n                    materialize(cursor);\n                    // materialize create one more level of nesting\n                    // we need to add depth to active overlay for going backwards\n                    if (overlay)\n                        overlay.depth++;\n                    if (covered)\n                        covered.depth++;\n                }\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, !!nest.bracketed, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay ||\n                        (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));\n                    if (ranges.length)\n                        checkRanges(ranges);\n                    if (ranges.length || !nest.overlay)\n                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)\n                            : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, !!nest.bracketed, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from)\n                        overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to };\n                    else\n                        overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.bracketed, overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n    }\n    return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [i];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos\n            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)\n            : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack) {\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtDQUFrQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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dWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/ZDZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbmZpZy5jb21iaW5lIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlciwgXG4gICAgLyoqXG4gICAgW0luZGljYXRlc10oI2NvbW1vbi5JdGVyTW9kZS5FbnRlckJyYWNrZXRlZCkgdGhhdCB0aGUgbmVzdGVkXG4gICAgY29udGVudCBpcyBkZWxpbmVhdGVkIHdpdGggc29tZSBraW5kXG4gICAgb2YgYnJhY2tldCB0b2tlbi5cbiAgICAqL1xuICAgIGJyYWNrZXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmJyYWNrZXRlZCA9IGJyYWNrZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYWRkWzFdLCBwcm9wID0gYWRkWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5jb21iaW5lICYmIHByb3AuaWQgaW4gbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3AuY29tYmluZShuZXdQcm9wc1twcm9wLmlkXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1twcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpLCBDYWNoZWRJbm5lck5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5PcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbm9wZXJhdG9yIHRvIGVuYWJsZSBtdWx0aXBsZSBvbmVzLlxuKi9cbnZhciBJdGVyTW9kZTtcbihmdW5jdGlvbiAoSXRlck1vZGUpIHtcbiAgICAvKipcbiAgICBXaGVuIGVuYWJsZWQsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgdmlzaXQgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIFtgVHJlZUJ1ZmZlcmBdKCNjb21tb24uVHJlZUJ1ZmZlcilzLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJFeGNsdWRlQnVmZmVyc1wiXSA9IDFdID0gXCJFeGNsdWRlQnVmZmVyc1wiO1xuICAgIC8qKlxuICAgIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgdGhlIG5vZGVzIHRoYXQgd3JhcCByZXBlYXRlZCBncmFtbWFyIGNvbnN0cnVjdHMgaW50byBhIGJhbGFuY2VkXG4gICAgdHJlZSkuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8qKlxuICAgIEJ5IGRlZmF1bHQsIHJlZ3VsYXIgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgbm9kZXNcbiAgICByZXBsYWNlIHRoZWlyIGJhc2Ugbm9kZSBpbiBpdGVyYXRpb24uIEVuYWJsZSB0aGlzIHRvIGlnbm9yZSB0aGVtXG4gICAgaW5zdGVhZC5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlTW91bnRzXCJdID0gNF0gPSBcIklnbm9yZU1vdW50c1wiO1xuICAgIC8qKlxuICAgIFRoaXMgb3B0aW9uIG9ubHkgYXBwbGllcyBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIGxpYnJhcnkgdG8gbm90IGVudGVyIG1vdW50ZWQgb3ZlcmxheXMgaWYgb25lIGNvdmVycyB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbiAgICAvKipcbiAgICBXaGVuIHNldCwgcG9zaXRpb25zIG9uIHRoZSBib3VuZGFyeSBvZiBhIG1vdW50ZWQgb3ZlcmxheSB0cmVlXG4gICAgdGhhdCBoYXMgaXRzIFtgYnJhY2tldGVkYF0oI2NvbW1vbi5OZXN0ZWRQYXJzZS5icmFja2V0ZWQpIGZsYWdcbiAgICBzZXQgd2lsbCBlbnRlciB0aGF0IHRyZWUgcmVnYXJkbGVzcyBvZiBzaWRlLiBPbmx5IHN1cHBvcnRlZCBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLCBub3QgaW4gY3Vyc29ycy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRW50ZXJCcmFja2V0ZWRcIl0gPSAxNl0gPSBcIkVudGVyQnJhY2tldGVkXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMucGFyZW50LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCEoKG1vZGUgJiBJdGVyTW9kZS5FbnRlckJyYWNrZXRlZCkgJiYgbmV4dCBpbnN0YW5jZW9mIFRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJsYXkpID09PSBudWxsICYmIChzdGFydCA+PSBwb3MgfHwgc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSBwb3MpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQobmV4dCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLl90cmVlLnByb3AocHJvcCk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tLCBlbnRlckJyYWNrZXRlZCA9IChtb2RlICYgSXRlck1vZGUuRW50ZXJCcmFja2V0ZWQpICYmIG1vdW50ZWQuYnJhY2tldGVkO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgfHwgZW50ZXJCcmFja2V0ZWQgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwIHx8IGVudGVyQnJhY2tldGVkID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgZm9yIChsZXQgZm91bmQgPSBmYWxzZTsgIWZvdW5kOykge1xuICAgICAgICAgICAgZm91bmQgPSBjdXIudHlwZS5pcyhiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlOyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgY2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnR5cGUucHJvcChwcm9wKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbn1cbmZ1bmN0aW9uIGl0ZXJTdGFjayhoZWFkcykge1xuICAgIGlmICghaGVhZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcGljayA9IDAsIHBpY2tlZCA9IGhlYWRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBoZWFkc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA+IHBpY2tlZC5mcm9tIHx8IG5vZGUudG8gPCBwaWNrZWQudG8pIHtcbiAgICAgICAgICAgIHBpY2tlZCA9IG5vZGU7XG4gICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dCA9IHBpY2tlZCBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHBpY2tlZC5pbmRleCA8IDAgPyBudWxsIDogcGlja2VkLnBhcmVudDtcbiAgICBsZXQgbmV3SGVhZHMgPSBoZWFkcy5zbGljZSgpO1xuICAgIGlmIChuZXh0KVxuICAgICAgICBuZXdIZWFkc1twaWNrXSA9IG5leHQ7XG4gICAgZWxzZVxuICAgICAgICBuZXdIZWFkcy5zcGxpY2UocGljaywgMSk7XG4gICAgcmV0dXJuIG5ldyBTdGFja0l0ZXJhdG9yKG5ld0hlYWRzLCBwaWNrZWQpO1xufVxuY2xhc3MgU3RhY2tJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaGVhZHMsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5oZWFkcyA9IGhlYWRzO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIGl0ZXJTdGFjayh0aGlzLmhlYWRzKTsgfVxufVxuZnVuY3Rpb24gc3RhY2tJdGVyYXRvcih0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIHNpZGUpLCBsYXllcnMgPSBudWxsO1xuICAgIGZvciAobGV0IHNjYW4gPSBpbm5lciBpbnN0YW5jZW9mIFRyZWVOb2RlID8gaW5uZXIgOiBpbm5lci5jb250ZXh0LnBhcmVudDsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FuLmluZGV4IDwgMCkgeyAvLyBUaGlzIGlzIGFuIG92ZXJsYXkgcm9vdFxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHNjYW4ucGFyZW50O1xuICAgICAgICAgICAgKGxheWVycyB8fCAobGF5ZXJzID0gW2lubmVyXSkpLnB1c2gocGFyZW50LnJlc29sdmUocG9zLCBzaWRlKSk7XG4gICAgICAgICAgICBzY2FuID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdW50ID0gTW91bnRlZFRyZWUuZ2V0KHNjYW4udHJlZSk7XG4gICAgICAgICAgICAvLyBSZWxldmFudCBvdmVybGF5IGJyYW5jaGluZyBvZmZcbiAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5vdmVybGF5ICYmIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA8PSBwb3MgJiYgbW91bnQub3ZlcmxheVttb3VudC5vdmVybGF5Lmxlbmd0aCAtIDFdLnRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCByb290ID0gbmV3IFRyZWVOb2RlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIHNjYW4uZnJvbSwgLTEsIHNjYW4pO1xuICAgICAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHJlc29sdmVOb2RlKHJvb3QsIHBvcywgc2lkZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzID8gaXRlclN0YWNrKGxheWVycykgOiBpbm5lcjtcbn1cbi8qKlxuQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG5hbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLyoqXG4gICAgU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBtb2RlID0gMCkge1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlICYgfkl0ZXJNb2RlLkVudGVyQnJhY2tldGVkO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyc2FsLiBBXG4gICAgbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgICovXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgICovXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcbiAgICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICAqL1xuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdGhpcy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICAgKi9cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLnBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXMgfSA9IGJ1ZmZlci5zZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5fdHJlZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZCwgY29udGV4dEF0U3RhcnQgPSBjb250ZXh0SGFzaDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPiAyNTAwIC8qIEN1dE9mZi5EZXB0aCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0YWtlRmxhdE5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRha2VGbGF0Tm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdOyAvLyBUZW1wb3JhcnksIGludmVydGVkIGFycmF5IG9mIGxlYWYgbm9kZXMgZm91bmQsIHdpdGggYWJzb2x1dGUgcG9zaXRpb25zXG4gICAgICAgIGxldCBub2RlQ291bnQgPSAwLCBzdG9wQXQgPSAtMTtcbiAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBtaW5Qb3MpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHsgLy8gTm90IGEgbGVhZlxuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdG9wQXQgPiAtMSAmJiBzdGFydCA8IHN0b3BBdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BBdCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCA9IGVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGlkLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkobm9kZUNvdW50ICogNCk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAzLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDFdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMl0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBUcmVlQnVmZmVyKGJ1ZmZlciwgbm9kZXNbMl0gLSBzdGFydCwgbm9kZVNldCkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bywgY29udGV4dEhhc2gpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovIHx8IGZvcmsuc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgYnJhY2tldGVkLCB0YXJnZXQsIGZyb20pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5icmFja2V0ZWQgPSBicmFja2V0ZWQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgYnJhY2tldGVkLCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuYnJhY2tldGVkID0gYnJhY2tldGVkO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyLCBpbm5lci5icmFja2V0ZWQpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRlcmlhbGl6ZSBjcmVhdGUgb25lIG1vcmUgbGV2ZWwgb2YgbmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkZCBkZXB0aCB0byBhY3RpdmUgb3ZlcmxheSBmb3IgZ29pbmcgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCAhIW5lc3QuYnJhY2tldGVkLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCAhIW5lc3QuYnJhY2tldGVkLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBvdmVybGF5LnJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA+PSAwICYmIG92ZXJsYXkucmFuZ2VzW2xhc3RdLnRvID09IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlc1tsYXN0XSA9IHsgZnJvbTogb3ZlcmxheS5yYW5nZXNbbGFzdF0uZnJvbSwgdG86IHJhbmdlLnRvIH07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkuYnJhY2tldGVkLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzWzBdLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvdmVyLk5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIHN0YWNrID0gW107XG4gICAgbGV0IGJ1ZmZlciA9IG5vZGUuY29udGV4dC5idWZmZXI7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBzdGFjay5wdXNoKGN1cnNvci5pbmRleCk7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGJhc2UgPSBjdXJzb3IudHJlZSwgaSA9IGJhc2UuY2hpbGRyZW4uaW5kZXhPZihidWZmZXIpO1xuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlciwgbmV3U3RhY2sgPSBbaV07XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoLCBzdGFja1Bvcykge1xuICAgICAgICBsZXQgdGFyZ2V0SSA9IHN0YWNrW3N0YWNrUG9zXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgdGFyZ2V0SSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbdGFyZ2V0SSArIDFdLCB0byA9IGJbdGFyZ2V0SSArIDJdO1xuICAgICAgICBuZXdTdGFjay5wdXNoKGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0YWNrUG9zXG4gICAgICAgICAgICA/IHNwbGl0KHRhcmdldEkgKyA0LCBiW3RhcmdldEkgKyAzXSwgYnVmLnNldC50eXBlc1tiW3RhcmdldEldXSwgZnJvbSwgdG8gLSBmcm9tLCBzdGFja1BvcyAtIDEpXG4gICAgICAgICAgICA6IG5vZGUudG9UcmVlKCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbdGFyZ2V0SSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGluZGV4IG9mIG5ld1N0YWNrKSB7XG4gICAgICAgIGxldCB0cmVlID0gY3Vyc29yLnRyZWUuY2hpbGRyZW5baW5kZXhdLCBwb3MgPSBjdXJzb3IudHJlZS5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBjdXJzb3IueWllbGQobmV3IFRyZWVOb2RlKHRyZWUsIHBvcyArIGN1cnNvci5mcm9tLCBpbmRleCwgY3Vyc29yLl90cmVlKSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIEl0ZXJNb2RlLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBOb2RlV2Vha01hcCwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/css/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@lezer/css/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst descendantOp = 122,\n  Unit = 1,\n  identifier = 123,\n  callee = 124,\n  VariableName = 2,\n  queryIdentifier = 125,\n  queryVariableName = 3,\n  QueryCallee = 4;\n\n/* Hand-written tokenizers for CSS tokens that can't be\n   expressed by Lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,\n               8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];\nconst colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46,\n      hash = 35, percent = 37, ampersand = 38, backslash = 92, newline = 10, asterisk = 42;\n\nfunction isAlpha(ch) { return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 }\n\nfunction isDigit(ch) { return ch >= 48 && ch <= 57 }\n\nfunction isHex(ch) { return isDigit(ch) || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70 }\n\nconst identifierTokens = (id, varName, callee) => (input, stack) => {\n  for (let inside = false, dashes = 0, i = 0;; i++) {\n    let {next} = input;\n    if (isAlpha(next) || next == dash || next == underscore || (inside && isDigit(next))) {\n      if (!inside && (next != dash || i > 0)) inside = true;\n      if (dashes === i && next == dash) dashes++;\n      input.advance();\n    } else if (next == backslash && input.peek(1) != newline) {\n      input.advance();\n      if (isHex(input.next)) {\n        do { input.advance(); } while (isHex(input.next))\n        if (input.next == 32) input.advance();\n      } else if (input.next > -1) {\n        input.advance();\n      }\n      inside = true;\n    } else {\n      if (inside) input.acceptToken(\n        dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee : id\n      );\n      break\n    }\n  }\n};\n\nconst identifiers = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(\n  identifierTokens(identifier, VariableName, callee)\n);\nconst queryIdentifiers = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(\n  identifierTokens(queryIdentifier, queryVariableName, QueryCallee)\n);\n\nconst descendant = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  if (space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (isAlpha(next) || next == underscore || next == hash || next == period ||\n        next == asterisk || next == bracketL || next == colon && isAlpha(input.peek(1)) ||\n        next == dash || next == ampersand)\n      input.acceptToken(descendantOp);\n  }\n});\n\nconst unitToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  if (!space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (next == percent) { input.advance(); input.acceptToken(Unit); }\n    if (isAlpha(next)) {\n      do { input.advance(); } while (isAlpha(input.next) || isDigit(input.next))\n      input.acceptToken(Unit);\n    }\n  }\n});\n\nconst cssHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"AtKeyword import charset namespace keyframes media supports\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"from to selector\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  NamespaceName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace,\n  KeyframeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  KeyframeRangeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  ClassName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  PseudoClassName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  IdName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  \"FeatureName PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  NumberLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  KeywordQuery: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  UnaryQueryOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"CallTag ValueName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  Callee: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  Unit: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.unit,\n  \"UniversalSelector NestingSelector\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  \"MatchOp CompareOp\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  \"ChildOp SiblingOp, LogicOp\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BinOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  Important: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  ColorLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.color,\n  \"ParenthesizedContent StringLiteral\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  \":\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"PseudoOp #\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \"; ,\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_callee = {__proto__:null,lang:38, \"nth-child\":38, \"nth-last-child\":38, \"nth-of-type\":38, \"nth-last-of-type\":38, dir:38, \"host-context\":38, if:84, url:124, \"url-prefix\":124, domain:124, regexp:124};\nconst spec_queryIdentifier = {__proto__:null,or:98, and:98, not:106, only:106, layer:170};\nconst spec_QueryCallee = {__proto__:null,selector:112, layer:166};\nconst spec_AtKeyword = {__proto__:null,\"@import\":162, \"@media\":174, \"@charset\":178, \"@namespace\":182, \"@keyframes\":188, \"@supports\":200, \"@scope\":204};\nconst spec_identifier = {__proto__:null,to:207};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a\",\n  stateData: \"Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~\",\n  goto: \"2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P\",\n  nodeNames: \"âš  Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles\",\n  maxTerm: 143,\n  nodeProps: [\n    [\"isolate\", -2,5,36,\"\"],\n    [\"openedBy\", 20,\"(\",28,\"[\",31,\"{\"],\n    [\"closedBy\", 21,\")\",29,\"]\",32,\"}\"]\n  ],\n  propSources: [cssHighlighting],\n  skippedNodes: [0,5,106],\n  repeatNodeCount: 15,\n  tokenData: \"JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q\",\n  tokenizers: [descendant, unitToken, identifiers, queryIdentifiers, 1, 2, 3, 4, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~\", 28, 129)],\n  topRules: {\"StyleSheet\":[0,6],\"Styles\":[1,105]},\n  specialized: [{term: 124, get: (value) => spec_callee[value] || -1},{term: 125, get: (value) => spec_queryIdentifier[value] || -1},{term: 4, get: (value) => spec_QueryCallee[value] || -1},{term: 25, get: (value) => spec_AtKeyword[value] || -1},{term: 123, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 1963\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2Nzcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RTtBQUN0Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qix1QkFBdUI7O0FBRXZCLHFCQUFxQjs7QUFFckI7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQWlCO0FBQzlDO0FBQ0E7O0FBRUEsdUJBQXVCLHdEQUFpQjtBQUN4QztBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQix3REFBaUI7QUFDdkM7QUFDQSxTQUFTLE1BQU07QUFDZiwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0IsMkRBQVM7QUFDakMsaUVBQWlFLGtEQUFJO0FBQ3JFLHNCQUFzQixrREFBSTtBQUMxQixpQkFBaUIsa0RBQUk7QUFDckIsZ0JBQWdCLGtEQUFJO0FBQ3BCLHFCQUFxQixrREFBSTtBQUN6QixXQUFXLGtEQUFJO0FBQ2YsYUFBYSxrREFBSTtBQUNqQixtQkFBbUIsa0RBQUksVUFBVSxrREFBSTtBQUNyQyxVQUFVLGtEQUFJO0FBQ2QsOEJBQThCLGtEQUFJO0FBQ2xDLGlCQUFpQixrREFBSTtBQUNyQixpQkFBaUIsa0RBQUk7QUFDckIsZ0JBQWdCLGtEQUFJ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LElBQUksYUFBYSxLQUFLLEdBQUcsc0JBQXNCLEtBQUssR0FBRyxzQkFBc0IsS0FBSyxHQUFHLHNCQUFzQixLQUFLLEdBQUcsc0JBQXNCLEtBQUssR0FBRyxtQ0FBbUMsS0FBSyxHQUFHLGFBQWEsRUFBRTtBQUMxK0cscUZBQXFGLHNEQUFlLFdBQVc7QUFDL0csYUFBYSxvQ0FBb0M7QUFDakQsaUJBQWlCLG9EQUFvRCxFQUFFLDZEQUE2RCxFQUFFLHVEQUF1RCxFQUFFLHNEQUFzRCxFQUFFLHdEQUF3RDtBQUMvUztBQUNBLENBQUM7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktYXBwLWJ1aWxkZXItd2ViLy4vbm9kZV9tb2R1bGVzL0BsZXplci9jc3MvZGlzdC9pbmRleC5qcz9lNGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IGRlc2NlbmRhbnRPcCA9IDEyMixcbiAgVW5pdCA9IDEsXG4gIGlkZW50aWZpZXIgPSAxMjMsXG4gIGNhbGxlZSA9IDEyNCxcbiAgVmFyaWFibGVOYW1lID0gMixcbiAgcXVlcnlJZGVudGlmaWVyID0gMTI1LFxuICBxdWVyeVZhcmlhYmxlTmFtZSA9IDMsXG4gIFF1ZXJ5Q2FsbGVlID0gNDtcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplcnMgZm9yIENTUyB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IExlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LFxuICAgICAgICAgICAgICAgODE5OCwgODE5OSwgODIwMCwgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuY29uc3QgY29sb24gPSA1OCwgcGFyZW5MID0gNDAsIHVuZGVyc2NvcmUgPSA5NSwgYnJhY2tldEwgPSA5MSwgZGFzaCA9IDQ1LCBwZXJpb2QgPSA0NixcbiAgICAgIGhhc2ggPSAzNSwgcGVyY2VudCA9IDM3LCBhbXBlcnNhbmQgPSAzOCwgYmFja3NsYXNoID0gOTIsIG5ld2xpbmUgPSAxMCwgYXN0ZXJpc2sgPSA0MjtcblxuZnVuY3Rpb24gaXNBbHBoYShjaCkgeyByZXR1cm4gY2ggPj0gNjUgJiYgY2ggPD0gOTAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8IGNoID49IDE2MSB9XG5cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHsgcmV0dXJuIGNoID49IDQ4ICYmIGNoIDw9IDU3IH1cblxuZnVuY3Rpb24gaXNIZXgoY2gpIHsgcmV0dXJuIGlzRGlnaXQoY2gpIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMiB8fCBjaCA+PSA2NSAmJiBjaCA8PSA3MCB9XG5cbmNvbnN0IGlkZW50aWZpZXJUb2tlbnMgPSAoaWQsIHZhck5hbWUsIGNhbGxlZSkgPT4gKGlucHV0LCBzdGFjaykgPT4ge1xuICBmb3IgKGxldCBpbnNpZGUgPSBmYWxzZSwgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBsZXQge25leHR9ID0gaW5wdXQ7XG4gICAgaWYgKGlzQWxwaGEobmV4dCkgfHwgbmV4dCA9PSBkYXNoIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCAoaW5zaWRlICYmIGlzRGlnaXQobmV4dCkpKSB7XG4gICAgICBpZiAoIWluc2lkZSAmJiAobmV4dCAhPSBkYXNoIHx8IGkgPiAwKSkgaW5zaWRlID0gdHJ1ZTtcbiAgICAgIGlmIChkYXNoZXMgPT09IGkgJiYgbmV4dCA9PSBkYXNoKSBkYXNoZXMrKztcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT0gYmFja3NsYXNoICYmIGlucHV0LnBlZWsoMSkgIT0gbmV3bGluZSkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgaWYgKGlzSGV4KGlucHV0Lm5leHQpKSB7XG4gICAgICAgIGRvIHsgaW5wdXQuYWR2YW5jZSgpOyB9IHdoaWxlIChpc0hleChpbnB1dC5uZXh0KSlcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPT0gMzIpIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA+IC0xKSB7XG4gICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnNpZGUpIGlucHV0LmFjY2VwdFRva2VuKFxuICAgICAgICBkYXNoZXMgPT0gMiAmJiBzdGFjay5jYW5TaGlmdChWYXJpYWJsZU5hbWUpID8gdmFyTmFtZSA6IG5leHQgPT0gcGFyZW5MID8gY2FsbGVlIDogaWRcbiAgICAgICk7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoXG4gIGlkZW50aWZpZXJUb2tlbnMoaWRlbnRpZmllciwgVmFyaWFibGVOYW1lLCBjYWxsZWUpXG4pO1xuY29uc3QgcXVlcnlJZGVudGlmaWVycyA9IG5ldyBFeHRlcm5hbFRva2VuaXplcihcbiAgaWRlbnRpZmllclRva2VucyhxdWVyeUlkZW50aWZpZXIsIHF1ZXJ5VmFyaWFibGVOYW1lLCBRdWVyeUNhbGxlZSlcbik7XG5cbmNvbnN0IGRlc2NlbmRhbnQgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICBpZiAoc3BhY2UuaW5jbHVkZXMoaW5wdXQucGVlaygtMSkpKSB7XG4gICAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICAgIGlmIChpc0FscGhhKG5leHQpIHx8IG5leHQgPT0gdW5kZXJzY29yZSB8fCBuZXh0ID09IGhhc2ggfHwgbmV4dCA9PSBwZXJpb2QgfHxcbiAgICAgICAgbmV4dCA9PSBhc3RlcmlzayB8fCBuZXh0ID09IGJyYWNrZXRMIHx8IG5leHQgPT0gY29sb24gJiYgaXNBbHBoYShpbnB1dC5wZWVrKDEpKSB8fFxuICAgICAgICBuZXh0ID09IGRhc2ggfHwgbmV4dCA9PSBhbXBlcnNhbmQpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihkZXNjZW5kYW50T3ApO1xuICB9XG59KTtcblxuY29uc3QgdW5pdFRva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgaWYgKCFzcGFjZS5pbmNsdWRlcyhpbnB1dC5wZWVrKC0xKSkpIHtcbiAgICBsZXQge25leHR9ID0gaW5wdXQ7XG4gICAgaWYgKG5leHQgPT0gcGVyY2VudCkgeyBpbnB1dC5hZHZhbmNlKCk7IGlucHV0LmFjY2VwdFRva2VuKFVuaXQpOyB9XG4gICAgaWYgKGlzQWxwaGEobmV4dCkpIHtcbiAgICAgIGRvIHsgaW5wdXQuYWR2YW5jZSgpOyB9IHdoaWxlIChpc0FscGhhKGlucHV0Lm5leHQpIHx8IGlzRGlnaXQoaW5wdXQubmV4dCkpXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihVbml0KTtcbiAgICB9XG4gIH1cbn0pO1xuXG5jb25zdCBjc3NIaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBcIkF0S2V5d29yZCBpbXBvcnQgY2hhcnNldCBuYW1lc3BhY2Uga2V5ZnJhbWVzIG1lZGlhIHN1cHBvcnRzXCI6IHRhZ3MuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiZnJvbSB0byBzZWxlY3RvclwiOiB0YWdzLmtleXdvcmQsXG4gIE5hbWVzcGFjZU5hbWU6IHRhZ3MubmFtZXNwYWNlLFxuICBLZXlmcmFtZU5hbWU6IHRhZ3MubGFiZWxOYW1lLFxuICBLZXlmcmFtZVJhbmdlTmFtZTogdGFncy5vcGVyYXRvcktleXdvcmQsXG4gIFRhZ05hbWU6IHRhZ3MudGFnTmFtZSxcbiAgQ2xhc3NOYW1lOiB0YWdzLmNsYXNzTmFtZSxcbiAgUHNldWRvQ2xhc3NOYW1lOiB0YWdzLmNvbnN0YW50KHRhZ3MuY2xhc3NOYW1lKSxcbiAgSWROYW1lOiB0YWdzLmxhYmVsTmFtZSxcbiAgXCJGZWF0dXJlTmFtZSBQcm9wZXJ0eU5hbWVcIjogdGFncy5wcm9wZXJ0eU5hbWUsXG4gIEF0dHJpYnV0ZU5hbWU6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgTnVtYmVyTGl0ZXJhbDogdGFncy5udW1iZXIsXG4gIEtleXdvcmRRdWVyeTogdGFncy5rZXl3b3JkLFxuICBVbmFyeVF1ZXJ5T3A6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcIkNhbGxUYWcgVmFsdWVOYW1lXCI6IHRhZ3MuYXRvbSxcbiAgVmFyaWFibGVOYW1lOiB0YWdzLnZhcmlhYmxlTmFtZSxcbiAgQ2FsbGVlOiB0YWdzLm9wZXJhdG9yS2V5d29yZCxcbiAgVW5pdDogdGFncy51bml0LFxuICBcIlVuaXZlcnNhbFNlbGVjdG9yIE5lc3RpbmdTZWxlY3RvclwiOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgXCJNYXRjaE9wIENvbXBhcmVPcFwiOiB0YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgXCJDaGlsZE9wIFNpYmxpbmdPcCwgTG9naWNPcFwiOiB0YWdzLmxvZ2ljT3BlcmF0b3IsXG4gIEJpbk9wOiB0YWdzLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgSW1wb3J0YW50OiB0YWdzLm1vZGlmaWVyLFxuICBDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgQ29sb3JMaXRlcmFsOiB0YWdzLmNvbG9yLFxuICBcIlBhcmVudGhlc2l6ZWRDb250ZW50IFN0cmluZ0xpdGVyYWxcIjogdGFncy5zdHJpbmcsXG4gIFwiOlwiOiB0YWdzLnB1bmN0dWF0aW9uLFxuICBcIlBzZXVkb09wICNcIjogdGFncy5kZXJlZk9wZXJhdG9yLFxuICBcIjsgLFwiOiB0YWdzLnNlcGFyYXRvcixcbiAgXCIoIClcIjogdGFncy5wYXJlbixcbiAgXCJbIF1cIjogdGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiB0YWdzLmJyYWNlXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2NhbGxlZSA9IHtfX3Byb3RvX186bnVsbCxsYW5nOjM4LCBcIm50aC1jaGlsZFwiOjM4LCBcIm50aC1sYXN0LWNoaWxkXCI6MzgsIFwibnRoLW9mLXR5cGVcIjozOCwgXCJudGgtbGFzdC1vZi10eXBlXCI6MzgsIGRpcjozOCwgXCJob3N0LWNvbnRleHRcIjozOCwgaWY6ODQsIHVybDoxMjQsIFwidXJsLXByZWZpeFwiOjEyNCwgZG9tYWluOjEyNCwgcmVnZXhwOjEyNH07XG5jb25zdCBzcGVjX3F1ZXJ5SWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxvcjo5OCwgYW5kOjk4LCBub3Q6MTA2LCBvbmx5OjEwNiwgbGF5ZXI6MTcwfTtcbmNvbnN0IHNwZWNfUXVlcnlDYWxsZWUgPSB7X19wcm90b19fOm51bGwsc2VsZWN0b3I6MTEyLCBsYXllcjoxNjZ9O1xuY29uc3Qgc3BlY19BdEtleXdvcmQgPSB7X19wcm90b19fOm51bGwsXCJAaW1wb3J0XCI6MTYyLCBcIkBtZWRpYVwiOjE3NCwgXCJAY2hhcnNldFwiOjE3OCwgXCJAbmFtZXNwYWNlXCI6MTgyLCBcIkBrZXlmcmFtZXNcIjoxODgsIFwiQHN1cHBvcnRzXCI6MjAwLCBcIkBzY29wZVwiOjIwNH07XG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsdG86MjA3fTtcbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCJFYlFZUWRPT08jcVFkT09QI3hPYE9PT09RUCcjQ2YnI0NmT09RUCcjQ2UnI0NlTyN9UWRPJyNDaE8kblFhTycjQ2NPJHhRZE8nI0NrTyVUUWRPJyNEcE8lWVFkTycjRHJPJV9RZE8nI0R1TyVfUWRPJyNEeE9PUVAnI0ZWJyNGVk8mZVFoTycjRWhPT1FTJyNGVScjRlVPT1FTJyNFaycjRWtRWVFkT09PJmxRZE8nI0VPTyZQUWhPJyNFVU8mbFFkTycjRVdPJ2FRZE8nI0VZTydsUWRPJyNFXU8ndFFoTycjRWNPKFZRZE8nI0VlTyhiUWFPJyNDZk8pVlFgTycjRHtPKVtRYE8nI0ZgTylnUWRPJyNGYFFPUWBPT1ApcU8mak8nI0NhUE9PTylDQHQpQ0B0T09RUCcjQ2onI0NqT09RUCw1OVMsNTlTTyN9UWRPLDU5U08pfFFkTyw1OVZPJVRRZE8sNTpbTyVZUWRPLDU6Xk8lX1FkTyw1OmFPJV9RZE8sNTpjTyVfUWRPLDU6ZE8lX1FkTycjRXJPKlhRYE8sNTh9TyphUWRPJyNEek9PUVMsNTh9LDU4fU9PUVAnI0NuJyNDbk9PUU8nI0RuJyNEbk9PUVAsNTlWLDU5Vk8qaFFgTyw1OVZPKm1RYE8sNTlWT09RUCcjRHEnI0RxT09RUCw1OlssNTpbT09RTycjRHMnI0RzTypyUXBPLDU6Xk8rXVFhTyw1OmFPK3NRYU8sNTpkT09RVycjRFonI0RaTyxaUWhPJyNEZE8seFFoTycjRmFPJ3RRaE8nI0RiTy1XUWBPJyNEaE9PUVcnI0ZbJyNGW08tXVFgTyw1O1NPLWVRYE8nI0RlT09RUy1FOGktRThpT09RWycjQ3MnI0NzTy1qUWRPJyNDdE8uUVFkTycjQ3pPLmhRZE8nI0N9Ty9PUSFwTycjRFBPMVJRIWpPLDU6ak9PUU8nI0RVJyNEVU8qbVFgTycjRFRPMWNRIW5PJyNGWE8zYFFgTycjRFZPM2VRYE8nI0RrT09RWycjRlgnI0ZYTy1gUWBPLDU6cE8zalEhYk8sNTpyT09RUycjRVsnI0VbTzNyUWBPLDU6dE8zd1FkTyw1OnRPT1FPJyNFXycjRV9PNFBRYE8sNTp3TzRVUWhPLDU6fU8lX1FkTycjRGdPT1FTLDU7UCw1O1BPLWVRYE8sNTtQTzReUWRPLDU7UE80ZlFkTyw1OmdPNHZRZE8nI0V0TzVUUWBPLDU7ek81VFFgTyw1O3pQT09PJyNFaicjRWpQNWBPJmpPLDU4e1BPT08sNTh7LDU4e09PUVAxRy5uMUcubk9PUVAxRy5xMUcucU8qaFFgTzFHLnFPKm1RYE8xRy5xT09RUDFHL3YxRy92TzVrUXBPMUcveE81c1FhTzFHL3tPNlpRYU8xRy99TzZxUWFPMUcwT083WFFhTyw1O15PT1FPLUU4cC1FOHBPT1FTMUcuaTFHLmlPN2NRYE8sNTpmTzdoUWRPJyNEb083b1FkTycjQ3JPT1FQMUcveDFHL3hPJmxRZE8xRy94Tzd2USFqTycjRFpPOFVRIWJPLDU5dk84XlFoTyw1Ok9PT1FPJyNGXScjRl1POFhRIWJPLDU5ek8ndFFoTyw1OXhPOGZRaE8nI0V2TzhzUWBPLDU7e085T1FoTyw1OXxPOXVRaE8nI0RpT09RVyw1OlMsNTpTT09RUzFHMG4xRzBuT09RVyw1OlAsNTpQTzl8USFmTycjRllPT1FTJyNGWScjRllPT1FTJyNFbScjRW1PO15RZE8sNTlgT09RWyw1OWAsNTlgTzt0UWRPLDU5Zk9PUVssNTlmLDU5Zk88W1FkTyw1OWlPT1FbLDU5aSw1OWlPT1FbLDU5ayw1OWtPJmxRZE8sNTltTzxyUWhPJyNFUU9PUVcnI0VRJyNFUU89V1FgTzFHMFVPMVtRaE8xRzBVT09RWyw1OW8sNTlvTyd0UWhPJyNEWE9PUVssNTlxLDU5cU89XVEjdE8sNTpWT09RUzFHMFsxRzBbT09RUzFHMF4xRzBeT09RUzFHMGAxRzBgTz1oUWBPMUcwYE89bVFkTycjRWBPT1FTMUcwYzFHMGNPT1FTMUcwaTFHMGlPPXhRYU8sNTpSTy1gUWBPMUcwa09PUVMxRzBrMUcwa08tZVFgTzFHMGtPPlBRIWZPMUcwUk9PUU8xRzBSMUcwUk9PUU8sNTtgLDU7YE8+Z1FkTyw1O2BPT1FPLUU4ci1FOHJPPnRRYE8xRzFmUE9PTy1FOGgtRThoUE9PTzFHLmcxRy5nT09RUDcrJF03KyRdT09RUDcrJWQ3KyVkTyZsUWRPNyslZE9PUVMxRzBRMUcwUU8/UFFhTycjRl9PP1pRYE8sNTpaTz9gUSFmTycjRWxPQF5RZE8nI0ZXT0BoUWBPLDU5Xk9AbVEhYk83KyVkTyZsUWRPMUcvYk9AdVFoTzFHL2ZPT1FXMUcvajFHL2pPT1FXMUcvZDFHL2RPQVdRaE8sNTtiT09RTy1FOHQtRTh0T0FmUWhPJyNEWk9BdFFoTycjRl5PQlBRYE8nI0ZeT0JVUWBPLDU6VE9PUVMtRThrLUU4a09PUVsxRy56MUcuek9PUVsxRy9RMUcvUU9PUVsxRy9UMUcvVE9PUVsxRy9YMUcvWE9CWlFkTyw1OmxPT1FTNyslcDcrJXBPQmBRYE83KyVwT0JlUWhPJyNEWU9CbVFgTyw1OXNPJ3RRaE8sNTlzT09RWzFHL3ExRy9xT0J1UWBPMUcvcU9PUVM3KyV6Nyslek9CelFiTycjRFBPT1FPJyNFYicjRWJPQ1lRYE8nI0VhT09RTycjRWEnI0VhT0NlUWBPJyNFd09DbVFkTyw1OnpPT1FTLDU6eiw1OnpPT1FbMUcvbTFHL21PT1FTNysmVjcrJlZPLWBRYE83KyZWT0N4USFmTycjRXNPJmxRZE8nI0VzT0VQUWRPNyslbU9PUU83KyVtNyslbU9PUU8xRzB6MUcwek9FZFEhYk88PElPT0VsUWRPJyNFcU9FdlFgTyw1O3lPT1FQMUcvdTFHL3VPT1FTLUU4ai1FOGpPRk9RZE8nI0VwT0ZZUWBPLDU7ck9PUV0xRy54MUcueE9PUVA8PElPPDxJT09GYlFkTzcrJHxPT1FPJyNEXScjRF1PRmlRIWJPNyslUU9GcVFoTycjRW9PRntRYE8sNTt4TyZsUWRPLDU7eE9PUVcxRy9vMUcvb09PUU8nI0VTJyNFU09HVFFgTzFHMFdPT1FTPDxJWzw8SVtPJmxRZE8sNTl0T0duUWhPMUcvX09PUVsxRy9fMUcvX09HdVFgTzFHL19PT1FXLUU4bC1FOGxPT1FbNyslXTcrJV1PT1FPLDU6eyw1OntPPXBRZE8nI0V4T0NlUWBPLDU7Y09PUVMsNTtjLDU7Y09PUVMtRTh1LUU4dU9PUVMxRzBmMUcwZk9PUVM8PElxPDxJcU9HfVEhZk8sNTtfT09RUy1FOHEtRThxT09RTzw8SVg8PElYT09RUEFOPmpBTj5qT0lVUWFPLDU7XU9PUU8tRThvLUU4b09JYFFkTyw1O1tPT1FPLUU4bi1FOG5PT1FXPDxIaDw8SGhPT1FXPDxIbDw8SGxPSWpRaE88PEhsT0l7UWhPLDU7Wk9KV1FgTyw1O1pPT1FPLUU4bS1FOG1PSl1RZE8xRzFkT0JaUWRPJyNFdU9KZ1FgTzcrJXJPT1FXNyslcjcrJXJPSm9RIWJPMUcvYE9PUVs3KyR5NyskeU9KelFoTzcrJHlQS1JRYE8nI0VuT09RTyw1O2QsNTtkT09RTy1FOHYtRTh2T09RUzFHMH0xRzB9T0tXUWBPQU4+V08mbFFkTzFHMHVPS11RYE83KydPT09RTyw1O2EsNTthT09RTy1FOHMtRThzT09RVzw8SV48PEleT09RWzw8SGU8PEhlUE9RVyw1O1ksNTtZT09RV0cyM3JHMjNyT0tlUWRPNysmYVwiLFxuICBzdGF0ZURhdGE6IFwiS3h+TyNzT1MjdFFRfk9XW09aW09dVE9gVk9hVk9pXU9qV09tWE8hallPIW1aTyFzYU8heWJPIXtjTyF9ZE8jUWVPI1dmTyNZZ08jb1JPfk9RaU9XW09aW09dVE9gVk9hVk9pXU9qV09tWE8hallPIW1aTyFzYU8heWJPIXtjTyF9ZE8jUWVPI1dmTyNZZ08jb2hPfk8jbSRTUH5QIWRPI3RtT35PI29vT35PXXFPYHJPYXJPanNPbXRPIWp1TyFtd08jbnZPfk9wek8hXnhPflAkU09jIVFPI298TyNwfU9+TyNvIVJPfk8jbyFUT35PV1tPWltPXVRPYFZPYVZPaldPbVhPIWpZTyFtWk8jb1JPfk9TIV1PZSFZTyFWIVtPIVkhYE8jcSFYT3AkVFB+T2skVFB+UCZQT1Ehak9lIWNPbSFkT3AhZU9yIW1PdCFtT3oha08hYCFsTyNvIWJPI3AhaE8jfSFmT35PdCFxTyFgIWxPI28hcE9+T3Qhc08jbyFzT35PUyFdT2UhWU8hViFbTyFZIWBPI3EhWE9+T2Uhdk9wek8jWiF4T35PXVlYYFlYYCFwWGFZWGpZWG1ZWHBZWCFeWVghallYIW1ZWCNuWVh+T2Ahek9+T2she08jbSRTWG8kU1h+TyNtJFNYbyRTWH5QIWRPI3UjT08jdiNPTyN3I1FPfk9jI1VPI298TyNwfU9+T3B6TyFeeE9+T28kU1B+UCFkT2UjYE9+T2UjYU9+T2wjYk8haCNjT35PXXFPYHJPYXJPanNPbXRPfk9wIWlhIV4haWEhaiFpYSFtIWlhI24haWFkIWlhflAqek9wIWxhIV4hbGEhaiFsYSFtIWxhI24hbGFkIWxhflAqek9SI2dPUyFdT2UhWU9yI2dPdCNnTyFWIVtPIVkhYE8jcSNkTyN9IWZPfk8hUiNpTyFeI2pPayRUWHAkVFh+T2UjbU9+T2sjb09wek9+T2Uhdk9+T10jck9gI3JPZCN1T2kjck9qI3JPayNyT35QJmxPXSNyT2Ajck9pI3JPaiNyT2sjck9sI3dPflAmbE9dI3JPYCNyT2kjck9qI3JPayNyT28jeU9+UCZsT1Ajek9Tc1hlc1hrc1h2c1ghVnNYIVlzWCF1c1ghd3NYI3FzWCFUc1hRc1hdc1hgc1hkc1hpc1hqc1htc1hwc1hyc1h0c1h6c1ghYHNYI29zWCNwc1gjfXNYbHNYb3NYIV5zWCFxc1gjbXNYfk92I3tPIXUjfE8hdyN9T2skVFB+UCd0T2UjYU9TI3tYayN7WHYje1ghViN7WCFZI3tYIXUje1ghdyN7WCNxI3tYUSN7WF0je1hgI3tYZCN7WGkje1hqI3tYbSN7WHAje1hyI3tYdCN7WHoje1ghYCN7WCNvI3tYI3Aje1gjfSN7WGwje1hvI3tYIV4je1ghcSN7WCNtI3tYfk9lJFJPfk9lJFRPfk9rJFZPdiN7T35PayRXT35PdCRYTyFgIWxPfk9wJFlPfk9wek8hUiNpT35PcHpPI1okYE9+TyFxJGJPayFvYSNtIW9hbyFvYX5QJmxPayNoWCNtI2hYbyNoWH5QIWRPayF7TyNtJFNhbyRTYX5PI3UjT08jdiNPTyN3JGhPfk9sJGpPIWgka09+T3AhaWkhXiFpaSFqIWlpIW0haWkjbiFpaWQhaWl+UCp6T3Aha2khXiFraSFqIWtpIW0ha2kjbiFraWQha2l+UCp6T3AhbGkhXiFsaSFqIWxpIW0hbGkjbiFsaWQhbGl+UCp6T3AjZmEhXiNmYX5QJFNPbyRsT35PZCRSUH5QJV9PZCN6UH5QJmxPYCFQWGR9WCFSfVghVCFQWH5PYCRzTyFUJHRPfk9kJHVPIVIjaU9+T2sjalhwI2pYIV4jalh+UCd0TyFeI2pPayRUYXAkVGF+TyFSI2lPayFVYXAhVWEhXiFVYWQhVWFgIVVhfk9TIV1PZSFZTyFWIVtPIVkhYE8jcSR5T35PZCRRUH5QOWRPdiN7T1EjfFhdI3xYYCN8WGQjfFhlI3xYaSN8WGojfFhrI3xYbSN8WHAjfFhyI3xYdCN8WHojfFghYCN8WCNvI3xYI3AjfFgjfSN8WGwjfFhvI3xYfk9dI3JPYCNyT2QlT09pI3JPaiNyT2sjck9+UCZsT10jck9gI3JPaSNyT2ojck9rI3JPbCVQT35QJmxPXSNyT2Ajck9pI3JPaiNyT2sjck9vJVFPflAmbE9lJVNPUyF0WGshdFghViF0WCFZIXRYI3EhdFh+T2slVE9+T2QlWU90JVpPIWElWk9+T2slW09+T28lY08jbyVeTyN9JV1Pfk9kJWRPflAkU092I3tPIV4laE8hcSVqT2shb2kjbSFvaW8hb2l+UCZsT2sjaGEjbSNoYW8jaGF+UCFkT2she08jbSRTaW8kU2l+TyFeJW1PZCRSWH5QJFNPZCVvT35PdiN7T1EjYFhkI2BYZSNgWG0jYFhwI2BYciNgWHQjYFh6I2BYIV4jYFghYCNgWCNvI2BYI3AjYFgjfSNgWH5PIV4lcU9kI3pYflAmbE9kJXNPfk9sJXRPdiN7T35PUiNnT3IjZ090I2dPI3Eldk8jfSFmT35PIVIjaU9rI2phcCNqYSFeI2phfk9gIVBYZH1YIVJ9WCFefVh+TyFSI2lPIV4leE9kJFFYfk9gJXpPfk9kJXtPfk8jbyV8T35PayZPT35PYCZQTyFSI2lPfk9kJlJPayZRT35PZCZVT35PUCN6T3BzWCFec1hkc1h+TyN9JV1PcCNUWCFeI1RYfk9wek8hXiZXT35PbyZbTyNvJV5PI30lXU9+T3Yje09RI2dYZSNnWGsjZ1htI2dYcCNnWHIjZ1h0I2dYeiNnWCFeI2dYIWAjZ1ghcSNnWCNtI2dYI28jZ1gjcCNnWCN9I2dYbyNnWH5PIV4laE8hcSZgT2shb3EjbSFvcW8hb3F+UCZsT2wmYU92I3tPfk9kI2VYIV4jZVh+UCVfTyFeJW1PZCRSYX5PZCNkWCFeI2RYflAmbE8hXiVxT2QjemF+T2QmZk9+UCZsT2QmZ08hVCZoT35PZCNjWCFeI2NYflA5ZE8hXiV4T2QkUWF+T10mbU9kJm9Pfk9TI2JhZSNiYSFWI2JhIVkjYmEjcSNiYX5PZCZxT35QR11PZCZxT2smck9+T3Yje09RI2dhZSNnYWsjZ2FtI2dhcCNnYXIjZ2F0I2dheiNnYSFeI2dhIWAjZ2EhcSNnYSNtI2dhI28jZ2EjcCNnYSN9I2dhbyNnYX5PZCNlYSFeI2VhflAkU09kI2RhIV4jZGF+UCZsT1IjZ09yI2dPdCNnTyNxJXZPI30lXU9+TyFSI2lPZCNjYSFeI2Nhfk9gJnhPfk8hXiV4T2QkUWl+UCZsT10mbU9kJnxPfk92I3tPZHxpa3xpfk9kJn1PflBHXU9rJ09Pfk9kJ1BPfk8hXiV4T2QkUXF+T2QjY3EhXiNjcX5QJmxPI3MhYSN0I31dI312IW1+XCIsXG4gIGdvdG86IFwiMmgkVVBQUFBQJFZQJFlQJGMkdVAkY1AlWCRjUFAlX1BQUCVlJW8lb1BQUFBQJW9QUCVvUCZdUCVvUCVvJ1clb1AndCd3J30nfSheJ31QJ31QJ31QJ30nfVAobSd9KHlQKHxQUClwKXYkYyl8JGMqU1AkY1AkYyRjUCpZKnsrWVAkWVArYVArZFAkWVAkWVAkWVAraiRZUCttK3Arcyt6JFlQJFlQUCRZUCxQLFYsZix8LVstYi1sLXIteC5PLlUuYC5mLmwuclBQUFBQUFBQUFBQLngvUi93L3owfFAxVTF1Mk8yUjJVMltSblFfXk9QYGt6IXskZHFbT1BZWmBrdXZ3eHohdiF7I2AkZCVtcVNPUFlaYGt1dnd4eiF2IXsjYCRkJW1RcFRSI1JxUSFPVlIjU3JRI1MhUVMkUSFpIWpSJGkjVSFWIW1hYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUSFVIW1hYyFjIWQhZSF6I2EjYyN0I3YjeCN7JGEkayRwJHMlaCVpJXEldSV6JlAmZCZsJngnUVUjZyFZJHQmaFUlYCRZJWImV1ImViVfIVYhaWFjIWMhZCFlIXojYSNjI3QjdiN4I3skYSRrJHAkcyVoJWklcSV1JXomUCZkJmwmeCdRUiRTIWtRJVckUlImUyVYayFeXWJmIVkhWyFnI2kjaiNtJFAkUiVYJXhRI2UhWVEkeyNtUSV3JHRRJmoleFImdyZoUSF5Z1EjcCFgUSReIXhSJWYkYFIjbiFdIVUhbWFjIWMhZCFlIXojYSNjI3QjdiN4I3skYSRrJHAkcyVoJWklcSV1JXomUCZkJmwmeCdRUSFxZFIkWCFyUSFQVlIjVHJRI1MhUFIkaSNUUSFTV1IjVnNRIVVYUiNXdFF7VVEhd2dRI155USNvIV9RJFUhblEkWyF1USRfIXlRJWUkXlEmWSVhUSZdJWZSJnYmWFNqUHpRIX1rUSRjIXtSJWskZFppUGt6IXskZFIkUCFnUSV9JVNSJnombVIhcmRSIXRlUiRaIXRTJWEkWSViUiZ0JldWJV8kWSViJldRI1BtUiRnI1BRYE9Ta1B6VSFhYGskZFIkZCF7USRwI2FZJXAkcCV1JmQmbCdRUSV1JHNRJmQlcVEmbCV6UidRJnhRI3QhY1EjdiFkUSN4IWVWJH0jdCN2I3hRJVgkUlImVCVYUSV5JHpTJmsleSZ5UiZ5JmxRJXIkcFImZSVyUSVuJG1SJmMlblF5VVIjXXlRJWkkYVImXyVpUSF8alMkZSF8JGZSJGYhfVEmbiV9UiZ7Jm5RI2shWlIkeCNrUSViJFlSJlolYlEmWCVhUiZ1JlhfX09QYGt6IXskZF5VT1Bga3oheyRkUSFWWVEhV1pRI1h1USNZdlEjWndRI1t4USRdIXZRJG0jYFImYiVtUiRxI2FRIWdhUSFvY1sjcSFjIWQhZSN0I3YjeFEkYSF6ZCRvI2EkcCRzJXEldSV6JmQmbCZ4J1FRJHIjY1ElUiN7UyVnJGElaVElbCRrUSZeJWhSJnAmUF0jcyFjIWQhZSN0I3YjeFchWl1iIWckUFEhdWZRI2YhWVEjbCFbUSR2I2lRJHcjalEkeiNtUyVWJFIlWFImaSV4USNoIVlRJXckdFImdyZoUiR8I21SJG4jYFFsUFIjX3pRIV9dUSFuYlEkTyFnUiVVJFBcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBVbml0IFZhcmlhYmxlTmFtZSBWYXJpYWJsZU5hbWUgUXVlcnlDYWxsZWUgQ29tbWVudCBTdHlsZVNoZWV0IFJ1bGVTZXQgVW5pdmVyc2FsU2VsZWN0b3IgVGFnU2VsZWN0b3IgVGFnTmFtZSBOZXN0aW5nU2VsZWN0b3IgQ2xhc3NTZWxlY3RvciAuIENsYXNzTmFtZSBQc2V1ZG9DbGFzc1NlbGVjdG9yIDogOjogUHNldWRvQ2xhc3NOYW1lIFBzZXVkb0NsYXNzTmFtZSApICggQXJnTGlzdCBWYWx1ZU5hbWUgUGFyZW50aGVzaXplZFZhbHVlIEF0S2V5d29yZCAjIDsgXSBbIEJyYWNrZXRlZFZhbHVlIH0geyBCcmFjZWRWYWx1ZSBDb2xvckxpdGVyYWwgTnVtYmVyTGl0ZXJhbCBTdHJpbmdMaXRlcmFsIEJpbmFyeUV4cHJlc3Npb24gQmluT3AgQ2FsbEV4cHJlc3Npb24gQ2FsbGVlIElmRXhwcmVzc2lvbiBpZiBBcmdMaXN0IElmQnJhbmNoIEtleXdvcmRRdWVyeSBGZWF0dXJlUXVlcnkgRmVhdHVyZU5hbWUgQmluYXJ5UXVlcnkgTG9naWNPcCBDb21wYXJpc29uUXVlcnkgQ29tcGFyZU9wIFVuYXJ5UXVlcnkgVW5hcnlRdWVyeU9wIFBhcmVudGhlc2l6ZWRRdWVyeSBTZWxlY3RvclF1ZXJ5IHNlbGVjdG9yIFBhcmVudGhlc2l6ZWRTZWxlY3RvciBDYWxsUXVlcnkgQXJnTGlzdCAsIENhbGxMaXRlcmFsIENhbGxUYWcgUGFyZW50aGVzaXplZENvbnRlbnQgUHNldWRvQ2xhc3NOYW1lIEFyZ0xpc3QgSWRTZWxlY3RvciBJZE5hbWUgQXR0cmlidXRlU2VsZWN0b3IgQXR0cmlidXRlTmFtZSBNYXRjaE9wIENoaWxkU2VsZWN0b3IgQ2hpbGRPcCBEZXNjZW5kYW50U2VsZWN0b3IgU2libGluZ1NlbGVjdG9yIFNpYmxpbmdPcCBCbG9jayBEZWNsYXJhdGlvbiBQcm9wZXJ0eU5hbWUgSW1wb3J0YW50IEltcG9ydFN0YXRlbWVudCBpbXBvcnQgTGF5ZXIgbGF5ZXIgTGF5ZXJOYW1lIGxheWVyIE1lZGlhU3RhdGVtZW50IG1lZGlhIENoYXJzZXRTdGF0ZW1lbnQgY2hhcnNldCBOYW1lc3BhY2VTdGF0ZW1lbnQgbmFtZXNwYWNlIE5hbWVzcGFjZU5hbWUgS2V5ZnJhbWVzU3RhdGVtZW50IGtleWZyYW1lcyBLZXlmcmFtZU5hbWUgS2V5ZnJhbWVMaXN0IEtleWZyYW1lU2VsZWN0b3IgS2V5ZnJhbWVSYW5nZU5hbWUgU3VwcG9ydHNTdGF0ZW1lbnQgc3VwcG9ydHMgU2NvcGVTdGF0ZW1lbnQgc2NvcGUgdG8gQXRSdWxlIFN0eWxlc1wiLFxuICBtYXhUZXJtOiAxNDMsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImlzb2xhdGVcIiwgLTIsNSwzNixcIlwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCAyMCxcIihcIiwyOCxcIltcIiwzMSxcIntcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMjEsXCIpXCIsMjksXCJdXCIsMzIsXCJ9XCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbY3NzSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMCw1LDEwNl0sXG4gIHJlcGVhdE5vZGVDb3VudDogMTUsXG4gIHRva2VuRGF0YTogXCJKUX5SIVlPWCRxWF4laV5wJHFwcSVpcXIoe3JzLXVzdC9pdHU2V3V2JHF2dzdRd3g3Y3h5OVF5ejljens5aHt8OlJ8fT50fSFPP1YhTyFQP3QhUCFRQF0hUSFbQVUhWyFdQlAhXSFeQnshXiFfQ14hXyFgRFkhYCFhRG0hYSFiJHEhYiFjRW4hYyF9JHEhfSNPR3sjTyNQJHEjUCNRSF4jUSNSNlcjUiNvJHEjbyNwSG8jcCNxNlcjcSNySVEjciNzSWMjcyN5JHEjeSN6JWkjeiRmJHEkZiRnJWkkZyNCWSRxI0JZI0JaJWkjQlokSVMkcSRJUyRJXyVpJElfJEl8JHEkSXwkSk8laSRKTyRKVCRxJEpUJEpVJWkkSlUkS1YkcSRLViRLVyVpJEtXJkZVJHEmRlUmRlYlaSZGVjsnUyRxOydTOz1gSXo8JWxPJHFgJHRTT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRYCVWUyFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWAlZlA7PWA8JWwlUX4lbmgjc35PWCVRWF4nWV5wJVFwcSdZcXklUXojeSVRI3kjeidZI3okZiVRJGYkZydZJGcjQlklUSNCWSNCWidZI0JaJElTJVEkSVMkSV8nWSRJXyRJfCVRJEl8JEpPJ1kkSk8kSlQlUSRKVCRKVSdZJEpVJEtWJVEkS1YkS1cnWSRLVyZGVSVRJkZVJkZWJ1kmRlY7J1MlUTsnUzs9YCVjPCVsTyVRfidhaCNzfiFhYE9YJVFYXidZXnAlUXBxJ1lxeSVReiN5JVEjeSN6J1kjeiRmJVEkZiRnJ1kkZyNCWSVRI0JZI0JaJ1kjQlokSVMlUSRJUyRJXydZJElfJEl8JVEkSXwkSk8nWSRKTyRKVCVRJEpUJEpVJ1kkSlUkS1YlUSRLViRLVydZJEtXJkZVJVEmRlUmRlYnWSZGVjsnUyVROydTOz1gJWM8JWxPJVFqKU9VT3klUXojXSVRI10jXiliI147J1MlUTsnUzs9YCVjPCVsTyVRailnVSFhYE95JVF6I2ElUSNhI2IpeSNiOydTJVE7J1M7PWAlYzwlbE8lUWoqT1UhYWBPeSVReiNkJVEjZCNlKmIjZTsnUyVROydTOz1gJWM8JWxPJVFqKmdVIWFgT3klUXojYyVRI2MjZCp5I2Q7J1MlUTsnUzs9YCVjPCVsTyVRaitPVSFhYE95JVF6I2YlUSNmI2crYiNnOydTJVE7J1M7PWAlYzwlbE8lUWorZ1UhYWBPeSVReiNoJVEjaCNpK3kjaTsnUyVROydTOz1gJWM8JWxPJVFqLE9VIWFgT3klUXojVCVRI1QjVSxiI1U7J1MlUTsnUzs9YCVjPCVsTyVRaixnVSFhYE95JVF6I2IlUSNiI2MseSNjOydTJVE7J1M7PWAlYzwlbE8lUWotT1UhYWBPeSVReiNoJVEjaCNpLWIjaTsnUyVROydTOz1gJWM8JWxPJVFqLWlTIXFZIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRfi14V09ZLXVaci11cnMuYnMjTy11I08jUC5nI1A7J1MtdTsnUzs9YC9jPCVsTy11fi5nT3R+fi5qUk87J1MtdTsnUzs9YC5zOz1gTy11fi52WE9ZLXVaci11cnMuYnMjTy11I08jUC5nI1A7J1MtdTsnUzs9YC9jOz1gPCVsLXU8JWxPLXV+L2ZQOz1gPCVsLXVqL25ZallPeSVReiFRJVEhUSFbMF4hWyFjJVEhYyFpMF4haSNUJVEjVCNaMF4jWjsnUyVROydTOz1gJWM8JWxPJVFqMGNZIWFgT3klUXohUSVRIVEhWzFSIVshYyVRIWMhaTFSIWkjVCVRI1QjWjFSI1o7J1MlUTsnUzs9YCVjPCVsTyVRajFXWSFhYE95JVF6IVElUSFRIVsxdiFbIWMlUSFjIWkxdiFpI1QlUSNUI1oxdiNaOydTJVE7J1M7PWAlYzwlbE8lUWoxfVlyWSFhYE95JVF6IVElUSFRIVsybSFbIWMlUSFjIWkybSFpI1QlUSNUI1oybSNaOydTJVE7J1M7PWAlYzwlbE8lUWoydFlyWSFhYE95JVF6IVElUSFRIVszZCFbIWMlUSFjIWkzZCFpI1QlUSNUI1ozZCNaOydTJVE7J1M7PWAlYzwlbE8lUWozaVkhYWBPeSVReiFRJVEhUSFbNFghWyFjJVEhYyFpNFghaSNUJVEjVCNaNFgjWjsnUyVROydTOz1gJWM8JWxPJVFqNGBZclkhYWBPeSVReiFRJVEhUSFbNU8hWyFjJVEhYyFpNU8haSNUJVEjVCNaNU8jWjsnUyVROydTOz1gJWM8JWxPJVFqNVRZIWFgT3klUXohUSVRIVEhWzVzIVshYyVRIWMhaTVzIWkjVCVRI1QjWjVzI1o7J1MlUTsnUzs9YCVjPCVsTyVRajV6U3JZIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRZDZaVU95JVF6IV8lUSFfIWA2bSFgOydTJVE7J1M7PWAlYzwlbE8lUWQ2dFMhaFMhYWBPeSVRejsnUyVROydTOz1gJWM8JWxPJVFiN1ZTWlFPeSVRejsnUyVROydTOz1gJWM8JWxPJVF+N2ZXT1k3Y1p3N2N3eC5ieCNPN2MjTyNQOE8jUDsnUzdjOydTOz1gOHo8JWxPN2N+OFJSTzsnUzdjOydTOz1gOFs7PWBPN2N+OF9YT1k3Y1p3N2N3eC5ieCNPN2MjTyNQOE8jUDsnUzdjOydTOz1gOHo7PWA8JWw3YzwlbE83Y344fVA7PWA8JWw3Y2o5VlNlWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUX45aE9kfm45b1VXUXZXT3klUXohXyVRIV8hYDZtIWA7J1MlUTsnUzs9YCVjPCVsTyVRajpZV3ZXIW1RT3klUXohTyVRIU8hUDpyIVAhUSVRIVEhWz13IVs7J1MlUTsnUzs9YCVjPCVsTyVRajp3VSFhYE95JVF6IVElUSFRIVs7WiFbOydTJVE7J1M7PWAlYzwlbE8lUWo7YlkhYWAjfVlPeSVReiFRJVEhUSFbO1ohWyFnJVEhZyFoPFEhaCNYJVEjWCNZPFEjWTsnUyVROydTOz1gJWM8JWxPJVFqPFZZIWFgT3klUXp7JVF7fDx1fH0lUX0hTzx1IU8hUSVRIVEhWz1eIVs7J1MlUTsnUzs9YCVjPCVsTyVRajx6VSFhYE95JVF6IVElUSFRIVs9XiFbOydTJVE7J1M7PWAlYzwlbE8lUWo9ZVUhYWAjfVlPeSVReiFRJVEhUSFbPV4hWzsnUyVROydTOz1gJWM8JWxPJVFqPk9bIWFgI31ZT3klUXohTyVRIU8hUDtaIVAhUSVRIVEhWz13IVshZyVRIWchaDxRIWgjWCVRI1gjWTxRI1k7J1MlUTsnUzs9YCVjPCVsTyVRaj55UyFeWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWo/W1d2V095JVF6IU8lUSFPIVA6ciFQIVElUSFRIVs9dyFbOydTJVE7J1M7PWAlYzwlbE8lUWo/eVVdWU95JVF6IVElUSFRIVs7WiFbOydTJVE7J1M7PWAlYzwlbE8lUX5AYlR2V095JVF6e0BxezsnUyVROydTOz1gJWM8JWxPJVF+QHhTIWFgI3R+T3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRakFaWyN9WU95JVF6IU8lUSFPIVA7WiFQIVElUSFRIVs9dyFbIWclUSFnIWg8USFoI1glUSNYI1k8USNZOydTJVE7J1M7PWAlYzwlbE8lUWpCVVVgWU95JVF6IVslUSFbIV1CaCFdOydTJVE7J1M7PWAlYzwlbE8lUWJCb1NhUSFhYE95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpDUVNrWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWhDY1UhVFdPeSVReiFfJVEhXyFgQ3UhYDsnUyVROydTOz1gJWM8JWxPJVFoQ3xTIVRXIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRbERhUyFUVyFoU095JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpEdFYhalEhVFdPeSVReiFfJVEhXyFgQ3UhYCFhRVohYTsnUyVROydTOz1gJWM8JWxPJVFiRWJTIWpRIWFgT3klUXo7J1MlUTsnUzs9YCVjPCVsTyVRakVxWU95JVF6fSVRfSFPRmEhTyFjJVEhYyF9R08hfSNUJVEjVCNvR08jbzsnUyVROydTOz1gJWM8JWxPJVFqRmZXIWFgT3klUXohYyVRIWMhfUdPIX0jVCVRI1Qjb0dPI287J1MlUTsnUzs9YCVjPCVsTyVRakdWW2lZIWFgT3klUXp9JVF9IU9HTyFPIVElUSFRIVtHTyFbIWMlUSFjIX1HTyF9I1QlUSNUI29HTyNvOydTJVE7J1M7PWAlYzwlbE8lUWpIUVNtWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUW5IY1NsXk95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpIdFNwWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWpJVlNvWU95JVF6OydTJVE7J1M7PWAlYzwlbE8lUWZJaFUhbVFPeSVReiFfJVEhXyFgNm0hYDsnUyVROydTOz1gJWM8JWxPJVFgSX1QOz1gPCVsJHFcIixcbiAgdG9rZW5pemVyczogW2Rlc2NlbmRhbnQsIHVuaXRUb2tlbiwgaWRlbnRpZmllcnMsIHF1ZXJ5SWRlbnRpZmllcnMsIDEsIDIsIDMsIDQsIG5ldyBMb2NhbFRva2VuR3JvdXAoXCJtflJSWVpbenthfn5nfmFPI3Z+fmRQIVAhUWd+bE8jd35+XCIsIDI4LCAxMjkpXSxcbiAgdG9wUnVsZXM6IHtcIlN0eWxlU2hlZXRcIjpbMCw2XSxcIlN0eWxlc1wiOlsxLDEwNV19LFxuICBzcGVjaWFsaXplZDogW3t0ZXJtOiAxMjQsIGdldDogKHZhbHVlKSA9PiBzcGVjX2NhbGxlZVt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAxMjUsIGdldDogKHZhbHVlKSA9PiBzcGVjX3F1ZXJ5SWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiA0LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19RdWVyeUNhbGxlZVt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAyNSwgZ2V0OiAodmFsdWUpID0+IHNwZWNfQXRLZXl3b3JkW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDEyMywgZ2V0OiAodmFsdWUpID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9XSxcbiAgdG9rZW5QcmVjOiAxOTYzXG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/css/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The optional name of the base tag @internal\n    */\n    name, \n    /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)\n            if (mod.name)\n                name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag)\n            parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name) {\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.configure({props: [\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n]})\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Mode.Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Mode.Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n    combine(a, b) {\n        let cur, root, take;\n        while (a || b) {\n            if (!a || b && a.depth >= b.depth) {\n                take = b;\n                b = b.next;\n            }\n            else {\n                take = a;\n                a = a.next;\n            }\n            if (cur && cur.mode == take.mode && !take.context && !cur.context)\n                continue;\n            let copy = new Rule(take.tags, take.mode, take.context);\n            if (cur)\n                cur.next = copy;\n            else\n                root = copy;\n            cur = copy;\n        }\n        return root;\n    }\n});\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Mode.Opaque */; }\n    get inherit() { return this.mode == 1 /* Mode.Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/\nfunction highlightTree(tree, highlighter, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/\nfunction highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos)\n            return;\n        for (let text = code.slice(pos, p), i = 0;;) {\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i)\n                putText(text.slice(i, upto), classes);\n            if (nextBreak < 0)\n                break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes) => {\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            if (mounted)\n                inheritedClass = \"\";\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */\n    lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */\n    blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */\n    docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */\n    variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */\n    tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */\n    attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */\n    className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */\n    labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */\n    namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */\n    macroName: t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */\n    docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */\n    character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */\n    attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */\n    integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */\n    float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */\n    bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */\n    regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */\n    color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */\n    url: t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */\n    null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */\n    unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */\n    modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */\n    controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */\n    moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */\n    derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */\n    arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */\n    logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */\n    bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */\n    compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */\n    typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */\n    controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */\n    brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */\n    heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */\n    heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */\n    heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */\n    heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */\n    heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */\n    heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */\n    contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */\n    list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */\n    quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */\n    emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */\n    strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */\n    link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: t(),\n    /**\n    Deleted text.\n    */\n    deleted: t(),\n    /**\n    Changed text.\n    */\n    changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */\n    processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */\n    definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */\n    constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */\n    local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: Tag.defineModifier(\"special\")\n};\nfor (let name in tags) {\n    let val = tags[name];\n    if (val instanceof Tag)\n        val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLDBCQUEwQixTQUFTLEdBQUcsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSxrRkFBa0Y7QUFDeEYsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxtRkFBbUY7QUFDekYsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSx5Q0FBeUM7QUFDL0MsTUFBTTtBQUNOOztBQUU4RyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWFwcC1idWlsZGVyLXdlYi8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguanM/YWVkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5sZXQgbmV4dFRhZ0lEID0gMDtcbi8qKlxuSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG5UaGV5IGFyZSBbYXNzb2NpYXRlZF0oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcbnRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuXG5CZWNhdXNlIHN5bnRheCB0cmVlIG5vZGUgdHlwZXMgYW5kIGhpZ2hsaWdodCBzdHlsZXMgaGF2ZSB0byBiZVxuYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cblt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG50cmFkaXRpb25hbCBvcGVuIHN0cmluZy1iYXNlZCBzeXN0ZW1zLCB3aGljaCBtYWtlIGl0IGhhcmQgZm9yXG5oaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxudmFyaW91cyBsYW5ndWFnZXMpLlxuXG5JdCBfaXNfIHBvc3NpYmxlIHRvIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgeW91ciBvd25cbmhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG50aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuYmUgcGlja2VkIHVwIGJ5IHJlZ3VsYXIgaGlnaGxpZ2h0ZXJzICh0aG91Z2ggeW91IGNhbiBkZXJpdmUgdGhlbVxuZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuKi9cbmNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgYmFzZSB0YWcgQGludGVybmFsXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIHRoaXMgdGFnIGFuZCBhbGwgaXRzIHBhcmVudCB0YWdzLCBzdGFydGluZyB3aXRoXG4gICAgdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICAqL1xuICAgIHNldCwgXG4gICAgLyoqXG4gICAgVGhlIGJhc2UgdW5tb2RpZmllZCB0YWcgdGhhdCB0aGlzIG9uZSBpcyBiYXNlZCBvbiwgaWYgaXQnc1xuICAgIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgICovXG4gICAgYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIG1vZGlmaWVycyBhcHBsaWVkIHRvIHRoaXMuYmFzZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgbW9kIG9mIHRoaXMubW9kaWZpZWQpXG4gICAgICAgICAgICBpZiAobW9kLm5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZSA9IGAke21vZC5uYW1lfSgke25hbWV9KWA7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKG5hbWVPclBhcmVudCwgcGFyZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0gdHlwZW9mIG5hbWVPclBhcmVudCA9PSBcInN0cmluZ1wiID8gbmFtZU9yUGFyZW50IDogXCI/XCI7XG4gICAgICAgIGlmIChuYW1lT3JQYXJlbnQgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgICAgICBwYXJlbnQgPSBuYW1lT3JQYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYmFzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVyaXZlIGZyb20gYSBtb2RpZmllZCB0YWdcIik7XG4gICAgICAgIGxldCB0YWcgPSBuZXcgVGFnKG5hbWUsIFtdLCBudWxsLCBbXSk7XG4gICAgICAgIHRhZy5zZXQucHVzaCh0YWcpO1xuICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiBwYXJlbnQuc2V0KVxuICAgICAgICAgICAgICAgIHRhZy5zZXQucHVzaCh0KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIHNhbWUgbW9kaWZpZXIgdG8gYSB0d2ljZSB0YWcgd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgKGBtMSh0MSlcbiAgICA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICBcbiAgICBXaGVuIG11bHRpcGxlIG1vZGlmaWVycyBhcmUgYXBwbGllZCB0byBhIGdpdmVuIGJhc2UgdGFnLCBlYWNoXG4gICAgc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgYG0xKG0zKHQxKWAsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcihuYW1lKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXIobmFtZSk7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoYmFzZS5uYW1lLCBzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLmNvbmZpZ3VyZSh7cHJvcHM6IFtcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG5dfSlcbmBgYFxuKi9cbmZ1bmN0aW9uIHN0eWxlVGFncyhzcGVjKSB7XG4gICAgbGV0IGJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB0YWdzID0gc3BlY1twcm9wXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlcyA9IFtdLCBtb2RlID0gMiAvKiBNb2RlLk5vcm1hbCAqLywgcmVzdCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ID09IFwiLi4uXCIgJiYgcG9zID4gMCAmJiBwb3MgKyAzID09IHBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMSAvKiBNb2RlLkluaGVyaXQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IC9eXCIoPzpbXlwiXFxcXF18XFxcXC4pKj9cInxbXlxcLyFdKy8uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKG1bMF0gPT0gXCIqXCIgPyBcIlwiIDogbVswXVswXSA9PSAnXCInID8gSlNPTi5wYXJzZShtWzBdKSA6IG1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0W3BvcysrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aCAmJiBuZXh0ID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMCAvKiBNb2RlLk9wYXF1ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBwYXJ0LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gcGllY2VzLmxlbmd0aCAtIDEsIGlubmVyID0gcGllY2VzW2xhc3RdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gbmV3IFJ1bGUodGFncywgbW9kZSwgbGFzdCA+IDAgPyBwaWVjZXMuc2xpY2UoMCwgbGFzdCkgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBieU5hbWVbaW5uZXJdID0gcnVsZS5zb3J0KGJ5TmFtZVtpbm5lcl0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZU5vZGVQcm9wLmFkZChieU5hbWUpO1xufVxuY29uc3QgcnVsZU5vZGVQcm9wID0gbmV3IE5vZGVQcm9wKHtcbiAgICBjb21iaW5lKGEsIGIpIHtcbiAgICAgICAgbGV0IGN1ciwgcm9vdCwgdGFrZTtcbiAgICAgICAgd2hpbGUgKGEgfHwgYikge1xuICAgICAgICAgICAgaWYgKCFhIHx8IGIgJiYgYS5kZXB0aCA+PSBiLmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgdGFrZSA9IGI7XG4gICAgICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRha2UgPSBhO1xuICAgICAgICAgICAgICAgIGEgPSBhLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VyICYmIGN1ci5tb2RlID09IHRha2UubW9kZSAmJiAhdGFrZS5jb250ZXh0ICYmICFjdXIuY29udGV4dClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IFJ1bGUodGFrZS50YWdzLCB0YWtlLm1vZGUsIHRha2UuY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY3VyKVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0ID0gY29weTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByb290ID0gY29weTtcbiAgICAgICAgICAgIGN1ciA9IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxufSk7XG5jbGFzcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzLCBtb2RlLCBjb250ZXh0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIGdldCBvcGFxdWUoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMCAvKiBNb2RlLk9wYXF1ZSAqLzsgfVxuICAgIGdldCBpbmhlcml0KCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovOyB9XG4gICAgc29ydChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XG59XG5SdWxlLmVtcHR5ID0gbmV3IFJ1bGUoW10sIDIgLyogTW9kZS5Ob3JtYWwgKi8sIG51bGwpO1xuLyoqXG5EZWZpbmUgYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpIGZyb20gYW4gYXJyYXkgb2ZcbnRhZy9jbGFzcyBwYWlycy4gQ2xhc3NlcyBhc3NvY2lhdGVkIHdpdGggbW9yZSBzcGVjaWZpYyB0YWdzIHdpbGxcbnRha2UgcHJlY2VkZW5jZS5cbiovXG5mdW5jdGlvbiB0YWdIaWdobGlnaHRlcih0YWdzLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgc3R5bGUgb2YgdGFncykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUudGFnKSlcbiAgICAgICAgICAgIG1hcFtzdHlsZS50YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBzdHlsZS50YWcpXG4gICAgICAgICAgICAgICAgbWFwW3RhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICB9XG4gICAgbGV0IHsgc2NvcGUsIGFsbCA9IG51bGwgfSA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6ICh0YWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2xzID0gYWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2YgdGFnLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFnQ2xhc3MgPSBtYXBbc3ViLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSBjbHMgPyBjbHMgKyBcIiBcIiArIHRhZ0NsYXNzIDogdGFnQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCB0YWdzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIHZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gW3RyZWVdKCNjb21tb24uVHJlZSkgd2l0aCB0aGUgZ2l2ZW5cbltoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuIE9mdGVuLCB0aGUgaGlnaGVyLWxldmVsXG5bYGhpZ2hsaWdodENvZGVgXSgjaGlnaGxpZ2h0LmhpZ2hsaWdodENvZGUpIGZ1bmN0aW9uIGlzIGVhc2llciB0b1xudXNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLyoqXG5Bc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXG5vZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbmBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG4qL1xucHV0U3R5bGUsIFxuLyoqXG5UaGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvIGhpZ2hsaWdodC5cbiovXG5mcm9tID0gMCwgXG4vKipcblRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuKi9cbnRvID0gdHJlZS5sZW5ndGgpIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBIaWdobGlnaHRCdWlsZGVyKGZyb20sIEFycmF5LmlzQXJyYXkoaGlnaGxpZ2h0ZXIpID8gaGlnaGxpZ2h0ZXIgOiBbaGlnaGxpZ2h0ZXJdLCBwdXRTdHlsZSk7XG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xuICAgIGJ1aWxkZXIuZmx1c2godG8pO1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gaGlnaGxpZ2h0ZXIsIGNhbGxpbmdcbmBwdXRUZXh0YCBmb3IgZXZlcnkgcGllY2Ugb2YgdGV4dCwgZWl0aGVyIHdpdGggYSBzZXQgb2YgY2xhc3NlcyBvclxud2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gdW5zdHlsZWQsIGFuZCBgcHV0QnJlYWtgIGZvciBldmVyeSBsaW5lXG5icmVhay5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRDb2RlKGNvZGUsIHRyZWUsIGhpZ2hsaWdodGVyLCBwdXRUZXh0LCBwdXRCcmVhaywgZnJvbSA9IDAsIHRvID0gY29kZS5sZW5ndGgpIHtcbiAgICBsZXQgcG9zID0gZnJvbTtcbiAgICBmdW5jdGlvbiB3cml0ZVRvKHAsIGNsYXNzZXMpIHtcbiAgICAgICAgaWYgKHAgPD0gcG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0ZXh0ID0gY29kZS5zbGljZShwb3MsIHApLCBpID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKFwiXFxuXCIsIGkpO1xuICAgICAgICAgICAgbGV0IHVwdG8gPSBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWs7XG4gICAgICAgICAgICBpZiAodXB0byA+IGkpXG4gICAgICAgICAgICAgICAgcHV0VGV4dCh0ZXh0LnNsaWNlKGksIHVwdG8pLCBjbGFzc2VzKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHV0QnJlYWsoKTtcbiAgICAgICAgICAgIGkgPSBuZXh0QnJlYWsgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IHA7XG4gICAgfVxuICAgIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIChmcm9tLCB0bywgY2xhc3NlcykgPT4ge1xuICAgICAgICB3cml0ZVRvKGZyb20sIFwiXCIpO1xuICAgICAgICB3cml0ZVRvKHRvLCBjbGFzc2VzKTtcbiAgICB9LCBmcm9tLCB0byk7XG4gICAgd3JpdGVUbyh0bywgXCJcIik7XG59XG5jbGFzcyBIaWdobGlnaHRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlcnMgPSBoaWdobGlnaHRlcnM7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuY2xhc3MgPSBcIlwiO1xuICAgIH1cbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgICAgICB0aGlzLmNsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKHRvKSB7XG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuc3Bhbih0aGlzLmF0LCB0bywgdGhpcy5jbGFzcyk7XG4gICAgfVxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZnJvbTogc3RhcnQsIHRvOiBlbmQgfSA9IGN1cnNvcjtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZS5pc1RvcClcbiAgICAgICAgICAgIGhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUodHlwZSkpO1xuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XG4gICAgICAgIGxldCBydWxlID0gZ2V0U3R5bGVUYWdzKGN1cnNvcikgfHwgUnVsZS5lbXB0eTtcbiAgICAgICAgbGV0IHRhZ0NscyA9IGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCBydWxlLnRhZ3MpO1xuICAgICAgICBpZiAodGFnQ2xzKSB7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XG4gICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyB0YWdDbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5tYXgoZnJvbSwgc3RhcnQpLCBjbHMpO1xuICAgICAgICBpZiAocnVsZS5vcGFxdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtb3VudGVkID0gY3Vyc29yLnRyZWUgJiYgY3Vyc29yLnRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBjdXJzb3Iubm9kZS5lbnRlcihtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIGxldCBpbm5lckhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobW91bnRlZC50cmVlLnR5cGUpKTtcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGkgPCBtb3VudGVkLm92ZXJsYXkubGVuZ3RoID8gbW91bnRlZC5vdmVybGF5W2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKSwgcmFuZ2VUbyA9IE1hdGgubWluKHRvLCBuZXh0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VGcm9tIDwgcmFuZ2VUbyAmJiBoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgcmFuZ2VGcm9tLCByYW5nZVRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHJhbmdlVG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IG5leHRQb3MgfHwgIWN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0UG9zID4gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGlubmVyLmN1cnNvcigpLCBNYXRoLm1heChmcm9tLCBuZXh0LmZyb20gKyBzdGFydCksIE1hdGgubWluKHRvLCBwb3MpLCBcIlwiLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBwb3MpLCBjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZClcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5NYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxudGhlcmUncyBhIG1hdGNoLCByZXR1cm4gaXRzIHNldCBvZiB0YWdzLCBhbmQgd2hldGhlciBpdCBpc1xub3BhcXVlICh1c2VzIGEgYCFgKSBvciBhcHBsaWVzIHRvIGFsbCBjaGlsZCBub2RlcyAoYC8uLi5gKS5cbiovXG5mdW5jdGlvbiBnZXRTdHlsZVRhZ3Mobm9kZSkge1xuICAgIGxldCBydWxlID0gbm9kZS50eXBlLnByb3AocnVsZU5vZGVQcm9wKTtcbiAgICB3aGlsZSAocnVsZSAmJiBydWxlLmNvbnRleHQgJiYgIW5vZGUubWF0Y2hDb250ZXh0KHJ1bGUuY29udGV4dCkpXG4gICAgICAgIHJ1bGUgPSBydWxlLm5leHQ7XG4gICAgcmV0dXJuIHJ1bGUgfHwgbnVsbDtcbn1cbmNvbnN0IHQgPSBUYWcuZGVmaW5lO1xuY29uc3QgY29tbWVudCA9IHQoKSwgbmFtZSA9IHQoKSwgdHlwZU5hbWUgPSB0KG5hbWUpLCBwcm9wZXJ0eU5hbWUgPSB0KG5hbWUpLCBsaXRlcmFsID0gdCgpLCBzdHJpbmcgPSB0KGxpdGVyYWwpLCBudW1iZXIgPSB0KGxpdGVyYWwpLCBjb250ZW50ID0gdCgpLCBoZWFkaW5nID0gdChjb250ZW50KSwga2V5d29yZCA9IHQoKSwgb3BlcmF0b3IgPSB0KCksIHB1bmN0dWF0aW9uID0gdCgpLCBicmFja2V0ID0gdChwdW5jdHVhdGlvbiksIG1ldGEgPSB0KCk7XG4vKipcblRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cblxuVGhpcyBjb2xsZWN0aW9uIGlzIGhlYXZpbHkgYmlhc2VkIHRvd2FyZHMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLFxuYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcbmNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbndyaXRlIHRoZW1lcyBmb3IuIFNvIHRyeSB0byBtYWtlIGRvIHdpdGggdGhpcyBzZXQuIElmIGFsbCBlbHNlXG5mYWlscywgW29wZW4gYW5cbmlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxubmV3IHRhZywgb3IgW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSBhIGxvY2FsIGN1c3RvbSB0YWcgZm9yXG55b3VyIHVzZSBjYXNlLlxuXG5Ob3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xudGFnIHBvc3NpYmxlIHRvIGFuIGVsZW1lbnTigJRpZiB5b3VyIGdyYW1tYXIgY2FuJ3QgZWFzaWx5XG5kaXN0aW5ndWlzaCBhIGNlcnRhaW4gdHlwZSBvZiBlbGVtZW50IChzdWNoIGFzIGEgbG9jYWwgdmFyaWFibGUpLFxuaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuXG5Gb3IgdGFncyB0aGF0IGV4dGVuZCBzb21lIHBhcmVudCB0YWcsIHRoZSBkb2N1bWVudGF0aW9uIGxpbmtzIHRvXG50aGUgcGFyZW50LlxuKi9cbmNvbnN0IHRhZ3MgPSB7XG4gICAgLyoqXG4gICAgQSBjb21tZW50LlxuICAgICovXG4gICAgY29tbWVudCxcbiAgICAvKipcbiAgICBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgYmxvY2sgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGRvY0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQW55IGtpbmQgb2YgaWRlbnRpZmllci5cbiAgICAqL1xuICAgIG5hbWUsXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cbiAgICAqL1xuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgICAvKipcbiAgICBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgICovXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLyoqXG4gICAgQSBwcm9wZXJ0eSBvciBmaWVsZCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZU5hbWU6IHQocHJvcGVydHlOYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxuICAgICovXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGFiZWwgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbmFtZXNwYWNlOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXG4gICAgKi9cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsaXRlcmFsIHZhbHVlLlxuICAgICovXG4gICAgbGl0ZXJhbCxcbiAgICAvKipcbiAgICBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgc3RyaW5nLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgICAqL1xuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVWYWx1ZTogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBudW1iZXIsXG4gICAgLyoqXG4gICAgQW4gaW50ZWdlciBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgaW50ZWdlcjogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGZsb2F0OiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBib29sZWFuIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIFJlZ3VsYXIgZXhwcmVzc2lvbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgcmVnZXhwOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgYmFja3NsYXNoIGVzY2FwZSBpbiBhIHN0cmluZy5cbiAgICAqL1xuICAgIGVzY2FwZTogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBjb2xvcjogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIFVSTCBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2Uga2V5d29yZC5cbiAgICAqL1xuICAgIGtleXdvcmQsXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICBvYmplY3QuXG4gICAgKi9cbiAgICBzZWxmOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgICovXG4gICAgbnVsbDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXG4gICAgKi9cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IHJlcHJlc2VudHMgYSB1bml0LlxuICAgICovXG4gICAgdW5pdDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBtb2RpZmllcjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgY29udHJvbC1mbG93IHJlbGF0ZWQgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIGNvbnRyb2xLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcbiAgICBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgKi9cbiAgICBtb2R1bGVLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3IsXG4gICAgLyoqXG4gICAgQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVyZWZlcmVuY2VzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlcmVmT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIExvZ2ljYWwgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGJpdHdpc2VPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IHVwZGF0ZXMgaXRzIG9wZXJhbmQuXG4gICAgKi9cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxuICAgICovXG4gICAgcHVuY3R1YXRpb24sXG4gICAgLyoqXG4gICAgW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgdGhpbmdzLlxuICAgICovXG4gICAgc2VwYXJhdG9yOiB0KHB1bmN0dWF0aW9uKSxcbiAgICAvKipcbiAgICBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICAqL1xuICAgIGJyYWNrZXQsXG4gICAgLyoqXG4gICAgQW5nbGUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFNxdWFyZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgW2AgYW5kIGBdYFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFBhcmVudGhlc2VzICh1c3VhbGx5IGAoYCBhbmQgYClgIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBwYXJlbjogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBCcmFjZXMgKHVzdWFsbHkgYHtgIGFuZCBgfWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIENvbnRlbnQsIGZvciBleGFtcGxlIHBsYWluIHRleHQgaW4gWE1MIG9yIG1hcmt1cCBkb2N1bWVudHMuXG4gICAgKi9cbiAgICBjb250ZW50LFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgICAqL1xuICAgIGhlYWRpbmcsXG4gICAgLyoqXG4gICAgQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDIgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzM6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDUgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzY6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBwcm9zZSBbY29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICAqL1xuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgICAqL1xuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgKi9cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAgICovXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgc3R5bGUuXG4gICAgKi9cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBEZWxldGVkIHRleHQuXG4gICAgKi9cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLyoqXG4gICAgQ2hhbmdlZCB0ZXh0LlxuICAgICovXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IHQoKSxcbiAgICAvKipcbiAgICBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgICovXG4gICAgbWV0YSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYW5ub3RhdGVzIG9yIGFkZHNcbiAgICBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gb3IgcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZS4gU3VidGFnIG9mXG4gICAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgICBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IFRhZy5kZWZpbmVNb2RpZmllcihcImRlZmluaXRpb25cIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgKi9cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKFwiY29uc3RhbnRcIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgYXMgYSBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJmdW5jdGlvblwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICAgIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgICovXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcihcInN0YW5kYXJkXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIGEgZ2l2ZW5cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgICovXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcihcImxvY2FsXCIpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXRcbiAgICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICBmb3JtcyBvZiBhdCBsZWFzdCB0aGUgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykgYW5kXG4gICAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IFRhZy5kZWZpbmVNb2RpZmllcihcInNwZWNpYWxcIilcbn07XG5mb3IgKGxldCBuYW1lIGluIHRhZ3MpIHtcbiAgICBsZXQgdmFsID0gdGFnc1tuYW1lXTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgVGFnKVxuICAgICAgICB2YWwubmFtZSA9IG5hbWU7XG59XG4vKipcblRoaXMgaXMgYSBoaWdobGlnaHRlciB0aGF0IGFkZHMgc3RhYmxlLCBwcmVkaWN0YWJsZSBjbGFzc2VzIHRvXG50b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuXG5UaGUgZm9sbG93aW5nIHRhZ3MgYXJlIG1hcHBlZCB0byB0aGVpciBuYW1lIHByZWZpeGVkIHdpdGggYFwidG9rLVwiYFxuKGZvciBleGFtcGxlIGBcInRvay1jb21tZW50XCJgKTpcblxuKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbiogW2BoZWFkaW5nYF0oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4qIFtgZW1waGFzaXNgXSgjaGlnaGxpZ2h0LnRhZ3MuZW1waGFzaXMpXG4qIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbiogW2BrZXl3b3JkYF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4qIFtgYXRvbWBdKCNoaWdobGlnaHQudGFncy5hdG9tKVxuKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbiogW2B1cmxgXSgjaGlnaGxpZ2h0LnRhZ3MudXJsKVxuKiBbYGxhYmVsTmFtZWBdKCNoaWdobGlnaHQudGFncy5sYWJlbE5hbWUpXG4qIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4qIFtgZGVsZXRlZGBdKCNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuKiBbYGxpdGVyYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbClcbiogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuKiBbYG51bWJlcmBdKCNoaWdobGlnaHQudGFncy5udW1iZXIpXG4qIFtgdmFyaWFibGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbiogW2BuYW1lc3BhY2VgXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuKiBbYGNsYXNzTmFtZWBdKCNoaWdobGlnaHQudGFncy5jbGFzc05hbWUpXG4qIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbiogW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuKiBbYG9wZXJhdG9yYF0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKVxuKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbiogW2BtZXRhYF0oI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4qIFtgcHVuY3R1YXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pXG4qIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuXG5JbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxuXG4qIFtgcmVnZXhwYF0oI2hpZ2hsaWdodC50YWdzLnJlZ2V4cCksXG4gIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuICBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYChzdHJpbmcpYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiAgYXJlIG1hcHBlZCB0byBgXCJ0b2stc3RyaW5nMlwiYFxuKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZTJcImBcbiogW2Bsb2NhbGBdKCNoaWdobGlnaHQudGFncy5sb2NhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4gIHRvIGBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiovXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRDb2RlLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/html/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/@lezer/html/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configureNesting: () => (/* binding */ configureNesting),\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst scriptText = 55,\n  StartCloseScriptTag = 1,\n  styleText = 56,\n  StartCloseStyleTag = 2,\n  textareaText = 57,\n  StartCloseTextareaTag = 3,\n  EndTag = 4,\n  SelfClosingEndTag = 5,\n  StartTag = 6,\n  StartScriptTag = 7,\n  StartStyleTag = 8,\n  StartTextareaTag = 9,\n  StartSelfClosingTag = 10,\n  StartCloseTag = 11,\n  NoMatchStartCloseTag = 12,\n  MismatchedStartCloseTag = 13,\n  missingCloseTag = 58,\n  IncompleteTag = 14,\n  IncompleteCloseTag = 15,\n  commentContent$1 = 59,\n  Element = 21,\n  TagName = 23,\n  Attribute = 24,\n  AttributeName = 25,\n  AttributeValue = 27,\n  UnquotedAttributeValue = 28,\n  ScriptText = 29,\n  StyleText = 32,\n  TextareaText = 35,\n  OpenTag = 37,\n  CloseTag = 38,\n  Dialect_noMatch = 0,\n  Dialect_selfClosing = 1;\n\n/* Hand-written tokenizers for HTML. */\n\nconst selfClosers = {\n  area: true, base: true, br: true, col: true, command: true,\n  embed: true, frame: true, hr: true, img: true, input: true,\n  keygen: true, link: true, meta: true, param: true, source: true,\n  track: true, wbr: true, menuitem: true\n};\n\nconst implicitlyClosed = {\n  dd: true, li: true, optgroup: true, option: true, p: true,\n  rp: true, rt: true, tbody: true, td: true, tfoot: true,\n  th: true, tr: true\n};\n\nconst closeOnOpen = {\n  dd: {dd: true, dt: true},\n  dt: {dd: true, dt: true},\n  li: {li: true},\n  option: {option: true, optgroup: true},\n  optgroup: {optgroup: true},\n  p: {\n    address: true, article: true, aside: true, blockquote: true, dir: true,\n    div: true, dl: true, fieldset: true, footer: true, form: true,\n    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,\n    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,\n    p: true, pre: true, section: true, table: true, ul: true\n  },\n  rp: {rp: true, rt: true},\n  rt: {rp: true, rt: true},\n  tbody: {tbody: true, tfoot: true},\n  td: {td: true, th: true},\n  tfoot: {tbody: true},\n  th: {td: true, th: true},\n  thead: {tbody: true, tfoot: true},\n  tr: {tr: true}\n};\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161\n}\n\nlet cachedName = null, cachedInput = null, cachedPos = 0;\nfunction tagNameAfter(input, offset) {\n  let pos = input.pos + offset;\n  if (cachedPos == pos && cachedInput == input) return cachedName\n  let next = input.peek(offset), name = \"\";\n  for (;;) {\n    if (!nameChar(next)) break\n    name += String.fromCharCode(next);\n    next = input.peek(++offset);\n  }\n  // Undefined to signal there's a <? or <!, null for just missing\n  cachedInput = input; cachedPos = pos;\n  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null\n}\n\nconst lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;\n\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n}\n\nconst startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];\n\nconst elementContext = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: null,\n  shift(context, term, stack, input) {\n    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  reduce(context, term) {\n    return term == Element && context ? context.parent : context\n  },\n  reuse(context, node, stack, input) {\n    let type = node.type.id;\n    return type == StartTag || type == OpenTag\n      ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  strict: false\n});\n\nconst tagStart = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next != lessThan) {\n    // End of file, close any open tags\n    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);\n    return\n  }\n  input.advance();\n  let close = input.next == slash;\n  if (close) input.advance();\n  let name = tagNameAfter(input, 0);\n  if (name === undefined) return\n  if (!name) return input.acceptToken(close ? IncompleteCloseTag : IncompleteTag)\n\n  let parent = stack.context ? stack.context.name : null;\n  if (close) {\n    if (name == parent) return input.acceptToken(StartCloseTag)\n    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)\n    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)\n    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return\n    input.acceptToken(MismatchedStartCloseTag);\n  } else {\n    if (name == \"script\") return input.acceptToken(StartScriptTag)\n    if (name == \"style\") return input.acceptToken(StartStyleTag)\n    if (name == \"textarea\") return input.acceptToken(StartTextareaTag)\n    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)\n    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);\n    else input.acceptToken(StartTag);\n  }\n}, {contextual: true});\n\nconst commentContent = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n  for (let dashes = 0, i = 0;; i++) {\n    if (input.next < 0) {\n      if (i) input.acceptToken(commentContent$1);\n      break\n    }\n    if (input.next == dash) {\n      dashes++;\n    } else if (input.next == greaterThan && dashes >= 2) {\n      if (i >= 3) input.acceptToken(commentContent$1, -2);\n      break\n    } else {\n      dashes = 0;\n    }\n    input.advance();\n  }\n});\n\nfunction inForeignElement(context) {\n  for (; context; context = context.parent)\n    if (context.name == \"svg\" || context.name == \"math\") return true\n  return false\n}\n\nconst endTag = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next == slash && input.peek(1) == greaterThan) {\n    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);\n    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);\n  } else if (input.next == greaterThan) {\n    input.acceptToken(EndTag, 1);\n  }\n});\n\nfunction contentTokenizer(tag, textToken, endToken) {\n  let lastState = 2 + tag.length;\n  return new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer(input => {\n    // state means:\n    // - 0 nothing matched\n    // - 1 '<' matched\n    // - 2 '</'\n    // - 3-(1+tag.length) part of the tag matched\n    // - lastState whole tag + possibly whitespace matched\n    for (let state = 0, matchedLen = 0, i = 0;; i++) {\n      if (input.next < 0) {\n        if (i) input.acceptToken(textToken);\n        break\n      }\n      if (state == 0 && input.next == lessThan ||\n          state == 1 && input.next == slash ||\n          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {\n        state++;\n        matchedLen++;\n      } else if (state == lastState && input.next == greaterThan) {\n        if (i > matchedLen)\n          input.acceptToken(textToken, -matchedLen);\n        else\n          input.acceptToken(endToken, -(matchedLen - 2));\n        break\n      } else if ((input.next == 10 /* '\\n' */ || input.next == 13 /* '\\r' */) && i) {\n        input.acceptToken(textToken, 1);\n        break\n      } else {\n        state = matchedLen = 0;\n      }\n      input.advance();\n    }\n  })\n}\n\nconst scriptTokens = contentTokenizer(\"script\", scriptText, StartCloseScriptTag);\n\nconst styleTokens = contentTokenizer(\"style\", styleText, StartCloseStyleTag);\n\nconst textareaTokens = contentTokenizer(\"textarea\", textareaText, StartCloseTextareaTag);\n\nconst htmlHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"Text RawText IncompleteTag IncompleteCloseTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"StartTag StartCloseTag SelfClosingEndTag EndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  TagName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"MismatchedCloseTag/TagName\": [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,  _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid],\n  AttributeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"AttributeValue UnquotedAttributeValue\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  Is: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  \"EntityReference CharacterReference\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,\n  Comment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  ProcessingInst: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,\n  DoctypeDecl: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.documentMeta\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[\",\n  stateData: \",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~\",\n  goto: \"%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp\",\n  nodeNames: \"âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl\",\n  maxTerm: 68,\n  context: elementContext,\n  nodeProps: [\n    [\"closedBy\", -10,1,2,3,7,8,9,10,11,12,13,\"EndTag\",6,\"EndTag SelfClosingEndTag\",-4,22,31,34,37,\"CloseTag\"],\n    [\"openedBy\", 4,\"StartTag StartCloseTag\",5,\"StartTag\",-4,30,33,36,38,\"OpenTag\"],\n    [\"group\", -10,14,15,18,19,20,21,40,41,42,43,\"Entity\",17,\"Entity TextContent\",-3,29,32,35,\"TextContent Entity\"],\n    [\"isolate\", -11,22,30,31,33,34,36,37,38,39,42,43,\"ltr\",-3,27,28,40,\"\"]\n  ],\n  propSources: [htmlHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X\",\n  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],\n  topRules: {\"Document\":[0,16]},\n  dialects: {noMatch: 0, selfClosing: 515},\n  tokenPrec: 517\n});\n\nfunction getAttrs(openTag, input) {\n  let attrs = Object.create(null);\n  for (let att of openTag.getChildren(Attribute)) {\n    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);\n    if (name) attrs[input.read(name.from, name.to)] =\n      !value ? \"\" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);\n  }\n  return attrs\n}\n\nfunction findTagName(openTag, input) {\n  let tagNameNode = openTag.getChild(TagName);\n  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : \" \"\n}\n\nfunction maybeNest(node, input, tags) {\n  let attrs;\n  for (let tag of tags) {\n    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent.firstChild, input))))\n      return {parser: tag.parser, bracketed: true}\n  }\n  return null\n}\n\n// tags?: {\n//   tag: string,\n//   attrs?: ({[attr: string]: string}) => boolean,\n//   parser: Parser\n// }[]\n// attributes?: {\n//   name: string,\n//   tagName?: string,\n//   parser: Parser\n// }[]\n \nfunction configureNesting(tags = [], attributes = []) {\n  let script = [], style = [], textarea = [], other = [];\n  for (let tag of tags) {\n    let array = tag.tag == \"script\" ? script : tag.tag == \"style\" ? style : tag.tag == \"textarea\" ? textarea : other;\n    array.push(tag);\n  }\n  let attrs = attributes.length ? Object.create(null) : null;\n  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);\n\n  return (0,_lezer_common__WEBPACK_IMPORTED_MODULE_2__.parseMixed)((node, input) => {\n    let id = node.type.id;\n    if (id == ScriptText) return maybeNest(node, input, script)\n    if (id == StyleText) return maybeNest(node, input, style)\n    if (id == TextareaText) return maybeNest(node, input, textarea)\n\n    if (id == Element && other.length) {\n      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs;\n      if (tagName) for (let tag of other) {\n        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(open, input))))) {\n          let close = n.lastChild;\n          let to = close.type.id == CloseTag ? close.from : n.to;\n          if (to > open.to)\n            return {parser: tag.parser, overlay: [{from: open.to, to}]}\n        }\n      }\n    }\n\n    if (attrs && id == Attribute) {\n      let n = node.node, nameNode;\n      if (nameNode = n.firstChild) {\n        let matches = attrs[input.read(nameNode.from, nameNode.to)];\n        if (matches) for (let attr of matches) {\n          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue\n          let value = n.lastChild;\n          if (value.type.id == AttributeValue) {\n            let from = value.from + 1;\n            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);\n            if (to > from) return {parser: attr.parser, overlay: [{from, to}], bracketed: true}\n          } else if (value.type.id == UnquotedAttributeValue) {\n            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}\n          }\n        }\n      }\n    }\n    return null\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2h0bWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RTtBQUNyQjtBQUNSOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sU0FBUztBQUNoQixXQUFXLDZCQUE2QjtBQUN4QyxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLFVBQVUseUJBQXlCO0FBQ25DLE9BQU8sbUJBQW1CO0FBQzFCLFVBQVUsWUFBWTtBQUN0QixPQUFPLG1CQUFtQjtBQUMxQixVQUFVLHlCQUF5QjtBQUNuQyxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixxREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQscUJBQXFCLHdEQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNB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QUcseUJBQXlCLDBDQUEwQyxNQUFNLEdBQUcsNEJBQTRCLEtBQUssR0FBRyxnQkFBZ0IsaURBQWlELEdBQUcsTUFBTSxHQUFHLHdEQUF3RCxNQUFNLEdBQUcsZ0NBQWdDLEtBQUssR0FBRyxnQkFBZ0IseURBQXlELElBQUksTUFBTSxHQUFHLElBQUksWUFBWSw0QkFBNEIsS0FBSyxHQUFHLGNBQWMsR0FBRyxnQ0FBZ0Msc0JBQXNCLEtBQUssR0FBRztBQUNsb007QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLDZCQUE2QjtBQUMxQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMseURBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0NBQWdDLFNBQVM7QUFDNUUsWUFBWTtBQUNaLG9CQUFvQixnQ0FBZ0MsK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktYXBwLWJ1aWxkZXItd2ViLy4vbm9kZV9tb2R1bGVzL0BsZXplci9odG1sL2Rpc3QvaW5kZXguanM/N2MwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgcGFyc2VNaXhlZCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNjcmlwdFRleHQgPSA1NSxcbiAgU3RhcnRDbG9zZVNjcmlwdFRhZyA9IDEsXG4gIHN0eWxlVGV4dCA9IDU2LFxuICBTdGFydENsb3NlU3R5bGVUYWcgPSAyLFxuICB0ZXh0YXJlYVRleHQgPSA1NyxcbiAgU3RhcnRDbG9zZVRleHRhcmVhVGFnID0gMyxcbiAgRW5kVGFnID0gNCxcbiAgU2VsZkNsb3NpbmdFbmRUYWcgPSA1LFxuICBTdGFydFRhZyA9IDYsXG4gIFN0YXJ0U2NyaXB0VGFnID0gNyxcbiAgU3RhcnRTdHlsZVRhZyA9IDgsXG4gIFN0YXJ0VGV4dGFyZWFUYWcgPSA5LFxuICBTdGFydFNlbGZDbG9zaW5nVGFnID0gMTAsXG4gIFN0YXJ0Q2xvc2VUYWcgPSAxMSxcbiAgTm9NYXRjaFN0YXJ0Q2xvc2VUYWcgPSAxMixcbiAgTWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcgPSAxMyxcbiAgbWlzc2luZ0Nsb3NlVGFnID0gNTgsXG4gIEluY29tcGxldGVUYWcgPSAxNCxcbiAgSW5jb21wbGV0ZUNsb3NlVGFnID0gMTUsXG4gIGNvbW1lbnRDb250ZW50JDEgPSA1OSxcbiAgRWxlbWVudCA9IDIxLFxuICBUYWdOYW1lID0gMjMsXG4gIEF0dHJpYnV0ZSA9IDI0LFxuICBBdHRyaWJ1dGVOYW1lID0gMjUsXG4gIEF0dHJpYnV0ZVZhbHVlID0gMjcsXG4gIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgPSAyOCxcbiAgU2NyaXB0VGV4dCA9IDI5LFxuICBTdHlsZVRleHQgPSAzMixcbiAgVGV4dGFyZWFUZXh0ID0gMzUsXG4gIE9wZW5UYWcgPSAzNyxcbiAgQ2xvc2VUYWcgPSAzOCxcbiAgRGlhbGVjdF9ub01hdGNoID0gMCxcbiAgRGlhbGVjdF9zZWxmQ2xvc2luZyA9IDE7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXJzIGZvciBIVE1MLiAqL1xuXG5jb25zdCBzZWxmQ2xvc2VycyA9IHtcbiAgYXJlYTogdHJ1ZSwgYmFzZTogdHJ1ZSwgYnI6IHRydWUsIGNvbDogdHJ1ZSwgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsIGZyYW1lOiB0cnVlLCBocjogdHJ1ZSwgaW1nOiB0cnVlLCBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLCBsaW5rOiB0cnVlLCBtZXRhOiB0cnVlLCBwYXJhbTogdHJ1ZSwgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSwgd2JyOiB0cnVlLCBtZW51aXRlbTogdHJ1ZVxufTtcblxuY29uc3QgaW1wbGljaXRseUNsb3NlZCA9IHtcbiAgZGQ6IHRydWUsIGxpOiB0cnVlLCBvcHRncm91cDogdHJ1ZSwgb3B0aW9uOiB0cnVlLCBwOiB0cnVlLFxuICBycDogdHJ1ZSwgcnQ6IHRydWUsIHRib2R5OiB0cnVlLCB0ZDogdHJ1ZSwgdGZvb3Q6IHRydWUsXG4gIHRoOiB0cnVlLCB0cjogdHJ1ZVxufTtcblxuY29uc3QgY2xvc2VPbk9wZW4gPSB7XG4gIGRkOiB7ZGQ6IHRydWUsIGR0OiB0cnVlfSxcbiAgZHQ6IHtkZDogdHJ1ZSwgZHQ6IHRydWV9LFxuICBsaToge2xpOiB0cnVlfSxcbiAgb3B0aW9uOiB7b3B0aW9uOiB0cnVlLCBvcHRncm91cDogdHJ1ZX0sXG4gIG9wdGdyb3VwOiB7b3B0Z3JvdXA6IHRydWV9LFxuICBwOiB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGRpcjogdHJ1ZSxcbiAgICBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLFxuICAgIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSwgaDY6IHRydWUsXG4gICAgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBtZW51OiB0cnVlLCBuYXY6IHRydWUsIG9sOiB0cnVlLFxuICAgIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHVsOiB0cnVlXG4gIH0sXG4gIHJwOiB7cnA6IHRydWUsIHJ0OiB0cnVlfSxcbiAgcnQ6IHtycDogdHJ1ZSwgcnQ6IHRydWV9LFxuICB0Ym9keToge3Rib2R5OiB0cnVlLCB0Zm9vdDogdHJ1ZX0sXG4gIHRkOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGZvb3Q6IHt0Ym9keTogdHJ1ZX0sXG4gIHRoOiB7dGQ6IHRydWUsIHRoOiB0cnVlfSxcbiAgdGhlYWQ6IHt0Ym9keTogdHJ1ZSwgdGZvb3Q6IHRydWV9LFxuICB0cjoge3RyOiB0cnVlfVxufTtcblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjFcbn1cblxubGV0IGNhY2hlZE5hbWUgPSBudWxsLCBjYWNoZWRJbnB1dCA9IG51bGwsIGNhY2hlZFBvcyA9IDA7XG5mdW5jdGlvbiB0YWdOYW1lQWZ0ZXIoaW5wdXQsIG9mZnNldCkge1xuICBsZXQgcG9zID0gaW5wdXQucG9zICsgb2Zmc2V0O1xuICBpZiAoY2FjaGVkUG9zID09IHBvcyAmJiBjYWNoZWRJbnB1dCA9PSBpbnB1dCkgcmV0dXJuIGNhY2hlZE5hbWVcbiAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZnNldCksIG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWtcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgbmV4dCA9IGlucHV0LnBlZWsoKytvZmZzZXQpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCB0byBzaWduYWwgdGhlcmUncyBhIDw/IG9yIDwhLCBudWxsIGZvciBqdXN0IG1pc3NpbmdcbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDsgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBuZXh0ID09IHF1ZXN0aW9uIHx8IG5leHQgPT0gYmFuZyA/IHVuZGVmaW5lZCA6IG51bGxcbn1cblxuY29uc3QgbGVzc1RoYW4gPSA2MCwgZ3JlYXRlclRoYW4gPSA2Miwgc2xhc2ggPSA0NywgcXVlc3Rpb24gPSA2MywgYmFuZyA9IDMzLCBkYXNoID0gNDU7XG5cbmZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KG5hbWUsIHBhcmVudCkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn1cblxuY29uc3Qgc3RhcnRUYWdUZXJtcyA9IFtTdGFydFRhZywgU3RhcnRTZWxmQ2xvc2luZ1RhZywgU3RhcnRTY3JpcHRUYWcsIFN0YXJ0U3R5bGVUYWcsIFN0YXJ0VGV4dGFyZWFUYWddO1xuXG5jb25zdCBlbGVtZW50Q29udGV4dCA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBudWxsLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICByZXR1cm4gc3RhcnRUYWdUZXJtcy5pbmRleE9mKHRlcm0pID4gLTEgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHRcbiAgfSxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBFbGVtZW50ICYmIGNvbnRleHQgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHRcbiAgfSxcbiAgcmV1c2UoY29udGV4dCwgbm9kZSwgc3RhY2ssIGlucHV0KSB7XG4gICAgbGV0IHR5cGUgPSBub2RlLnR5cGUuaWQ7XG4gICAgcmV0dXJuIHR5cGUgPT0gU3RhcnRUYWcgfHwgdHlwZSA9PSBPcGVuVGFnXG4gICAgICA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dFxuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcblxuY29uc3QgdGFnU3RhcnQgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsZXNzVGhhbikge1xuICAgIC8vIEVuZCBvZiBmaWxlLCBjbG9zZSBhbnkgb3BlbiB0YWdzXG4gICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIHN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZyk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBsZXQgY2xvc2UgPSBpbnB1dC5uZXh0ID09IHNsYXNoO1xuICBpZiAoY2xvc2UpIGlucHV0LmFkdmFuY2UoKTtcbiAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKCFuYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oY2xvc2UgPyBJbmNvbXBsZXRlQ2xvc2VUYWcgOiBJbmNvbXBsZXRlVGFnKVxuXG4gIGxldCBwYXJlbnQgPSBzdGFjay5jb250ZXh0ID8gc3RhY2suY29udGV4dC5uYW1lIDogbnVsbDtcbiAgaWYgKGNsb3NlKSB7XG4gICAgaWYgKG5hbWUgPT0gcGFyZW50KSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRDbG9zZVRhZylcbiAgICBpZiAocGFyZW50ICYmIGltcGxpY2l0bHlDbG9zZWRbcGFyZW50XSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKG1pc3NpbmdDbG9zZVRhZywgLTIpXG4gICAgaWYgKHN0YWNrLmRpYWxlY3RFbmFibGVkKERpYWxlY3Rfbm9NYXRjaCkpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihOb01hdGNoU3RhcnRDbG9zZVRhZylcbiAgICBmb3IgKGxldCBjeCA9IHN0YWNrLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnBhcmVudCkgaWYgKGN4Lm5hbWUgPT0gbmFtZSkgcmV0dXJuXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oTWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcpO1xuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lID09IFwic2NyaXB0XCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFNjcmlwdFRhZylcbiAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFN0eWxlVGFnKVxuICAgIGlmIChuYW1lID09IFwidGV4dGFyZWFcIikgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0VGV4dGFyZWFUYWcpXG4gICAgaWYgKHNlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oU3RhcnRTZWxmQ2xvc2luZ1RhZylcbiAgICBpZiAocGFyZW50ICYmIGNsb3NlT25PcGVuW3BhcmVudF0gJiYgY2xvc2VPbk9wZW5bcGFyZW50XVtuYW1lXSkgaW5wdXQuYWNjZXB0VG9rZW4obWlzc2luZ0Nsb3NlVGFnLCAtMSk7XG4gICAgZWxzZSBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRhZyk7XG4gIH1cbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IGNvbW1lbnRDb250ZW50ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgZm9yIChsZXQgZGFzaGVzID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaW5wdXQubmV4dCA8IDApIHtcbiAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbihjb21tZW50Q29udGVudCQxKTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnB1dC5uZXh0ID09IGRhc2gpIHtcbiAgICAgIGRhc2hlcysrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubmV4dCA9PSBncmVhdGVyVGhhbiAmJiBkYXNoZXMgPj0gMikge1xuICAgICAgaWYgKGkgPj0gMykgaW5wdXQuYWNjZXB0VG9rZW4oY29tbWVudENvbnRlbnQkMSwgLTIpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFzaGVzID0gMDtcbiAgICB9XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gaW5Gb3JlaWduRWxlbWVudChjb250ZXh0KSB7XG4gIGZvciAoOyBjb250ZXh0OyBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQpXG4gICAgaWYgKGNvbnRleHQubmFtZSA9PSBcInN2Z1wiIHx8IGNvbnRleHQubmFtZSA9PSBcIm1hdGhcIikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGVuZFRhZyA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGlmIChpbnB1dC5uZXh0ID09IHNsYXNoICYmIGlucHV0LnBlZWsoMSkgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICBsZXQgc2VsZkNsb3NpbmcgPSBzdGFjay5kaWFsZWN0RW5hYmxlZChEaWFsZWN0X3NlbGZDbG9zaW5nKSB8fCBpbkZvcmVpZ25FbGVtZW50KHN0YWNrLmNvbnRleHQpO1xuICAgIGlucHV0LmFjY2VwdFRva2VuKHNlbGZDbG9zaW5nID8gU2VsZkNsb3NpbmdFbmRUYWcgOiBFbmRUYWcsIDIpO1xuICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihFbmRUYWcsIDEpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29udGVudFRva2VuaXplcih0YWcsIHRleHRUb2tlbiwgZW5kVG9rZW4pIHtcbiAgbGV0IGxhc3RTdGF0ZSA9IDIgKyB0YWcubGVuZ3RoO1xuICByZXR1cm4gbmV3IEV4dGVybmFsVG9rZW5pemVyKGlucHV0ID0+IHtcbiAgICAvLyBzdGF0ZSBtZWFuczpcbiAgICAvLyAtIDAgbm90aGluZyBtYXRjaGVkXG4gICAgLy8gLSAxICc8JyBtYXRjaGVkXG4gICAgLy8gLSAyICc8LydcbiAgICAvLyAtIDMtKDErdGFnLmxlbmd0aCkgcGFydCBvZiB0aGUgdGFnIG1hdGNoZWRcbiAgICAvLyAtIGxhc3RTdGF0ZSB3aG9sZSB0YWcgKyBwb3NzaWJseSB3aGl0ZXNwYWNlIG1hdGNoZWRcbiAgICBmb3IgKGxldCBzdGF0ZSA9IDAsIG1hdGNoZWRMZW4gPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSB7XG4gICAgICAgIGlmIChpKSBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4pO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09IDAgJiYgaW5wdXQubmV4dCA9PSBsZXNzVGhhbiB8fFxuICAgICAgICAgIHN0YXRlID09IDEgJiYgaW5wdXQubmV4dCA9PSBzbGFzaCB8fFxuICAgICAgICAgIHN0YXRlID49IDIgJiYgc3RhdGUgPCBsYXN0U3RhdGUgJiYgaW5wdXQubmV4dCA9PSB0YWcuY2hhckNvZGVBdChzdGF0ZSAtIDIpKSB7XG4gICAgICAgIHN0YXRlKys7XG4gICAgICAgIG1hdGNoZWRMZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gbGFzdFN0YXRlICYmIGlucHV0Lm5leHQgPT0gZ3JlYXRlclRoYW4pIHtcbiAgICAgICAgaWYgKGkgPiBtYXRjaGVkTGVuKVxuICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRleHRUb2tlbiwgLW1hdGNoZWRMZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4oZW5kVG9rZW4sIC0obWF0Y2hlZExlbiAtIDIpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAoKGlucHV0Lm5leHQgPT0gMTAgLyogJ1xcbicgKi8gfHwgaW5wdXQubmV4dCA9PSAxMyAvKiAnXFxyJyAqLykgJiYgaSkge1xuICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXh0VG9rZW4sIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBtYXRjaGVkTGVuID0gMDtcbiAgICAgIH1cbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IHNjcmlwdFRva2VucyA9IGNvbnRlbnRUb2tlbml6ZXIoXCJzY3JpcHRcIiwgc2NyaXB0VGV4dCwgU3RhcnRDbG9zZVNjcmlwdFRhZyk7XG5cbmNvbnN0IHN0eWxlVG9rZW5zID0gY29udGVudFRva2VuaXplcihcInN0eWxlXCIsIHN0eWxlVGV4dCwgU3RhcnRDbG9zZVN0eWxlVGFnKTtcblxuY29uc3QgdGV4dGFyZWFUb2tlbnMgPSBjb250ZW50VG9rZW5pemVyKFwidGV4dGFyZWFcIiwgdGV4dGFyZWFUZXh0LCBTdGFydENsb3NlVGV4dGFyZWFUYWcpO1xuXG5jb25zdCBodG1sSGlnaGxpZ2h0aW5nID0gc3R5bGVUYWdzKHtcbiAgXCJUZXh0IFJhd1RleHQgSW5jb21wbGV0ZVRhZyBJbmNvbXBsZXRlQ2xvc2VUYWdcIjogdGFncy5jb250ZW50LFxuICBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU2VsZkNsb3NpbmdFbmRUYWcgRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ05hbWVcIjogW3RhZ3MudGFnTmFtZSwgIHRhZ3MuaW52YWxpZF0sXG4gIEF0dHJpYnV0ZU5hbWU6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlXCI6IHRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIElzOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgXCJFbnRpdHlSZWZlcmVuY2UgQ2hhcmFjdGVyUmVmZXJlbmNlXCI6IHRhZ3MuY2hhcmFjdGVyLFxuICBDb21tZW50OiB0YWdzLmJsb2NrQ29tbWVudCxcbiAgUHJvY2Vzc2luZ0luc3Q6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLFxuICBEb2N0eXBlRGVjbDogdGFncy5kb2N1bWVudE1ldGFcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIseE9WTyFyT09PIVpRI3RPJyNDck8hYFEjdE8nI0N7TyFlUSN0TycjRE9PIWpRI3RPJyNEUk8hb1EjdE8nI0RUTyF0T2FPJyNDcU8jUE9iTycjQ3FPI1tPZE8nI0NxTyRrTyFyTycjQ3FPT09gJyNDcScjQ3FPJHJPJGZPJyNEVU8kelEjdE8nI0RXTyVQUSN0TycjRFhPT09gJyNEbCcjRGxPT09gJyNEWicjRFpRVk8hck9PTyVVUSZyTyw1OV5PJWFRJnJPLDU5Z08lbFEmck8sNTlqTyV3USZyTyw1OW1PJlNRJnJPLDU5b09PT2EnI0RfJyNEX08mX09hTycjQ3lPJmpPYU8sNTldT09PYicjRGAnI0RgTyZyT2JPJyNDfE8mfU9iTyw1OV1PT09kJyNEYScjRGFPJ1ZPZE8nI0RQTydiT2RPLDU5XU9PT2AnI0RiJyNEYk8nak8hck8sNTldTydxUSN0TycjRFNPT09gLDU5XSw1OV1PT09wJyNEYycjRGNPJ3ZPJGZPLDU5cE9PT2AsNTlwLDU5cE8oT1EjfE8sNTlyTyhUUSN8Tyw1OXNPT09gLUU3WC1FN1hPKFlRJnJPJyNDdE9PUVcnI0RbJyNEW08oaFEmck8xRy54T09PYTFHLngxRy54T09PYDFHL1oxRy9aTyhzUSZyTzFHL1JPT09iMUcvUjFHL1JPKU9RJnJPMUcvVU9PT2QxRy9VMUcvVU8pWlEmck8xRy9YT09PYDFHL1gxRy9YTylmUSZyTzFHL1pPT09hLUU3XS1FN11PKXFRI3RPJyNDek9PT2AxRy53MUcud09PT2ItRTdeLUU3Xk8pdlEjdE8nI0N9T09PZC1FN18tRTdfTyl7USN0TycjRFFPT09gLUU3YC1FN2BPKlFRI3xPLDU5bk9PT3AtRTdhLUU3YU9PT2AxRy9bMUcvW09PT2AxRy9eMUcvXk9PT2AxRy9fMUcvX08qVlEsVU8sNTlgT09RVy1FN1ktRTdZT09PYTcrJGQ3KyRkT09PYDcrJHU3KyR1T09PYjcrJG03KyRtT09PZDcrJHA3KyRwT09PYDcrJHM3KyRzTypiUSN8Tyw1OWZPKmdRI3xPLDU5aU8qbFEjfE8sNTlsT09PYDFHL1kxRy9ZTypxTzdbTycjQ3dPK1NPTWhPJyNDd09PUVcxRy56MUcuek9PT2AxRy9RMUcvUU9PT2AxRy9UMUcvVE9PT2AxRy9XMUcvV09PT08nI0RdJyNEXU8rZU83W08sNTljT09RVyw1OWMsNTljT09PTycjRF4nI0ReTyt2T01oTyw1OWNPT09PLUU3Wi1FN1pPT1FXMUcufTFHLn1PT09PLUU3Wy1FN1tcIixcbiAgc3RhdGVEYXRhOiBcIixjfk8hX09Tfk9VU09WUE9XUU9YUk9ZVE9bXU9dW09eXk9fXk9hXk9iXk9jXk9kXk95Xk98X08hZVpPfk9nYU9+T2diT35PZ2NPfk9nZE9+T2dlT35PIVhmT1BtUCFbbVB+TyFZaU9RcFAhW3BQfk8hWmxPUnNQIVtzUH5PVVNPVlBPV1FPWFJPWVRPWnFPW11PXVtPXl5PX15PYV5PYl5PY15PZF5PeV5PIWVaT35PIVtyT35QI2dPIV1zTyFmdU9+T2d2T35PZ3dPfk9TfE9UfU9peU9+T1MhUE9UfU9peU9+T1MhUk9UfU9peU9+T1MhVE9UfU9peU9+T1N9T1R9T2l5T35PIVhmT1BtWCFbbVh+T1AhV08hWyFYT35PIVlpT1FwWCFbcFh+T1EhWk8hWyFYT35PIVpsT1JzWCFbc1h+T1IhXU8hWyFYT35PIVshWE9+UCNnT2chX09+TyFdc08hZiFhT35PUyFiT35PUyFjT35PaiFkT1NoWFRoWGloWH5PUyFmT1QhZ09peU9+T1MhaE9UIWdPaXlPfk9TIWlPVCFnT2l5T35PUyFqT1QhZ09peU9+T1MhZ09UIWdPaXlPfk9nIWtPfk9nIWxPfk9nIW1Pfk9TIW5Pfk9sIXFPIWEhb08hYyFwT35PUyFyT35PUyFzT35PUyF0T35PYiF1T2MhdU9kIXVPIWEhd08hYiF1T35PYiF4T2MheE9kIXhPIWMhd08hZCF4T35PYiF1T2MhdU9kIXVPIWEhe08hYiF1T35PYiF4T2MheE9kIXhPIWMhe08hZCF4T35PVH5jYmQhZXl8IWV+XCIsXG4gIGdvdG86IFwiJXEhYVBQUFBQUFBQUFBQUFBQUFBQUFBQUCFiIWhQIW5QUCF6UCF9I1EjVCNaI14jYSNnI2ojbSNzI3khYlAhYiFiUCRQJFYkbSRzJHklUCVWJV0lY1BQUFBQUFBQJWlYXk9YYHBYVU9YYHBlemFiY2RleyFPIVEhUyFVUiFxIWRSaFVSIVhoWFZPWGBwUmtWUiFYa1hXT1hgcFJuV1IhWG5YWE9YYHBRclhSIVhwWFlPWGBwUWBPUnhgUXthUSFPYlEhUWNRIVNkUSFVZVohZXshTyFRIVMhVVEhdiFvUiF6IXZRIXkhcFIhfCF5UWdVUiFWZ1FqVlIhWWpRbVdSIVttUXBYUiFecFF0WlIhYHRTX09gVG9YcFwiLFxuICBub2RlTmFtZXM6IFwi4pqgIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIEVuZFRhZyBTZWxmQ2xvc2luZ0VuZFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydFRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBJbmNvbXBsZXRlVGFnIEluY29tcGxldGVDbG9zZVRhZyBEb2N1bWVudCBUZXh0IEVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2UgSW52YWxpZEVudGl0eSBFbGVtZW50IE9wZW5UYWcgVGFnTmFtZSBBdHRyaWJ1dGUgQXR0cmlidXRlTmFtZSBJcyBBdHRyaWJ1dGVWYWx1ZSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlIFNjcmlwdFRleHQgQ2xvc2VUYWcgT3BlblRhZyBTdHlsZVRleHQgQ2xvc2VUYWcgT3BlblRhZyBUZXh0YXJlYVRleHQgQ2xvc2VUYWcgT3BlblRhZyBDbG9zZVRhZyBTZWxmQ2xvc2luZ1RhZyBDb21tZW50IFByb2Nlc3NpbmdJbnN0IE1pc21hdGNoZWRDbG9zZVRhZyBDbG9zZVRhZyBEb2N0eXBlRGVjbFwiLFxuICBtYXhUZXJtOiA2OCxcbiAgY29udGV4dDogZWxlbWVudENvbnRleHQsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImNsb3NlZEJ5XCIsIC0xMCwxLDIsMyw3LDgsOSwxMCwxMSwxMiwxMyxcIkVuZFRhZ1wiLDYsXCJFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWdcIiwtNCwyMiwzMSwzNCwzNyxcIkNsb3NlVGFnXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDQsXCJTdGFydFRhZyBTdGFydENsb3NlVGFnXCIsNSxcIlN0YXJ0VGFnXCIsLTQsMzAsMzMsMzYsMzgsXCJPcGVuVGFnXCJdLFxuICAgIFtcImdyb3VwXCIsIC0xMCwxNCwxNSwxOCwxOSwyMCwyMSw0MCw0MSw0Miw0MyxcIkVudGl0eVwiLDE3LFwiRW50aXR5IFRleHRDb250ZW50XCIsLTMsMjksMzIsMzUsXCJUZXh0Q29udGVudCBFbnRpdHlcIl0sXG4gICAgW1wiaXNvbGF0ZVwiLCAtMTEsMjIsMzAsMzEsMzMsMzQsMzYsMzcsMzgsMzksNDIsNDMsXCJsdHJcIiwtMywyNywyOCw0MCxcIlwiXVxuICBdLFxuICBwcm9wU291cmNlczogW2h0bWxIaWdobGlnaHRpbmddLFxuICBza2lwcGVkTm9kZXM6IFswXSxcbiAgcmVwZWF0Tm9kZUNvdW50OiA5LFxuICB0b2tlbkRhdGE6IFwiITxwIWFSIVlPWCRxWFksUVlaLFFaWyRxW10mWF1eLFFecCRxcHEsUXFyLV9yczNfc3YtX3Z3M313eEhZeH0tX30hT0h7IU8hUC1fIVAhUSRxIVEhWy1fIVshXU16IV0hXi1fIV4hXyEkUyFfIWAhO3ghYCFhJlghYSFjLV8hYyF9TXohfSNSLV8jUiNTTXojUyNUMWsjVCNvTXojbyNzLV8jcyRmJHEkZiVXLV8lVyVvTXolbyVwLV8lcCZhTXomYSZiLV8mYjFwTXoxcDRVLV80VTRkTXo0ZDRlLV80ZSRJU016JElTJElgLV8kSWAkSWJNeiRJYiRLaC1fJEtoJSN0TXolI3QmL3gtXyYveCZFdE16JkV0JkZWLV8mRlY7J1NNejsnUzs6aiEjfDs6ajs9YDNYPCVsPyZyLV8/JnI/QWhNej9BaD9CWSRxP0JZP01uTXo/TW5PJHEhWiR8Y2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxciRxcnMmfXN2JHF2dytQd3godHghXiRxIV4hXypWIV8hYSZYIWEjUyRxI1MjVCZYI1Q7J1MkcTsnUzs9YCt6PCVsTyRxIVImYlhhUCFiYCFkcE9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWHEnVVZhUCFkcE92Jn13eCdreCFeJn0hXiFfKFYhXzsnUyZ9OydTOz1gKG48JWxPJn1QJ3BUYVBPdidrdyFeJ2shXzsnUydrOydTOz1gKFA8JWxPJ2tQKFNQOz1gPCVsJ2twKFtTIWRwT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcChrUDs9YDwlbChWcShxUDs9YDwlbCZ9YSh7V2FQIWJgT3IodHJzJ2tzdih0dyFeKHQhXiFfKWUhXzsnUyh0OydTOz1gKlA8JWxPKHRgKWpUIWJgT3IpZXN2KWV3OydTKWU7J1M7PWApeTwlbE8pZWApfFA7PWA8JWwpZWEqU1A7PWA8JWwodCFRKl5WIWJgIWRwT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVEqdlA7PWA8JWwqViFSKnxQOz1gPCVsJlhXK1VZbFdPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQVyt3UDs9YDwlbCtQIVorfVA7PWA8JWwkcSFhLF1gYVAhYmAhZHAhX15PWCZYWFksUVlaLFFaXSZYXV4sUV5wJlhwcSxRcXImWHJzJn1zdiZYd3godHghXiZYIV4hXypWIV87J1MmWDsnUzs9YCp5PCVsTyZYIV8tbGppU2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHghUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYSZYIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxWy9lYmlTbFdPWCtQWlsrUF5wK1Bxci9ec3cvXnghUC9eIVAhUStQIVEhXi9eIWEjUy9eI1MjVDBtI1Qjcy9eI3MkZitQJGY7J1MvXjsnUzs9YDFlPCVsP0FoL14/QWg/QlkrUD9CWT9Nbi9eP01uTytQUzByWGlTcXIwbXN3MG14IVAwbSFRIV4wbSFhI3MwbSRmOydTMG07J1M7PWAxXzwlbD9BaDBtP0JZP01uMG1TMWJQOz1gPCVsMG1bMWhQOz1gPCVsL14hVjF2Y2lTYVAhYmAhZHBPcSZYcXIxa3JzJn1zdjFrdncwbXd4KHR4IVAxayFQIVEmWCFRIV4xayFeIV8qViFfIWEmWCFhI3MxayNzJGYmWCRmOydTMWs7J1M7PWAzUjwlbD9BaDFrP0FoP0JZJlg/Qlk/TW4xaz9Nbk8mWCFWM1VQOz1gPCVsMWshXzNbUDs9YDwlbC1fIVozaFYhYWhhUCFkcE92Jn13eCdreCFeJn0hXiFfKFYhXzsnUyZ9OydTOz1gKG48JWxPJn0hXzRXaWlTbFdkIVJPWDV1WFo3U1pbNXVbXjdTXnA1dXFyOHRyczdTc3Q+XXR3OHR3eDdTeCFQOHQhUCFRNXUhUSFdOHQhXSFeL14hXiFhN1MhYSNTOHQjUyNUO3sjVCNzOHQjcyRmNXUkZjsnUzh0OydTOz1gPlY8JWw/QWg4dD9BaD9CWTV1P0JZP01uOHQ/TW5PNXUhWjV6YmxXT1g1dVhaN1NaWzV1W143U15wNXVxcjV1cnM3U3N0K1B0dzV1d3g3U3ghXTV1IV0hXjd3IV4hYTdTIWEjUzV1I1MjVDdTI1Q7J1M1dTsnUzs9YDhuPCVsTzV1IVI3VlZPcDdTcXM3U3QhXTdTIV0hXjdsIV47J1M3UzsnUzs9YDdxPCVsTzdTIVI3cU9iIVIhUjd0UDs9YDwlbDdTIVo4T1lsV2IhUk9YK1BaWytQXnArUHFyK1BzdytQeCFeK1AhYSNTK1AjVDsnUytQOydTOz1gK3Q8JWxPK1AhWjhxUDs9YDwlbDV1IV84e2lpU2xXT1g1dVhaN1NaWzV1W143U15wNXVxcjh0cnM3U3N0L150dzh0d3g3U3ghUDh0IVAhUTV1IVEhXTh0IV0hXjpqIV4hYTdTIWEjUzh0I1MjVDt7I1Qjczh0I3MkZjV1JGY7J1M4dDsnUzs9YD5WPCVsP0FoOHQ/QWg/Qlk1dT9CWT9Nbjh0P01uTzV1IV86c2JpU2xXYiFST1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUCFWPFFjaVNPcDdTcXI7e3JzN1NzdDBtdHc7e3d4N1N4IVA7eyFQIVE3UyFRIV07eyFdIV49XSFeIWE3UyFhI3M7eyNzJGY3UyRmOydTO3s7J1M7PWA+UDwlbD9BaDt7P0FoP0JZN1M/Qlk/TW47ez9Nbk83UyFWPWRYaVNiIVJxcjBtc3cwbXghUDBtIVEhXjBtIWEjczBtJGY7J1MwbTsnUzs9YDFfPCVsP0FoMG0/Qlk/TW4wbSFWPlNQOz1gPCVsO3shXz5ZUDs9YDwlbDh0IV8+ZGhpU2xXT1hAT1haQVlaW0BPW15BWV5wQE9xckJ3cnNBWXN3Qnd3eEFZeCFQQnchUCFRQE8hUSFdQnchXSFeL14hXiFhQVkhYSNTQncjUyNURXsjVCNzQncjcyRmQE8kZjsnU0J3OydTOz1gSFM8JWw/QWhCdz9BaD9CWUBPP0JZP01uQnc/TW5PQE8hWkBUYWxXT1hAT1haQVlaW0BPW15BWV5wQE9xckBPcnNBWXN3QE93eEFZeCFdQE8hXSFeQXohXiFhQVkhYSNTQE8jUyNUQVkjVDsnU0BPOydTOz1gQnE8JWxPQE8hUkFdVU9wQVlxIV1BWSFdIV5BbyFeOydTQVk7J1M7PWBBdDwlbE9BWSFSQXRPYyFSIVJBd1A7PWA8JWxBWSFaQlJZbFdjIVJPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQIVpCdFA7PWA8JWxATyFfQ09oaVNsV09YQE9YWkFZWltAT1teQVlecEBPcXJCd3JzQVlzd0J3d3hBWXghUEJ3IVAhUUBPIVEhXUJ3IV0hXkRqIV4hYUFZIWEjU0J3I1MjVEV7I1Qjc0J3I3MkZkBPJGY7J1NCdzsnUzs9YEhTPCVsP0FoQnc/QWg/QllATz9CWT9NbkJ3P01uT0BPIV9Ec2JpU2xXYyFST1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUCFWRlFiaVNPcEFZcXJFe3JzQVlzd0V7d3hBWXghUEV7IVAhUUFZIVEhXUV7IV0hXkdZIV4hYUFZIWEjc0V7I3MkZkFZJGY7J1NFezsnUzs9YEd8PCVsP0FoRXs/QWg/QllBWT9CWT9NbkV7P01uT0FZIVZHYVhpU2MhUnFyMG1zdzBteCFQMG0hUSFeMG0hYSNzMG0kZjsnUzBtOydTOz1gMV88JWw/QWgwbT9CWT9NbjBtIVZIUFA7PWA8JWxFeyFfSFZQOz1gPCVsQnchWkhjVyFjeGFQIWJgT3IodHJzJ2tzdih0dyFeKHQhXiFfKWUhXzsnUyh0OydTOz1gKlA8JWxPKHQhYUlZbGlTYVBsVyFiYCFkcE9YJHFYWiZYWlskcVteJlhecCRxcHEmWHFyLV9ycyZ9c3YtX3Z3L153eCh0eH0tX30hT0tRIU8hUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYSZYIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxIWFLX2tpU2FQbFchYmAhZHBPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHghUC1fIVAhUSRxIVEhXi1fIV4hXypWIV8hYCZYIWAhYU1TIWEjUy1fI1MjVDFrI1Qjcy1fI3MkZiRxJGY7J1MtXzsnUzs9YDNYPCVsP0FoLV8/QWg/QlkkcT9CWT9Nbi1fP01uTyRxIVRNX1hhUCFiYCFkcCFmUU9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWCFhTlohWmlTZ1FhUGxXIWJgIWRwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4fS1ffSFPTXohTyFQTXohUCFRJHEhUSFbTXohWyFdTXohXSFeLV8hXiFfKlYhXyFhJlghYSFjLV8hYyF9TXohfSNSLV8jUiNTTXojUyNUMWsjVCNvTXojbyNzLV8jcyRmJHEkZiR9LV8kfSVPTXolTyVXLV8lVyVvTXolbyVwLV8lcCZhTXomYSZiLV8mYjFwTXoxcDRVTXo0VTRkTXo0ZDRlLV80ZSRJU016JElTJElgLV8kSWAkSWJNeiRJYiRKZS1fJEplJEpnTXokSmckS2gtXyRLaCUjdE16JSN0Ji94LV8mL3gmRXRNeiZFdCZGVi1fJkZWOydTTXo7J1M7OmohI3w7Omo7PWAzWDwlbD8mci1fPyZyP0FoTXo/QWg/QlkkcT9CWT9Nbk16P01uTyRxIWEhJFBQOz1gPCVsTXohUiEkWlkhYmAhZHBPcSpWcXIhJHlycyhWc3YqVnd4KWV4IWEqViFhIWIhNHQhYjsnUypWOydTOz1gKnM8JWxPKlYhUiElUV0hYmAhZHBPcipWcnMoVnN2KlZ3eClleH0qVn0hTyEleSFPIWYqViFmIWchJ10hZyNXKlYjVyNYITBgI1g7J1MqVjsnUzs9YCpzPCVsTypWIVIhJlFYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXh9KlZ9IU8hJm0hTzsnUypWOydTOz1gKnM8JWxPKlYhUiEmdlYhYmAhZHAhZVBPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiEnZFghYmAhZHBPcipWcnMoVnN2KlZ3eClleCFxKlYhcSFyIShQIXI7J1MqVjsnUzs9YCpzPCVsTypWIVIhKFdYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXghZSpWIWUhZiEocyFmOydTKlY7J1M7PWAqczwlbE8qViFSISh6WCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IXYqViF2IXchKWchdzsnUypWOydTOz1gKnM8JWxPKlYhUiEpblghYmAhZHBPcipWcnMoVnN2KlZ3eClleCF7KlYheyF8ISpaIXw7J1MqVjsnUzs9YCpzPCVsTypWIVIhKmJYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXghcipWIXIhcyEqfSFzOydTKlY7J1M7PWAqczwlbE8qViFSIStVWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4IWcqViFnIWghK3EhaDsnUypWOydTOz1gKnM8JWxPKlYhUiEreFkhYmAhZHBPciErcXJzISxoc3YhK3F2dyEtU3d4IS5beCFgIStxIWAhYSEvaiFhOydTIStxOydTOz1gITBZPCVsTyErcXEhLG1WIWRwT3YhLGh2eCEtU3ghYCEsaCFgIWEhLXEhYTsnUyEsaDsnUzs9YCEuVTwlbE8hLGhQIS1WVE8hYCEtUyFgIWEhLWYhYTsnUyEtUzsnUzs9YCEtazwlbE8hLVNQIS1rT3xQUCEtblA7PWA8JWwhLVNxIS14UyFkcHxQT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcSEuWFA7PWA8JWwhLGhhIS5hWCFiYE9yIS5bcnMhLVNzdiEuW3Z3IS1TdyFgIS5bIWAhYSEufCFhOydTIS5bOydTOz1gIS9kPCVsTyEuW2EhL1RUIWJgfFBPcillc3YpZXc7J1MpZTsnUzs9YCl5PCVsTyllYSEvZ1A7PWA8JWwhLlshUiEvc1YhYmAhZHB8UE9yKlZycyhWc3YqVnd4KWV4OydTKlY7J1M7PWAqczwlbE8qViFSITBdUDs9YDwlbCErcSFSITBnWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I2MqViNjI2QhMVMjZDsnUypWOydTOz1gKnM8JWxPKlYhUiExWlghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNWKlYjViNXITF2I1c7J1MqVjsnUzs9YCpzPCVsTypWIVIhMX1YIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjaCpWI2gjaSEyaiNpOydTKlY7J1M7PWAqczwlbE8qViFSITJxWCFiYCFkcE9yKlZycyhWc3YqVnd4KWV4I20qViNtI24hM14jbjsnUypWOydTOz1gKnM8JWxPKlYhUiEzZVghYmAhZHBPcipWcnMoVnN2KlZ3eClleCNkKlYjZCNlITRRI2U7J1MqVjsnUzs9YCpzPCVsTypWIVIhNFhYIWJgIWRwT3IqVnJzKFZzdipWd3gpZXgjWCpWI1gjWSErcSNZOydTKlY7J1M7PWAqczwlbE8qViFSITR7WSFiYCFkcE9yITR0cnMhNWtzdiE0dHZ3ITZWd3ghOF14IWEhNHQhYSFiITpdIWI7J1MhNHQ7J1M7PWAhO3I8JWxPITR0cSE1cFYhZHBPdiE1a3Z4ITZWeCFhITVrIWEhYiE3VyFiOydTITVrOydTOz1gIThWPCVsTyE1a1AhNllUTyFhITZWIWEhYiE2aSFiOydTITZWOydTOz1gITdRPCVsTyE2VlAhNmxUTyFgITZWIWAhYSE2eyFhOydTITZWOydTOz1gITdRPCVsTyE2VlAhN1FPeVBQITdUUDs9YDwlbCE2VnEhN11WIWRwT3YhNWt2eCE2VnghYCE1ayFgIWEhN3IhYTsnUyE1azsnUzs9YCE4VjwlbE8hNWtxITd5UyFkcHlQT3YoVng7J1MoVjsnUzs9YChoPCVsTyhWcSE4WVA7PWA8JWwhNWthIThiWCFiYE9yIThdcnMhNlZzdiE4XXZ3ITZWdyFhIThdIWEhYiE4fSFiOydTIThdOydTOz1gITpWPCVsTyE4XWEhOVNYIWJgT3IhOF1ycyE2VnN2IThddnchNlZ3IWAhOF0hYCFhITlvIWE7J1MhOF07J1M7PWAhOlY8JWxPIThdYSE5dlQhYmB5UE9yKWVzdilldzsnUyllOydTOz1gKXk8JWxPKWVhITpZUDs9YDwlbCE4XSFSITpkWSFiYCFkcE9yITR0cnMhNWtzdiE0dHZ3ITZWd3ghOF14IWAhNHQhYCFhITtTIWE7J1MhNHQ7J1M7PWAhO3I8JWxPITR0IVIhO11WIWJgIWRweVBPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiE7dVA7PWA8JWwhNHQhViE8VFhqU2FQIWJgIWRwT3ImWHJzJn1zdiZYd3godHghXiZYIV4hXypWIV87J1MmWDsnUzs9YCp5PCVsTyZYXCIsXG4gIHRva2VuaXplcnM6IFtzY3JpcHRUb2tlbnMsIHN0eWxlVG9rZW5zLCB0ZXh0YXJlYVRva2VucywgZW5kVGFnLCB0YWdTdGFydCwgY29tbWVudENvbnRlbnQsIDAsIDEsIDIsIDMsIDQsIDVdLFxuICB0b3BSdWxlczoge1wiRG9jdW1lbnRcIjpbMCwxNl19LFxuICBkaWFsZWN0czoge25vTWF0Y2g6IDAsIHNlbGZDbG9zaW5nOiA1MTV9LFxuICB0b2tlblByZWM6IDUxN1xufSk7XG5cbmZ1bmN0aW9uIGdldEF0dHJzKG9wZW5UYWcsIGlucHV0KSB7XG4gIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAobGV0IGF0dCBvZiBvcGVuVGFnLmdldENoaWxkcmVuKEF0dHJpYnV0ZSkpIHtcbiAgICBsZXQgbmFtZSA9IGF0dC5nZXRDaGlsZChBdHRyaWJ1dGVOYW1lKSwgdmFsdWUgPSBhdHQuZ2V0Q2hpbGQoQXR0cmlidXRlVmFsdWUpIHx8IGF0dC5nZXRDaGlsZChVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICBpZiAobmFtZSkgYXR0cnNbaW5wdXQucmVhZChuYW1lLmZyb20sIG5hbWUudG8pXSA9XG4gICAgICAhdmFsdWUgPyBcIlwiIDogdmFsdWUudHlwZS5pZCA9PSBBdHRyaWJ1dGVWYWx1ZSA/IGlucHV0LnJlYWQodmFsdWUuZnJvbSArIDEsIHZhbHVlLnRvIC0gMSkgOiBpbnB1dC5yZWFkKHZhbHVlLmZyb20sIHZhbHVlLnRvKTtcbiAgfVxuICByZXR1cm4gYXR0cnNcbn1cblxuZnVuY3Rpb24gZmluZFRhZ05hbWUob3BlblRhZywgaW5wdXQpIHtcbiAgbGV0IHRhZ05hbWVOb2RlID0gb3BlblRhZy5nZXRDaGlsZChUYWdOYW1lKTtcbiAgcmV0dXJuIHRhZ05hbWVOb2RlID8gaW5wdXQucmVhZCh0YWdOYW1lTm9kZS5mcm9tLCB0YWdOYW1lTm9kZS50bykgOiBcIiBcIlxufVxuXG5mdW5jdGlvbiBtYXliZU5lc3Qobm9kZSwgaW5wdXQsIHRhZ3MpIHtcbiAgbGV0IGF0dHJzO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGlmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhub2RlLm5vZGUucGFyZW50LmZpcnN0Q2hpbGQsIGlucHV0KSkpKVxuICAgICAgcmV0dXJuIHtwYXJzZXI6IHRhZy5wYXJzZXIsIGJyYWNrZXRlZDogdHJ1ZX1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyB0YWdzPzoge1xuLy8gICB0YWc6IHN0cmluZyxcbi8vICAgYXR0cnM/OiAoe1thdHRyOiBzdHJpbmddOiBzdHJpbmd9KSA9PiBib29sZWFuLFxuLy8gICBwYXJzZXI6IFBhcnNlclxuLy8gfVtdXG4vLyBhdHRyaWJ1dGVzPzoge1xuLy8gICBuYW1lOiBzdHJpbmcsXG4vLyAgIHRhZ05hbWU/OiBzdHJpbmcsXG4vLyAgIHBhcnNlcjogUGFyc2VyXG4vLyB9W11cbiBcbmZ1bmN0aW9uIGNvbmZpZ3VyZU5lc3RpbmcodGFncyA9IFtdLCBhdHRyaWJ1dGVzID0gW10pIHtcbiAgbGV0IHNjcmlwdCA9IFtdLCBzdHlsZSA9IFtdLCB0ZXh0YXJlYSA9IFtdLCBvdGhlciA9IFtdO1xuICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgIGxldCBhcnJheSA9IHRhZy50YWcgPT0gXCJzY3JpcHRcIiA/IHNjcmlwdCA6IHRhZy50YWcgPT0gXCJzdHlsZVwiID8gc3R5bGUgOiB0YWcudGFnID09IFwidGV4dGFyZWFcIiA/IHRleHRhcmVhIDogb3RoZXI7XG4gICAgYXJyYXkucHVzaCh0YWcpO1xuICB9XG4gIGxldCBhdHRycyA9IGF0dHJpYnV0ZXMubGVuZ3RoID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG51bGw7XG4gIGZvciAobGV0IGF0dHIgb2YgYXR0cmlidXRlcykgKGF0dHJzW2F0dHIubmFtZV0gfHwgKGF0dHJzW2F0dHIubmFtZV0gPSBbXSkpLnB1c2goYXR0cik7XG5cbiAgcmV0dXJuIHBhcnNlTWl4ZWQoKG5vZGUsIGlucHV0KSA9PiB7XG4gICAgbGV0IGlkID0gbm9kZS50eXBlLmlkO1xuICAgIGlmIChpZCA9PSBTY3JpcHRUZXh0KSByZXR1cm4gbWF5YmVOZXN0KG5vZGUsIGlucHV0LCBzY3JpcHQpXG4gICAgaWYgKGlkID09IFN0eWxlVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgc3R5bGUpXG4gICAgaWYgKGlkID09IFRleHRhcmVhVGV4dCkgcmV0dXJuIG1heWJlTmVzdChub2RlLCBpbnB1dCwgdGV4dGFyZWEpXG5cbiAgICBpZiAoaWQgPT0gRWxlbWVudCAmJiBvdGhlci5sZW5ndGgpIHtcbiAgICAgIGxldCBuID0gbm9kZS5ub2RlLCBvcGVuID0gbi5maXJzdENoaWxkLCB0YWdOYW1lID0gb3BlbiAmJiBmaW5kVGFnTmFtZShvcGVuLCBpbnB1dCksIGF0dHJzO1xuICAgICAgaWYgKHRhZ05hbWUpIGZvciAobGV0IHRhZyBvZiBvdGhlcikge1xuICAgICAgICBpZiAodGFnLnRhZyA9PSB0YWdOYW1lICYmICghdGFnLmF0dHJzIHx8IHRhZy5hdHRycyhhdHRycyB8fCAoYXR0cnMgPSBnZXRBdHRycyhvcGVuLCBpbnB1dCkpKSkpIHtcbiAgICAgICAgICBsZXQgY2xvc2UgPSBuLmxhc3RDaGlsZDtcbiAgICAgICAgICBsZXQgdG8gPSBjbG9zZS50eXBlLmlkID09IENsb3NlVGFnID8gY2xvc2UuZnJvbSA6IG4udG87XG4gICAgICAgICAgaWYgKHRvID4gb3Blbi50bylcbiAgICAgICAgICAgIHJldHVybiB7cGFyc2VyOiB0YWcucGFyc2VyLCBvdmVybGF5OiBbe2Zyb206IG9wZW4udG8sIHRvfV19XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cnMgJiYgaWQgPT0gQXR0cmlidXRlKSB7XG4gICAgICBsZXQgbiA9IG5vZGUubm9kZSwgbmFtZU5vZGU7XG4gICAgICBpZiAobmFtZU5vZGUgPSBuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBhdHRyc1tpbnB1dC5yZWFkKG5hbWVOb2RlLmZyb20sIG5hbWVOb2RlLnRvKV07XG4gICAgICAgIGlmIChtYXRjaGVzKSBmb3IgKGxldCBhdHRyIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICBpZiAoYXR0ci50YWdOYW1lICYmIGF0dHIudGFnTmFtZSAhPSBmaW5kVGFnTmFtZShuLnBhcmVudCwgaW5wdXQpKSBjb250aW51ZVxuICAgICAgICAgIGxldCB2YWx1ZSA9IG4ubGFzdENoaWxkO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlLmlkID09IEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlLmZyb20gKyAxO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB2YWx1ZS5sYXN0Q2hpbGQsIHRvID0gdmFsdWUudG8gLSAobGFzdCAmJiBsYXN0LmlzRXJyb3IgPyAwIDogMSk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbSwgdG99XSwgYnJhY2tldGVkOiB0cnVlfVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZS5pZCA9PSBVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BhcnNlcjogYXR0ci5wYXJzZXIsIG92ZXJsYXk6IFt7ZnJvbTogdmFsdWUuZnJvbSwgdG86IHZhbHVlLnRvfV19XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0pXG59XG5cbmV4cG9ydCB7IGNvbmZpZ3VyZU5lc3RpbmcsIHBhcnNlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/html/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 316,\n  noSemiType = 317,\n  incdec = 1,\n  incdecPrefix = 2,\n  questionDot = 3,\n  JSXStartTag = 4,\n  insertSemi = 318,\n  spaces = 320,\n  newline = 321,\n  LineComment = 5,\n  BlockComment = 6,\n  Dialect_jsx = 0;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44,\n      question = 63, dot = 46, bracketL = 91;\n\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == braceR || next == -1 || stack.context)\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context)\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst noSemicolonType = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);\n}, {contextual: true});\n\nconst operatorToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  } else if (next == question && input.peek(1) == dot) {\n    input.advance(); input.advance();\n    if (input.next < 48 || input.next > 57) // No digit after\n      input.acceptToken(questionDot);\n  }\n}, {contextual: true});\n\nfunction identifierChar(ch, start) {\n  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||\n    !start && ch >= 48 && ch <= 57\n}\n\nconst jsx = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack) => {\n  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return\n  input.advance();\n  if (input.next == slash) return\n  // Scan for an identifier followed by a comma or 'extends', don't\n  // treat this as a start tag if present.\n  let back = 0;\n  while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n  if (identifierChar(input.next, true)) {\n    input.advance();\n    back++;\n    while (identifierChar(input.next, false)) { input.advance(); back++; }\n    while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n    if (input.next == comma) return\n    for (let i = 0;; i++) {\n      if (i == 7) {\n        if (!identifierChar(input.next, true)) return\n        break\n      }\n      if (input.next != \"extends\".charCodeAt(i)) break\n      input.advance();\n      back++;\n    }\n  }\n  input.acceptToken(JSXStartTag, -back);\n});\n\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n  \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case defer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof as satisfies\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n  \"let var const using function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n  \"with debugger new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n  super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n  BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n  this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n  null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n  Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n  PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n  PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n  \"NewExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n  UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n  \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n  BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n  Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n  String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n  Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n  ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n  LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n  BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n  CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n  RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n  Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n  Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n  \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n  \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n  \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n  \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n  \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n  \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n  \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n  \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n\n  TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n  TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n  \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n  \"is keyof unique infer asserts\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n\n  JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n  JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:20, as:25, from:33, default:36, async:41, function:42, in:52, out:55, const:56, extends:60, this:64, true:72, false:72, null:84, void:88, typeof:92, super:108, new:142, delete:154, yield:163, await:167, class:172, public:235, private:235, protected:235, readonly:237, instanceof:256, satisfies:259, import:292, keyof:349, unique:353, infer:359, asserts:395, is:397, abstract:417, implements:419, type:421, let:424, var:426, using:429, interface:435, enum:439, namespace:445, module:447, declare:451, global:455, defer:471, for:476, of:485, while:488, with:492, do:496, if:500, else:502, switch:506, case:512, try:518, catch:522, finally:526, return:530, throw:534, break:538, continue:542, debugger:546};\nconst spec_word = {__proto__:null,async:129, get:131, set:133, declare:195, public:197, private:197, protected:197, static:199, abstract:201, override:203, readonly:209, accessor:211, new:401};\nconst spec_LessThan = {__proto__:null,\"<\":193};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 14,\n  states: \"$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]\",\n  stateData: \"()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~\",\n  goto: \"$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_\",\n  nodeNames: \"âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 380,\n  context: trackNewline,\n  nodeProps: [\n    [\"isolate\", -8,5,6,14,37,39,51,53,55,\"\"],\n    [\"group\", -26,9,17,19,68,207,211,215,216,218,221,224,234,237,243,245,247,249,252,258,264,266,268,270,272,274,275,\"Statement\",-34,13,14,32,35,36,42,51,54,55,57,62,70,72,76,80,82,84,85,110,111,120,121,136,139,141,142,143,144,145,147,148,167,169,171,\"Expression\",-23,31,33,37,41,43,45,173,175,177,178,180,181,182,184,185,186,188,189,190,201,203,205,206,\"Type\",-3,88,103,109,\"ClassItem\"],\n    [\"openedBy\", 23,\"<\",38,\"InterpolationStart\",56,\"[\",60,\"{\",73,\"(\",160,\"JSXStartCloseTag\"],\n    [\"closedBy\", -2,24,168,\">\",40,\"InterpolationEnd\",50,\"]\",61,\"}\",74,\")\",165,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,5,6,278],\n  repeatNodeCount: 37,\n  tokenData: \"$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~\", 141, 340), new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~\", 25, 323)],\n  topRules: {\"Script\":[0,7],\"SingleExpression\":[1,276],\"SingleClassItem\":[2,277]},\n  dialects: {jsx: 0, ts: 15175},\n  dynamicPrecedences: {\"80\":1,\"82\":1,\"94\":1,\"169\":1,\"199\":1},\n  specialized: [{term: 327, get: (value) => spec_identifier[value] || -1},{term: 343, get: (value) => spec_word[value] || -1},{term: 95, get: (value) => spec_LessThan[value] || -1}],\n  tokenPrec: 15201\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixxREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDRCQUE0Qix3REFBaUI7QUFDN0MsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBLENBQUMsR0FBRyxpQ0FBaUM7O0FBRXJDLHdCQUF3Qix3REFBaUI7QUFDekMsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUJBQWlCOztBQUVyQiw0QkFBNEIsd0RBQWlCO0FBQzdDO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckIsMEJBQTBCLHdEQUFpQjtBQUMzQyxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGlCQUFpQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHdEQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakUsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0JBQW9CLDJEQUFTO0FBQzdCLDBCQUEwQixrREFBSTtBQUM5QixrR0FBa0csa0RBQUk7QUFDdEcsa0VBQWtFLGtEQUFJO0FBQ3RF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QiwwQkFBMEIsb0RBQW9ELEtBQUssR0FBRyxnQkFBZ0IsaUNBQWlDLDhDQUE4QyxLQUFLLEdBQUcsaURBQWlELDhDQUE4QyxLQUFLLEdBQUcsOEVBQThFLE1BQU0sR0FBRyx1Q0FBdUMsS0FBSyxHQUFHLHlGQUF5RixLQUFLLEdBQUcseUVBQXlFLEtBQUssR0FBRyx5RUFBeUUsS0FBSyxHQUFHLHlFQUF5RSxLQUFLLEdBQUcsOEVBQThFLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLGlEQUFpRCxvREFBb0QsS0FBSyxHQUFHLFlBQVkscUNBQXFDLDhDQUE4QyxLQUFLLEdBQUcsMERBQTBELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsaURBQWlELG1CQUFtQixHQUFHLHdDQUF3QyxLQUFLLG1EQUFtRCxNQUFNLEdBQUcsbUJBQW1CLGdCQUFnQixjQUFjLHlCQUF5QixnQkFBZ0IsS0FBSyxHQUFHLGlEQUFpRCwyREFBMkQsS0FBSyxHQUFHLG9EQUFvRCw4Q0FBOEMsS0FBSyxHQUFHLCtDQUErQyw4Q0FBOEMsS0FBSyxHQUFHLCtFQUErRSxrQkFBa0IsR0FBRyxzQ0FBc0MsSUFBSSw0SUFBNEksS0FBSyxHQUFHLCtDQUErQyxpQ0FBaUMsa0JBQWtCLEdBQUcsc0NBQXNDLElBQUksaURBQWlELEtBQUssR0FBRztBQUN4aGYsa0lBQWtJLHNEQUFlLCtEQUErRCxLQUFLLEdBQUcsNkVBQTZFLE1BQU0sTUFBTSw2RUFBNkUsaUNBQWlDLHNEQUFlLFdBQVc7QUFDemIsYUFBYSxvRUFBb0U7QUFDakYsYUFBYSxrQkFBa0I7QUFDL0IsdUJBQXVCLHFDQUFxQztBQUM1RCxpQkFBaUIsd0RBQXdELEVBQUUsa0RBQWtELEVBQUUscURBQXFEO0FBQ3BMO0FBQ0EsQ0FBQzs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1hcHAtYnVpbGRlci13ZWIvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcz84NjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBub1NlbWkgPSAzMTYsXG4gIG5vU2VtaVR5cGUgPSAzMTcsXG4gIGluY2RlYyA9IDEsXG4gIGluY2RlY1ByZWZpeCA9IDIsXG4gIHF1ZXN0aW9uRG90ID0gMyxcbiAgSlNYU3RhcnRUYWcgPSA0LFxuICBpbnNlcnRTZW1pID0gMzE4LFxuICBzcGFjZXMgPSAzMjAsXG4gIG5ld2xpbmUgPSAzMjEsXG4gIExpbmVDb21tZW50ID0gNSxcbiAgQmxvY2tDb21tZW50ID0gNixcbiAgRGlhbGVjdF9qc3ggPSAwO1xuXG4vKiBIYW5kLXdyaXR0ZW4gdG9rZW5pemVycyBmb3IgSmF2YVNjcmlwdCB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IGxlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LCA4MTk4LCA4MTk5LCA4MjAwLFxuICAgICAgICAgICAgICAgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuXG5jb25zdCBicmFjZVIgPSAxMjUsIHNlbWljb2xvbiA9IDU5LCBzbGFzaCA9IDQ3LCBzdGFyID0gNDIsIHBsdXMgPSA0MywgbWludXMgPSA0NSwgbHQgPSA2MCwgY29tbWEgPSA0NCxcbiAgICAgIHF1ZXN0aW9uID0gNjMsIGRvdCA9IDQ2LCBicmFja2V0TCA9IDkxO1xuXG5jb25zdCB0cmFja05ld2xpbmUgPSBuZXcgQ29udGV4dFRyYWNrZXIoe1xuICBzdGFydDogZmFsc2UsXG4gIHNoaWZ0KGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBMaW5lQ29tbWVudCB8fCB0ZXJtID09IEJsb2NrQ29tbWVudCB8fCB0ZXJtID09IHNwYWNlcyA/IGNvbnRleHQgOiB0ZXJtID09IG5ld2xpbmVcbiAgfSxcbiAgc3RyaWN0OiBmYWxzZVxufSk7XG5cbmNvbnN0IGluc2VydFNlbWljb2xvbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKG5leHQgPT0gYnJhY2VSIHx8IG5leHQgPT0gLTEgfHwgc3RhY2suY29udGV4dClcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihpbnNlcnRTZW1pKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlLCBmYWxsYmFjazogdHJ1ZX0pO1xuXG5jb25zdCBub1NlbWljb2xvbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dCwgYWZ0ZXI7XG4gIGlmIChzcGFjZS5pbmRleE9mKG5leHQpID4gLTEpIHJldHVyblxuICBpZiAobmV4dCA9PSBzbGFzaCAmJiAoKGFmdGVyID0gaW5wdXQucGVlaygxKSkgPT0gc2xhc2ggfHwgYWZ0ZXIgPT0gc3RhcikpIHJldHVyblxuICBpZiAobmV4dCAhPSBicmFjZVIgJiYgbmV4dCAhPSBzZW1pY29sb24gJiYgbmV4dCAhPSAtMSAmJiAhc3RhY2suY29udGV4dClcbiAgICBpbnB1dC5hY2NlcHRUb2tlbihub1NlbWkpO1xufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3Qgbm9TZW1pY29sb25UeXBlID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgPT0gYnJhY2tldEwgJiYgIXN0YWNrLmNvbnRleHQpIGlucHV0LmFjY2VwdFRva2VuKG5vU2VtaVR5cGUpO1xufSwge2NvbnRleHR1YWw6IHRydWV9KTtcblxuY29uc3Qgb3BlcmF0b3JUb2tlbiA9IG5ldyBFeHRlcm5hbFRva2VuaXplcigoaW5wdXQsIHN0YWNrKSA9PiB7XG4gIGxldCB7bmV4dH0gPSBpbnB1dDtcbiAgaWYgKG5leHQgPT0gcGx1cyB8fCBuZXh0ID09IG1pbnVzKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGlmIChuZXh0ID09IGlucHV0Lm5leHQpIHtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGxldCBtYXlQb3N0Zml4ID0gIXN0YWNrLmNvbnRleHQgJiYgc3RhY2suY2FuU2hpZnQoaW5jZGVjKTtcbiAgICAgIGlucHV0LmFjY2VwdFRva2VuKG1heVBvc3RmaXggPyBpbmNkZWMgOiBpbmNkZWNQcmVmaXgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0ID09IHF1ZXN0aW9uICYmIGlucHV0LnBlZWsoMSkgPT0gZG90KSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpOyBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKGlucHV0Lm5leHQgPCA0OCB8fCBpbnB1dC5uZXh0ID4gNTcpIC8vIE5vIGRpZ2l0IGFmdGVyXG4gICAgICBpbnB1dC5hY2NlcHRUb2tlbihxdWVzdGlvbkRvdCk7XG4gIH1cbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmZ1bmN0aW9uIGlkZW50aWZpZXJDaGFyKGNoLCBzdGFydCkge1xuICByZXR1cm4gY2ggPj0gNjUgJiYgY2ggPD0gOTAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTIyIHx8IGNoID09IDk1IHx8IGNoID49IDE5MiB8fFxuICAgICFzdGFydCAmJiBjaCA+PSA0OCAmJiBjaCA8PSA1N1xufVxuXG5jb25zdCBqc3ggPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSBsdCB8fCAhc3RhY2suZGlhbGVjdEVuYWJsZWQoRGlhbGVjdF9qc3gpKSByZXR1cm5cbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBpZiAoaW5wdXQubmV4dCA9PSBzbGFzaCkgcmV0dXJuXG4gIC8vIFNjYW4gZm9yIGFuIGlkZW50aWZpZXIgZm9sbG93ZWQgYnkgYSBjb21tYSBvciAnZXh0ZW5kcycsIGRvbid0XG4gIC8vIHRyZWF0IHRoaXMgYXMgYSBzdGFydCB0YWcgaWYgcHJlc2VudC5cbiAgbGV0IGJhY2sgPSAwO1xuICB3aGlsZSAoc3BhY2UuaW5kZXhPZihpbnB1dC5uZXh0KSA+IC0xKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gIGlmIChpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCB0cnVlKSkge1xuICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICBiYWNrKys7XG4gICAgd2hpbGUgKGlkZW50aWZpZXJDaGFyKGlucHV0Lm5leHQsIGZhbHNlKSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICAgIHdoaWxlIChzcGFjZS5pbmRleE9mKGlucHV0Lm5leHQpID4gLTEpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgICBpZiAoaW5wdXQubmV4dCA9PSBjb21tYSkgcmV0dXJuXG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgIGlmIChpID09IDcpIHtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCB0cnVlKSkgcmV0dXJuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQubmV4dCAhPSBcImV4dGVuZHNcIi5jaGFyQ29kZUF0KGkpKSBicmVha1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgYmFjaysrO1xuICAgIH1cbiAgfVxuICBpbnB1dC5hY2NlcHRUb2tlbihKU1hTdGFydFRhZywgLWJhY2spO1xufSk7XG5cbmNvbnN0IGpzSGlnaGxpZ2h0ID0gc3R5bGVUYWdzKHtcbiAgXCJnZXQgc2V0IGFzeW5jIHN0YXRpY1wiOiB0YWdzLm1vZGlmaWVyLFxuICBcImZvciB3aGlsZSBkbyBpZiBlbHNlIHN3aXRjaCB0cnkgY2F0Y2ggZmluYWxseSByZXR1cm4gdGhyb3cgYnJlYWsgY29udGludWUgZGVmYXVsdCBjYXNlIGRlZmVyXCI6IHRhZ3MuY29udHJvbEtleXdvcmQsXG4gIFwiaW4gb2YgYXdhaXQgeWllbGQgdm9pZCB0eXBlb2YgZGVsZXRlIGluc3RhbmNlb2YgYXMgc2F0aXNmaWVzXCI6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcImxldCB2YXIgY29uc3QgdXNpbmcgZnVuY3Rpb24gY2xhc3MgZXh0ZW5kc1wiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImltcG9ydCBleHBvcnQgZnJvbVwiOiB0YWdzLm1vZHVsZUtleXdvcmQsXG4gIFwid2l0aCBkZWJ1Z2dlciBuZXdcIjogdGFncy5rZXl3b3JkLFxuICBUZW1wbGF0ZVN0cmluZzogdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKSxcbiAgc3VwZXI6IHRhZ3MuYXRvbSxcbiAgQm9vbGVhbkxpdGVyYWw6IHRhZ3MuYm9vbCxcbiAgdGhpczogdGFncy5zZWxmLFxuICBudWxsOiB0YWdzLm51bGwsXG4gIFN0YXI6IHRhZ3MubW9kaWZpZXIsXG4gIFZhcmlhYmxlTmFtZTogdGFncy52YXJpYWJsZU5hbWUsXG4gIFwiQ2FsbEV4cHJlc3Npb24vVmFyaWFibGVOYW1lIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgTGFiZWw6IHRhZ3MubGFiZWxOYW1lLFxuICBQcm9wZXJ0eU5hbWU6IHRhZ3MucHJvcGVydHlOYW1lLFxuICBQcml2YXRlUHJvcGVydHlOYW1lOiB0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkNhbGxFeHByZXNzaW9uL01lbWJlckV4cHJlc3Npb24vUHJvcGVydHlOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSksXG4gIFwiQ2xhc3NEZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5kZWZpbml0aW9uKHRhZ3MuY2xhc3NOYW1lKSxcbiAgXCJOZXdFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZVwiOiB0YWdzLmNsYXNzTmFtZSxcbiAgUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5zcGVjaWFsKHRhZ3MucHJvcGVydHlOYW1lKSksXG4gIFVwZGF0ZU9wOiB0YWdzLnVwZGF0ZU9wZXJhdG9yLFxuICBcIkxpbmVDb21tZW50IEhhc2hiYW5nXCI6IHRhZ3MubGluZUNvbW1lbnQsXG4gIEJsb2NrQ29tbWVudDogdGFncy5ibG9ja0NvbW1lbnQsXG4gIE51bWJlcjogdGFncy5udW1iZXIsXG4gIFN0cmluZzogdGFncy5zdHJpbmcsXG4gIEVzY2FwZTogdGFncy5lc2NhcGUsXG4gIEFyaXRoT3A6IHRhZ3MuYXJpdGhtZXRpY09wZXJhdG9yLFxuICBMb2dpY09wOiB0YWdzLmxvZ2ljT3BlcmF0b3IsXG4gIEJpdE9wOiB0YWdzLmJpdHdpc2VPcGVyYXRvcixcbiAgQ29tcGFyZU9wOiB0YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgUmVnRXhwOiB0YWdzLnJlZ2V4cCxcbiAgRXF1YWxzOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgQXJyb3c6IHRhZ3MuZnVuY3Rpb24odGFncy5wdW5jdHVhdGlvbiksXG4gIFwiOiBTcHJlYWRcIjogdGFncy5wdW5jdHVhdGlvbixcbiAgXCIoIClcIjogdGFncy5wYXJlbixcbiAgXCJbIF1cIjogdGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiB0YWdzLmJyYWNlLFxuICBcIkludGVycG9sYXRpb25TdGFydCBJbnRlcnBvbGF0aW9uRW5kXCI6IHRhZ3Muc3BlY2lhbCh0YWdzLmJyYWNlKSxcbiAgXCIuXCI6IHRhZ3MuZGVyZWZPcGVyYXRvcixcbiAgXCIsIDtcIjogdGFncy5zZXBhcmF0b3IsXG4gIFwiQFwiOiB0YWdzLm1ldGEsXG5cbiAgVHlwZU5hbWU6IHRhZ3MudHlwZU5hbWUsXG4gIFR5cGVEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy50eXBlTmFtZSksXG4gIFwidHlwZSBlbnVtIGludGVyZmFjZSBpbXBsZW1lbnRzIG5hbWVzcGFjZSBtb2R1bGUgZGVjbGFyZVwiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImFic3RyYWN0IGdsb2JhbCBQcml2YWN5IHJlYWRvbmx5IG92ZXJyaWRlXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiaXMga2V5b2YgdW5pcXVlIGluZmVyIGFzc2VydHNcIjogdGFncy5vcGVyYXRvcktleXdvcmQsXG5cbiAgSlNYQXR0cmlidXRlVmFsdWU6IHRhZ3MuYXR0cmlidXRlVmFsdWUsXG4gIEpTWFRleHQ6IHRhZ3MuY29udGVudCxcbiAgXCJKU1hTdGFydFRhZyBKU1hTdGFydENsb3NlVGFnIEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hFbmRUYWdcIjogdGFncy5hbmdsZUJyYWNrZXQsXG4gIFwiSlNYSWRlbnRpZmllciBKU1hOYW1lU3BhY2VkTmFtZVwiOiB0YWdzLnRhZ05hbWUsXG4gIFwiSlNYQXR0cmlidXRlL0pTWElkZW50aWZpZXIgSlNYQXR0cmlidXRlL0pTWE5hbWVTcGFjZWROYW1lXCI6IHRhZ3MuYXR0cmlidXRlTmFtZSxcbiAgXCJKU1hCdWlsdGluL0pTWElkZW50aWZpZXJcIjogdGFncy5zdGFuZGFyZCh0YWdzLnRhZ05hbWUpXG59KTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX2lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsZXhwb3J0OjIwLCBhczoyNSwgZnJvbTozMywgZGVmYXVsdDozNiwgYXN5bmM6NDEsIGZ1bmN0aW9uOjQyLCBpbjo1Miwgb3V0OjU1LCBjb25zdDo1NiwgZXh0ZW5kczo2MCwgdGhpczo2NCwgdHJ1ZTo3MiwgZmFsc2U6NzIsIG51bGw6ODQsIHZvaWQ6ODgsIHR5cGVvZjo5Miwgc3VwZXI6MTA4LCBuZXc6MTQyLCBkZWxldGU6MTU0LCB5aWVsZDoxNjMsIGF3YWl0OjE2NywgY2xhc3M6MTcyLCBwdWJsaWM6MjM1LCBwcml2YXRlOjIzNSwgcHJvdGVjdGVkOjIzNSwgcmVhZG9ubHk6MjM3LCBpbnN0YW5jZW9mOjI1Niwgc2F0aXNmaWVzOjI1OSwgaW1wb3J0OjI5Miwga2V5b2Y6MzQ5LCB1bmlxdWU6MzUzLCBpbmZlcjozNTksIGFzc2VydHM6Mzk1LCBpczozOTcsIGFic3RyYWN0OjQxNywgaW1wbGVtZW50czo0MTksIHR5cGU6NDIxLCBsZXQ6NDI0LCB2YXI6NDI2LCB1c2luZzo0MjksIGludGVyZmFjZTo0MzUsIGVudW06NDM5LCBuYW1lc3BhY2U6NDQ1LCBtb2R1bGU6NDQ3LCBkZWNsYXJlOjQ1MSwgZ2xvYmFsOjQ1NSwgZGVmZXI6NDcxLCBmb3I6NDc2LCBvZjo0ODUsIHdoaWxlOjQ4OCwgd2l0aDo0OTIsIGRvOjQ5NiwgaWY6NTAwLCBlbHNlOjUwMiwgc3dpdGNoOjUwNiwgY2FzZTo1MTIsIHRyeTo1MTgsIGNhdGNoOjUyMiwgZmluYWxseTo1MjYsIHJldHVybjo1MzAsIHRocm93OjUzNCwgYnJlYWs6NTM4LCBjb250aW51ZTo1NDIsIGRlYnVnZ2VyOjU0Nn07XG5jb25zdCBzcGVjX3dvcmQgPSB7X19wcm90b19fOm51bGwsYXN5bmM6MTI5LCBnZXQ6MTMxLCBzZXQ6MTMzLCBkZWNsYXJlOjE5NSwgcHVibGljOjE5NywgcHJpdmF0ZToxOTcsIHByb3RlY3RlZDoxOTcsIHN0YXRpYzoxOTksIGFic3RyYWN0OjIwMSwgb3ZlcnJpZGU6MjAzLCByZWFkb25seToyMDksIGFjY2Vzc29yOjIxMSwgbmV3OjQwMX07XG5jb25zdCBzcGVjX0xlc3NUaGFuID0ge19fcHJvdG9fXzpudWxsLFwiPFwiOjE5M307XG5jb25zdCBwYXJzZXIgPSBMUlBhcnNlci5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiJEZ8USVUUWxPT08lW1FsT09PJ19RcE9PUChsT2BPT08qelEhME14TycjQ2lPK1JPI3RPJyNDak8rYU8mak8nI0NqTytvTyNASXRPJyNEYU8uUVFsTycjRGdPLmJRbE8nI0RyTyVbUWxPJyNEek8wZlFsTycjRVNPT1EhMExmJyNFWycjRVtPMVBRYE8nI0VYT09RTycjRXAnI0VwT09RTycjSWwnI0lsTzFYUWBPJyNHc08xZFFgTycjRW9PMWlRYE8nI0VvTzNoUSEwTXhPJyNKck82W1EhME14TycjSnNPNnVRYE8nI0ZdTzZ6USxVTycjRnRPT1EhMExmJyNGZicjRmZPN1ZPN2RPJyNGZk85WFFNaE8nI0Z8TzlgUWBPJyNGe09PUSEwTGYnI0pzJyNKc09PUSEwTGInI0pyJyNKck85ZVFgTycjR3dPT1FbJyNLXycjS19POXBRYE8nI0lZTzl1USEwTHJPJyNJWk9PUVsnI0pgJyNKYE9PUVsnI0lfJyNJX1FgUWxPT1FgUWxPT085fVEhTF5PJyNEdk86VVFsTycjRU9POl1RbE8nI0VRTzlrUWBPJyNHc086ZFFNaE8nI0NvTzpyUWBPJyNFbk86fVFgTycjRXlPO2hRTWhPJyNGZU87eFFgTycjR3NPT1FPJyNLYCcjS2BPO31RYE8nI0tgTzxdUWBPJyNHe088XVFgTycjR3xPPF1RYE8nI0hPTzlrUWBPJyNIUk89U1FgTycjSFVPPmtRYE8nI0NlTz57UWBPJyNIY08/VFFgTycjSGlPP1RRYE8nI0hrT2BRbE8nI0htTz9UUWBPJyNIb08/VFFgTycjSHJPP1lRYE8nI0h4Tz9fUSEwTHNPJyNJT08lW1FsTycjSVFPP2pRITBMc08nI0lTTz91USEwTHNPJyNJVU85dVEhMExyTycjSVdPQFFRITBNeE8nI0NpT0FTUXBPJyNEbFFPUWBPT08lW1FsTycjRVFPQWpRYE8nI0VUTzpkUU1oTycjRW5PQXVRYE8nI0VuT0JRUSFiTycjRmVPT1FbJyNDZycjQ2dPT1EhMExiJyNEcScjRHFPT1EhMExiJyNKdicjSnZPJVtRbE8nI0p2T09RTycjSnknI0p5T09RTycjSWgnI0loT0NRUXBPJyNFZ09PUSEwTGInI0VmJyNFZk9PUSEwTGInI0p9JyNKfU9DfFEhME1TTycjRWdPRFdRcE8nI0VXT09RTycjSngnI0p4T0RsUXBPJyNKeU9FeVFwTycjRVdPRFdRcE8nI0VnUEZXTyYyRGpPJyNDYlBPT08pQ0R9KUNEfU9PT08nI0lgJyNJYE9GY08jdE8sNTlVT09RITBMaCw1OVUsNTlVT09PTycjSWEnI0lhT0ZxTyZqTyw1OVVPR1BRIUxeTycjRGNPT09PJyNJYycjSWNPR1dPI0BJdE8sNTl7T09RITBMZiw1OXssNTl7T0dmUWxPJyNJZE9HeVFgTycjSnRPSXhRIWZPJyNKdE8rfVFsTycjSnRPSlBRYE8sNTpST0pnUWBPJyNFcE9KdFFgTycjS1RPS1BRYE8nI0tTT0tQUWBPJyNLU09LWFFgTyw1O15PS15RYE8nI0tST09RITBMbiw1Ol4sNTpeT0tlUWxPLDU6Xk9NY1EhME14Tyw1OmZPTlNRYE8sNTpuT05tUSEwTHJPJyNLUU9OdFFgTycjS1BPOWVRYE8nI0tQTyEgWVFgTycjS1BPISBiUWBPLDU7XU8hIGdRYE8nI0tQTyEjbFEhZk8nI0pzT09RITBMaCcjQ2knI0NpTyVbUWxPJyNFU08hJFtRIWZPLDU6c09PUVMnI0p6JyNKek9PUU8tRTxqLUU8ak85a1FgTyw1PV9PISRyUWBPLDU9X08hJHdRbE8sNTtaTyEmelFNaE8nI0VrTyEoZVFgTyw1O1pPIShqUWxPJyNEeU8hKHRRcE8sNTtkTyEofFFwTyw1O2RPJVtRbE8sNTtkT09RWycjRlQnI0ZUT09RWycjRlYnI0ZWTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU8lW1FsTyw1O2VPJVtRbE8sNTtlTyVbUWxPLDU7ZU9PUVsnI0ZaJyNGWk8hKVtRbE8sNTt0T09RITBMZiw1O3ksNTt5T09RITBMZiw1O3osNTt6T09RITBMZiw1O3wsNTt8TyVbUWxPJyNJcE8hK19RITBMck8sNTxpTyVbUWxPLDU7ZU8hJnpRTWhPLDU7ZU8hK3xRTWhPLDU7ZU8hLW5RTWhPJyNFXk8lW1FsTyw1O3dPT1EhMExmLDU7eyw1O3tPIS11USxVTycjRmpPIS5yUSxVTycjS1hPIS5eUSxVTycjS1hPIS55USxVTycjS1hPT1FPJyNLWCcjS1hPIS9fUSxVTyw1PFNPT09XLDU8YCw1PGBPIS9wUWxPJyNGdk9PT1cnI0lvJyNJb083Vk83ZE8sNTxRTyEvd1EsVU8nI0Z4T09RITBMZiw1PFEsNTxRTyEwaFEkSVVPJyNDeU9PUSEwTGgnI0N9JyNDfU8hMHtPI0BJdE8nI0RSTyExaVFNak8sNTxlTyExcFFgTyw1PGhPITNZUShDV08nI0dYTyEzalFgTycjR1lPITNvUWBPJyNHWU8hNV9RKENXTycjR15PITZkUXBPJyNHYk9PUU8nI0duJyNHbk8hLFRRTWhPJyNHbU9PUU8nI0dwJyNHcE8hLFRRTWhPJyNHb08hN1ZRJElVTycjSmxPT1EhMExoJyNKbCcjSmxPITdhUWBPJyNKa08hN29RYE8nI0pqTyE3d1FgTycjQ3VPT1EhMExoJyNDeycjQ3tPIThZUWBPJyNDfU9PUSEwTGgnI0RWJyNEVk9PUSEwTGgnI0RYJyNEWE8hOF9RYE8sNTxlTzFTUWBPJyNEWk8hLFRRTWhPJyNHUE8hLFRRTWhPJyNHUk8hOGdRYE8nI0dUTyE4bFFgTycjR1VPITNvUWBPJyNHW08hLFRRTWhPJyNHYU88XVFgTycjSmtPIThxUWBPJyNFcU8hOWBRYE8sNTxnT09RITBMYicjQ3InI0NyTyE5aFFgTycjRXJPITpiUXBPJyNFc09PUSEwTGInI0tSJyNLUk8hOmlRITBMck8nI0thTzl1USEwTHJPLDU9Y09gUWxPLDU+dE9PUVsnI0poJyNKaE9PUVssNT51LDU+dU9PUVstRTxdLUU8XU8hPGhRITBNeE8sNTpiTyE6XVFwTyw1OmBPIT9SUSEwTXhPLDU6ak8lW1FsTyw1OmpPIUFpUSEwTXhPLDU6bE9PUU8sNUB6LDVAek8hQllRTWhPLDU9X08hQmhRITBMck8nI0ppTzlgUWBPJyNKaU8hQnlRITBMck8sNTlaTyFDVVFwTyw1OVpPIUNeUU1oTyw1OVpPOmRRTWhPLDU5Wk8hQ2lRYE8sNTtaTyFDcVFgTycjSGJPIURWUWBPJyNLZE8lW1FsTyw1O31PITpdUXBPLDU8UE8hRF9RYE8sNT16TyFEZFFgTyw1PXpPIURpUWBPLDU9ek8hRHdRYE8sNT16Tzl1USEwTHJPLDU9ek88XVFgTyw1PWpPT1FPJyNDeScjQ3lPIUVPUXBPLDU9Z08hRVdRTWhPLDU9aE8hRWNRYE8sNT1qTyFFaFEhYk8sNT1tTyFFcFFgTycjS2BPP1lRYE8nI0hXTzlrUWBPJyNIWU8hRXVRYE8nI0hZTzpkUU1oTycjSFtPIUV6UWBPJyNIW09PUVssNT1wLDU9cE8hRlBRYE8nI0hdTyFGYlFgTycjQ29PIUZnUWBPLDU5UE8hRnFRYE8sNTlQTyFIdlFsTyw1OVBPT1FbLDU5UCw1OVBPIUlXUSEwTHJPLDU5UE8lW1FsTyw1OVBPIUtjUWxPJyNIZU9PUVsnI0hmJyNIZk9PUVsnI0hnJyNIZ09gUWxPLDU9fU8hS3lRYE8sNT19T2BRbE8sNT5UT2BRbE8sNT5WTyFMT1FgTyw1PlhPYFFsTyw1PlpPIUxUUWBPLDU+Xk8hTFlRbE8sNT5kT09RWyw1PmosNT5qTyVbUWxPLDU+ak85dVEhMExyTyw1PmxPT1FbLDU+biw1Pm5PIyFkUWBPLDU+bk9PUVssNT5wLDU+cE8jIWRRYE8sNT5wT09RWyw1PnIsNT5yTyMjUVFwTycjRF9PJVtRbE8nI0p2TyMjc1FwTycjSnZPIyN9UXBPJyNEbU8jJGBRcE8nI0RtTyMmcVFsTycjRG1PIyZ4UWBPJyNKdU8jJ1FRYE8sNTpXTyMnVlFgTycjRXRPIydlUWBPJyNLVU8jJ21RYE8sNTtfTyMnclFwTycjRG1PIyhQUXBPJyNFVk9PUSEwTGYsNTpvLDU6b08lW1FsTyw1Om9PIyhXUWBPLDU6b08/WVFgTyw1O1lPIUNVUXBPLDU7WU8hQ15RTWhPLDU7WU86ZFFNaE8sNTtZTyMoYFFgTyw1QGJPIyhlUTA3ZE8sNTpzT09RTy1FPGYtRTxmTyMpa1EhME1TTyw1O1JPRFdRcE8sNTpyTyMpdVFwTyw1OnJPRFdRcE8sNTtSTyFCeVEhMExyTyw1OnJPT1EhMExiJyNFaicjRWpPT1FPLDU7Uiw1O1JPJVtRbE8sNTtSTyMqU1EhMExyTyw1O1JPIypfUSEwTHJPLDU7Uk8hQ1VRcE8sNTpyT09RTyw1O1gsNTtYTyMqbVEhMExyTyw1O1JQT09PJyNJXicjSV5QIytSTyYyRGpPLDU4fFBPT08sNTh8LDU4fE9PT08tRTxeLUU8Xk9PUSEwTGgxRy5wMUcucE9PT08tRTxfLUU8X09PT08sNTl9LDU5fU8jK15RIWJPLDU5fU9PT08tRTxhLUU8YU9PUSEwTGYxRy9nMUcvZ08jK2NRIWZPLDU/T08rfVFsTyw1P09PT1FPLDU/VSw1P1VPIyttUWxPJyNJZE9PUU8tRTxiLUU8Yk8jK3pRYE8sNUBgTyMsU1EhZk8sNUBgTyMsWlFgTyw1QG5PT1EhMExmMUcvbTFHL21PJVtRbE8sNUBvTyMsY1FgTycjSWpPT1FPLUU8aC1FPGhPIyxaUWBPLDVAbk9PUSEwTGIxRzB4MUcweE9PUSEwTG4xRy94MUcveE9PUSEwTG4xRzBZMUcwWU8lW1FsTyw1QGxPIyx3USEwTHJPLDVAbE8jLVlRITBMck8sNUBsTyMtYVFgTyw1QGtPOWVRYE8sNUBrTyMtaVFgTyw1QGtPIy13UWBPJyNJbU8jLWFRYE8sNUBrT09RITBMYjFHMHcxRzB3TyEodFFwTyw1OnVPISlQUXBPLDU6dU9PUVMsNTp3LDU6d08jLmlRZE8sNTp3TyMucVFNaE8xRzJ5TzlrUWBPMUcyeU9PUSEwTGYxRzB1MUcwdU8jL1BRITBNeE8xRzB1TyMwVVEhME12Tyw1O1ZPT1EhMExoJyNHVycjR1dPIzByUSEwTXpPJyNKbE8hJHdRbE8xRzB1TyMyfVEhZk8nI0p3TyVbUWxPJyNKd08jM1hRYE8sNTplT09RITBMaCcjRF8nI0RfT09RITBMZjFHMU8xRzFPTyVbUWxPMUcxT09PUSEwTGYxRzFmMUcxZk8jM15RYE8xRzFPTyM1clEhME14TzFHMVBPIzV5USEwTXhPMUcxUE8jOGFRITBNeE8xRzFQTyM4aFEhME14TzFHMVBPIztPUSEwTXhPMUcxUE8jPWZRITBNeE8xRzFQTyM9bVEhME14TzFHMVBPIz10USEwTXhPMUcxUE8jQFtRITBNeE8xRzFQTyNAY1EhME14TzFHMVBPI0JwUT9NdE8nI0NpTyNEa1E/TXRPMUcxYE8jRHJRP010TycjSnNPI0VWUSEwTXhPLDU/W09PUSEwTGItRTxuLUU8bk8jR2RRITBNeE8xRzFQTyNIYVEhME16TzFHMVBPT1EhMExmMUcxUDFHMVBPI0lkUU1qTycjSnxPI0luUWBPLDU6eE8jSXNRITBNeE8xRzFjTyNKZ1EsVU8sNTxXTyNKb1EsVU8sNTxYTyNKd1EsVU8nI0ZvTyNLYFFgTycjRm5PT1FPJyNLWScjS1lPT1FPJyNJbicjSW5PI0tlUSxVTzFHMW5PT1EhMExmMUcxbjFHMW5PT09XMUcxeTFHMXlPI0t2UT9NdE8nI0pyTyNMUVFgTyw1PGJPISlbUWxPLDU8Yk9PT1ctRTxtLUU8bU9PUSEwTGYxRzFsMUcxbE8jTFZRcE8nI0tYT09RITBMZiw1PGQsNTxkTyNMX1FwTyw1PGRPI0xkUU1oTycjRFRPT09PJyNJYicjSWJPI0xrTyNASXRPLDU5bU9PUSEwTGgsNTltLDU5bU8lW1FsTzFHMlBPIThsUWBPJyNJck8jTHZRYE8sNTx6T09RITBMaCw1PHcsNTx3TyEsVFFNaE8nI0l1TyNNZFFNak8sNT1YTyEsVFFNaE8nI0l3TyNOVlFNak8sNT1aTyEmelFNaE8sNT1dT09RTzFHMlMxRzJTTyNOYVEhZE8nI0NyTyNOdFEoQ1dPJyNFck8kIHxRcE8nI0diTyQhZFEhZE8sNTxzTyQha1FgTycjS1tPOWVRYE8nI0tbTyQheVFgTyw1PHVPJCNhUSFkTycjQ3tPISxUUU1oTyw1PHRPJCNrUWBPJyNHWk8kJFBRYE8sNTx0TyQkVVEhZE8nI0dXTyQkY1EhZE8nI0tdTyQkbVFgTycjS11PISZ6UU1oTycjS11PJCRyUWBPLDU8eE8kJHdRbE8nI0p2TyQlUlFwTycjR2NPIyRgUXBPJyNHY08kJWRRYE8nI0dnTyEzb1FgTycjR2tPJCVpUSEwTHJPJyNJdE8kJXRRcE8sNTx8T09RITBMcCw1PHwsNTx8TyQle1FwTycjR2NPJCZZUXBPJyNHZE8kJmtRcE8nI0dkTyQmcFFNak8sNT1YTyQnUVFNak8sNT1aT09RITBMaCw1PV4sNT1eTyEsVFFNaE8sNUBWTyEsVFFNaE8sNUBWTyQnYlFgTycjSXlPJCd2UWBPLDVAVU8kKE9RYE8sNTlhT09RITBMaCw1OWksNTlpTyQoVFFgTyw1QFZPJClUUSRJWU8sNTl1T09RITBMaCcjSnAnI0pwTyQpdlFNak8sNTxrTyQqaVFNak8sNTxtT0B6UWBPLDU8b09PUSEwTGgsNTxwLDU8cE8kKnNRYE8sNTx2TyQqeFFNak8sNTx7TyQrWVFgTycjS1BPISR3UWxPMUcyUk8kK19RYE8xRzJSTzllUWBPJyNLU085ZVFgTycjRXRPJVtRbE8nI0V0TzllUWBPJyNJe08kK2RRITBMck8sNUB7T09RWzFHMn0xRzJ9T09RWzFHNGAxRzRgT09RITBMZjFHL3wxRy98T09RITBMZjFHL3oxRy96TyQtZlEhME14TzFHMFVPT1FbMUcyeTFHMnlPISZ6UU1oTzFHMnlPJVtRbE8xRzJ5TyMudFFgTzFHMnlPJC9qUU1oTycjRWtPT1EhMExiLDVAVCw1QFRPJC93USEwTHJPLDVAVE9PUVsxRy51MUcudU8hQnlRITBMck8xRy51TyFDVVFwTzFHLnVPIUNeUU1oTzFHLnVPJDBZUWBPMUcwdU8kMF9RYE8nI0NpTyQwalFgTycjS2VPJDByUWBPLDU9fE8kMHdRYE8nI0tlTyQwfFFgTycjS2VPJDFbUWBPJyNKUk8kMWpRYE8sNUFPTyQxclEhZk8xRzFpT09RITBMZjFHMWsxRzFrTzlrUWBPMUczZk9AelFgTzFHM2ZPJDF5UWBPMUczZk8kMk9RYE8xRzNmTyFEaVFgTzFHM2ZPOXVRITBMck8xRzNmT09RWzFHM2YxRzNmTyFFY1FgTzFHM1VPISZ6UU1oTzFHM1JPJDJUUWBPMUczUk9PUVsxRzNTMUczU08hJnpRTWhPMUczU08kMllRYE8xRzNTTyQyYlFwTycjSFFPT1FbMUczVTFHM1VPITZfUXBPJyNJfU8hRWhRIWJPMUczWE9PUVsxRzNYMUczWE9PUVssNT1yLDU9ck8kMmpRTWhPLDU9dE85a1FgTyw1PXRPJCVkUWBPLDU9dk85YFFgTyw1PXZPIUNVUXBPLDU9dk8hQ15RTWhPLDU9dk86ZFFNaE8sNT12TyQyeFFgTycjS2NPJDNUUWBPLDU9d09PUVsxRy5rMUcua08kM1lRITBMck8xRy5rT0B6UWBPMUcua08kM2VRYE8xRy5rTzl1USEwTHJPMUcua08kNW1RIWZPLDVBUU8kNXpRYE8sNUFRTzllUWBPLDVBUU8kNlZRbE8sNT5QTyQ2XlFgTyw1PlBPT1FbMUczaTFHM2lPYFFsTzFHM2lPT1FbMUczbzFHM29PT1FbMUczcTFHM3FPP1RRYE8xRzNzTyQ2Y1FsTzFHM3VPJDpnUWxPJyNIdE9PUVsxRzN4MUczeE8kOnRRYE8nI0h6Tz9ZUWBPJyNIfE9PUVsxRzRPMUc0T08kOnxRbE8xRzRPTzl1USEwTHJPMUc0VU9PUVsxRzRXMUc0V09PUSEwTGInI0dfJyNHX085dVEhMExyTzFHNFlPOXVRITBMck8xRzRbTyQ/VFFgTyw1QGJPISlbUWxPLDU7YE85ZVFgTyw1O2BPP1lRYE8sNTpYTyEpW1FsTyw1OlhPIUNVUXBPLDU6WE8kP1lRP010Tyw1OlhPT1FPLDU7YCw1O2BPJD9kUXBPJyNJZU8kP3pRYE8sNUBhT09RITBMZjFHL3IxRy9yTyRAU1FwTycjSWtPJEBeUWBPLDVAcE9PUSEwTGIxRzB5MUcweU8jJGBRcE8sNTpYT09RTycjSWcnI0lnTyRAZlFwTyw1OnFPT1EhMExuLDU6cSw1OnFPIyhaUWBPMUcwWk9PUSEwTGYxRzBaMUcwWk8lW1FsTzFHMFpPT1EhMExmMUcwdDFHMHRPP1lRYE8xRzB0TyFDVVFwTzFHMHRPIUNeUU1oTzFHMHRPT1EhMExiMUc1fDFHNXxPIUJ5USEwTHJPMUcwXk9PUU8xRzBtMUcwbU8lW1FsTzFHMG1PJEBtUSEwTHJPMUcwbU8kQHhRITBMck8xRzBtTyFDVVFwTzFHMF5PRFdRcE8xRzBeTyRBV1EhMExyTzFHMG1PT1FPMUcwXjFHMF5PJEFsUSEwTXhPMUcwbVBPT08tRTxbLUU8W1BPT08xRy5oMUcuaE9PT08xRy9pMUcvaU8kQXZRIWJPLDU8aU8kQk9RIWZPMUc0ak9PUU8xRzRwMUc0cE8lW1FsTyw1P09PJEJZUWBPMUc1ek8kQmJRYE8xRzZZTyRCalEhZk8xRzZaTzllUWBPLDU/VU8kQnRRITBNeE8xRzZXTyVbUWxPMUc2V08kQ1VRITBMck8xRzZXTyRDZ1FgTzFHNlZPJENnUWBPMUc2Vk85ZVFgTzFHNlZPJENvUWBPLDU/WE85ZVFgTyw1P1hPT1FPLDU/WCw1P1hPJERUUWBPLDU/WE8kK1lRYE8sNT9YT09RTy1FPGstRTxrT09RUzFHMGExRzBhT09RUzFHMGMxRzBjTyMubFFgTzFHMGNPT1FbNysoZTcrKGVPISZ6UU1oTzcrKGVPJVtRbE83KyhlTyREY1FgTzcrKGVPJERuUU1oTzcrKGVPJER8USEwTXpPLDU9WE8kR1hRITBNek8sNT1aTyRJZFEhME16Tyw1PVhPJEt1USEwTXpPLDU9Wk8kTldRITBNek8sNTl1TyUhXVEhME16Tyw1PGtPJSRoUSEwTXpPLDU8bU8lJnNRITBNek8sNTx7T09RITBMZjcrJmE3KyZhTyUpVVEhME14TzcrJmFPJSl4UWxPJyNJZk8lKlZRYE8sNUBjTyUqX1EhZk8sNUBjT09RITBMZjFHMFAxRzBQTyUqaVFgTzcrJmpPT1EhMExmNysmajcrJmpPJSpuUT9NdE8sNTpmTyVbUWxPNysmek8lKnhRP010Tyw1OmJPJStWUT9NdE8sNTpqTyUrYVE/TXRPLDU6bE8lK2tRTWhPJyNJaU8lK3VRYE8sNUBoT09RITBMaDFHMGQxRzBkT09RTzFHMXIxRzFyT09RTzFHMXMxRzFzTyUrfVEhak8sNTxaTyEpW1FsTyw1PFlPT1FPLUU8bC1FPGxPT1EhMExmNysnWTcrJ1lPT09XNysnZTcrJ2VPT09XMUcxfDFHMXxPJSxZUWBPMUcxfE9PUSEwTGYxRzJPMUcyT09PT08sNTlvLDU5b08lLF9RIWRPLDU5b09PT08tRTxgLUU8YE9PUSEwTGgxRy9YMUcvWE8lLGZRITBNeE83KydrT09RITBMaCw1P14sNT9eTyUtWVFNaE8xRzJmUCUtYVFgTycjSXJQT1EhMExoLUU8cC1FPHBPJS19UU1qTyw1P2FPT1EhMExoLUU8cy1FPHNPJS5wUU1qTyw1P2NPT1EhMExoLUU8dS1FPHVPJS56USFkTzFHMndPJS9SUSFkTycjQ3JPJS9pUU1oTycjS1NPJCR3UWxPJyNKdk9PUSEwTGgxRzJfMUcyX08lL3NRYE8nI0lxTyUwW1FgTyw1QHZPJTBbUWBPLDVAdk8lMGRRYE8sNUB2TyUwb1FgTyw1QHZPT1FPMUcyYTFHMmFPJTB9UU1qTzFHMmBPJCtZUWBPJyNLW08hLFRRTWhPMUcyYE8lMV9RKENXTycjSXNPJTFsUWBPLDVAd08hJnpRTWhPLDVAd08lMXRRIWRPLDVAd09PUSEwTGgxRzJkMUcyZE8lNFVRIWZPJyNDaU8lNGBRYE8sNT1QT09RITBMYiw1PH0sNTx9TyU0aFFwTyw1PH1PT1EhMExiLDU9Tyw1PU9PQ3dRYE8sNTx9TyU0c1FwTyw1PH1PT1EhMExiLDU9Uiw1PVJPJCtZUWBPLDU9Vk9PUU8sNT9gLDU/YE9PUU8tRTxyLUU8ck9PUSEwTHAxRzJoMUcyaE8jJGBRcE8sNTx9TyQkd1FsTyw1PVBPJTVSUWBPLDU9T08lNV5RcE8sNT1PTyEsVFFNaE8nI0l1TyU2V1FNak8xRzJzTyEsVFFNaE8nI0l3TyU2eVFNak8xRzJ1TyU3VFFNak8xRzVxTyU3X1FNak8xRzVxT09RTyw1P2UsNT9lT09RTy1FPHctRTx3T09RTzFHLnsxRy57TyEsVFFNaE8xRzVxTyEsVFFNaE8xRzVxTyE6XVFwTyw1OXdPJVtRbE8sNTl3T09RITBMaCw1PGosNTxqTyU3bFFgTzFHMlpPISxUUU1oTzFHMmJPJTdxUSEwTXhPNysnbU9PUSEwTGY3KydtNysnbU8hJHdRbE83KydtTyU4ZVFgTyw1O2BPT1EhMExiLDU/Zyw1P2dPT1EhMExiLUU8eS1FPHlPJThqUSFkTycjS15PIyhaUWBPNysoZU80VVEhZk83KyhlTyREZlFgTzcrKGVPJTh0USEwTXZPJyNDaU8lOVhRITBNdk8sNT1TTyU5bFFgTyw1PVNPJTl0UWBPLDU9U09PUSEwTGIxRzVvMUc1b09PUVs3KyRhNyskYU8hQnlRITBMck83KyRhTyFDVVFwTzcrJGFPISR3UWxPNysmYU8lOXlRYE8nI0pRTyU6YlFgTyw1QVBPT1FPMUczaDFHM2hPOWtRYE8sNUFQTyU6YlFgTyw1QVBPJTpqUWBPLDVBUE9PUU8sNT9tLDU/bU9PUU8tRT1QLUU9UE9PUSEwTGY3KydUNysnVE8lOm9RYE83KylRTzl1USEwTHJPNyspUU85a1FgTzcrKVFPQHpRYE83KylRTyU6dFFgTzcrKVFPT1FbNyspUTcrKVFPT1FbNysocDcrKHBPJTp5USEwTXZPNysobU8hJnpRTWhPNysobU8hRV5RYE83KyhuT09RWzcrKG43KyhuTyEmelFNaE83KyhuTyU7VFFgTycjS2JPJTtgUWBPLDU9bE9PUU8sNT9pLDU/aU9PUU8tRTx7LUU8e09PUVs3KyhzNysoc08lPHJRcE8nI0haT09RWzFHM2AxRzNgTyEmelFNaE8xRzNgTyVbUWxPMUczYE8lPHlRYE8xRzNgTyU9VVFNaE8xRzNgTzl1USEwTHJPMUczYk8kJWRRYE8xRzNiTzlgUWBPMUczYk8hQ1VRcE8xRzNiTyFDXlFNaE8xRzNiTyU9ZFFgTycjSlBPJT14UWBPLDVAfU8lPlFRcE8sNUB9T09RITBMYjFHM2MxRzNjT09RWzcrJFY3KyRWT0B6UWBPNyskVk85dVEhMExyTzcrJFZPJT5dUWBPNyskVk8lW1FsTzFHNmxPJVtRbE8xRzZtTyU+YlEhMExyTzFHNmxPJT5sUWxPMUcza08lPnNRYE8xRzNrTyU+eFFsTzFHM2tPT1FbNyspVDcrKVRPOXVRITBMck83KylfT2BRbE83KylhT09RWycjS2gnI0toT09RWycjSlMnI0pTTyU/UFFsTyw1PmBPT1FbLDU+YCw1PmBPJVtRbE8nI0h1TyU/XlFgTycjSHdPT1FbLDU+Ziw1PmZPOWVRYE8sNT5mT09RWyw1PmgsNT5oT09RWzcrKWo3KylqT09RWzcrKXA3KylwT09RWzcrKXQ3Kyl0T09RWzcrKXY3Kyl2TyU/Y1FwTzFHNXxPJT99UT9NdE8xRzB6TyVAWFFgTzFHMHpPT1FPMUcvczFHL3NPJUBkUT9NdE8xRy9zTz9ZUWBPMUcvc08hKVtRbE8nI0RtT09RTyw1P1AsNT9QT09RTy1FPGMtRTxjT09RTyw1P1YsNT9WT09RTy1FPGktRTxpTyFDVVFwTzFHL3NPT1FPLUU8ZS1FPGVPT1EhMExuMUcwXTFHMF1PT1EhMExmNysldTcrJXVPIyhaUWBPNysldU9PUSEwTGY3KyZgNysmYE8/WVFgTzcrJmBPIUNVUXBPNysmYE9PUU83KyV4NysleE8kQWxRITBNeE83KyZYT09RTzcrJlg3KyZYTyVbUWxPNysmWE8lQG5RITBMck83KyZYTyFCeVEhMExyTzcrJXhPIUNVUXBPNysleE8lQHlRITBMck83KyZYTyVBWFEhME14TzcrK3JPJVtRbE83KytyTyVBaVFgTzcrK3FPJUFpUWBPNysrcU9PUU8xRzRzMUc0c085ZVFgTzFHNHNPJUFxUWBPMUc0c09PUVM3KyV9NyslfU8jKFpRYE88PExQTzRVUSFmTzw8TFBPJUJQUWBPPDxMUE9PUVs8PExQPDxMUE8hJnpRTWhPPDxMUE8lW1FsTzw8TFBPJUJYUWBPPDxMUE8lQmRRITBNek8sNT9hTyVEb1EhME16Tyw1P2NPJUZ6USEwTXpPMUcyYE8lSV1RITBNek8xRzJzTyVLaFEhME16TzFHMnVPJU1zUSFmTyw1P1FPJVtRbE8sNT9RT09RTy1FPGQtRTxkTyVNfVFgTzFHNX1PT1EhMExmPDxKVTw8SlVPJU5WUT9NdE8xRzB1TyYhXlE/TXRPMUcxUE8mIWVRP010TzFHMVBPJiRmUT9NdE8xRzFQTyYkbVE/TXRPMUcxUE8mJm5RP010TzFHMVBPJihvUT9NdE8xRzFQTyYodlE/TXRPMUcxUE8mKH1RP010TzFHMVBPJitPUT9NdE8xRzFQTyYrVlE/TXRPMUcxUE8mK15RITBNeE88PEpmTyYtVVE/TXRPMUcxUE8mLlJRP012TzFHMVBPJi9VUT9Ndk8nI0psTyYxW1E/TXRPMUcxY08mMWlRP010TzFHMFVPJjFzUU1qTyw1P1RPT1FPLUU8Zy1FPGdPISlbUWxPJyNGcU9PUU8nI0taJyNLWk9PUU8xRzF1MUcxdU8mMX1RYE8xRzF0TyYyU1E/TXRPLDU/W09PT1c3KydoNysnaE9PT08xRy9aMUcvWk8mMl5RIWRPMUc0eE9PUSEwTGg3KyhRNysoUVAhJnpRTWhPLDU/Xk8hLFRRTWhPNysoY08mMmVRYE8sNT9dTzllUWBPLDU/XU8kK1lRYE8sNT9dT09RTy1FPG8tRTxvTyYyc1FgTzFHNmJPJjJzUWBPMUc2Yk8mMntRYE8xRzZiTyYzV1FNak83Kyd6TyYzaFEhZE8sNT9fTyYzclFgTyw1P19PISZ6UU1oTyw1P19PT1FPLUU8cS1FPHFPJjN3USFkTzFHNmNPJjRSUWBPMUc2Y08mNFpRYE8xRzJrTyEmelFNaE8xRzJrT09RITBMYjFHMmkxRzJpT09RITBMYjFHMmoxRzJqTyU0aFFwTzFHMmlPIUNVUXBPMUcyaU9Dd1FgTzFHMmlPT1EhMExiMUcycTFHMnFPJjRgUXBPMUcyaU8mNG5RYE8xRzJrTyQrWVFgTzFHMmpPQ3dRYE8xRzJqTyQkd1FsTzFHMmtPJjR2UWBPMUcyak8mNWpRTWpPLDU/YU9PUSEwTGgtRTx0LUU8dE8mNl1RTWpPLDU/Y09PUSEwTGgtRTx2LUU8dk8hLFRRTWhPNysrXU8mNmdRTWpPNysrXU8mNnFRTWpPNysrXU9PUSEwTGgxRy9jMUcvY08mN09RYE8xRy9jT09RITBMaDcrJ3U3Kyd1TyY3VFFNak83Kyd8TyY3ZVEhME14Tzw8S1hPT1EhMExmPDxLWDw8S1hPJjhYUWBPMUcwek8hJnpRTWhPJyNJek8mOF5RYE8sNUB4TyY6YFEhZk88PExQTyEmelFNaE8xRzJuTyY6Z1EhMExyTzFHMm5PT1FbPDxHezw8R3tPIUJ5USEwTHJPPDxHe08mOnhRITBNeE88PEl7T09RITBMZjw8SXs8PEl7T09RTyw1P2wsNT9sTyY7bFFgTyw1P2xPJjtxUWBPLDU/bE9PUU8tRT1PLUU9T08mPFBRYE8xRzZrTyY8UFFgTzFHNmtPOWtRYE8xRzZrT0B6UWBPPDxMbE9PUVs8PExsPDxMbE8mPFhRYE88PExsTzl1USEwTHJPPDxMbE85a1FgTzw8TGxPT1FbPDxMWDw8TFhPJTp5USEwTXZPPDxMWE9PUVs8PExZPDxMWU8hRV5RYE88PExZTyY8XlFwTycjSXxPJjxpUWBPLDVAfE8hKVtRbE8sNUB8T09RWzFHM1cxRzNXT09RTycjSk8nI0pPTzl1USEwTHJPJyNKT08mPHFRcE8sNT11T09RWyw1PXUsNT11TyY8eFFwTycjRWdPJj1QUXBPJyNHZU8mPVVRYE83Kyh6TyY9WlFgTzcrKHpPT1FbNysoejcrKHpPISZ6UU1oTzcrKHpPJVtRbE83Kyh6TyY9Y1FgTzcrKHpPT1FbNysofDcrKHxPOXVRITBMck83Kyh8TyQlZFFgTzcrKHxPOWBRYE83Kyh8TyFDVVFwTzcrKHxPJj1uUWBPLDU/a09PUU8tRTx9LUU8fU9PUU8nI0heJyNIXk8mPXlRYE8xRzZpTzl1USEwTHJPPDxHcU9PUVs8PEdxPDxHcU9AelFgTzw8R3FPJj5SUWBPNyssV08mPldRYE83KyxYTyVbUWxPNyssV08lW1FsTzcrLFhPT1FbNyspVjcrKVZPJj5dUWBPNyspVk8mPmJRbE83KylWTyY+aVFgTzcrKVZPT1FbPDxMeTw8THlPT1FbPDxMezw8THtPT1FbLUU9US1FPVFPT1FbMUczejFHM3pPJj5uUWBPLDU+YU9PUVssNT5jLDU+Y08mPnNRYE8xRzRRTzllUWBPNysmZk8hKVtRbE83KyZmT09RTzcrJV83KyVfTyY+eFE/TXRPMUc2Wk8/WVFgTzcrJV9PT1EhMExmPDxJYTw8SWFPT1EhMExmPDxJejw8SXpPP1lRYE88PEl6T09RTzw8SXM8PElzTyRBbFEhME14Tzw8SXNPJVtRbE88PElzT09RTzw8SWQ8PElkTyFCeVEhMExyTzw8SWRPJj9TUSEwTHJPPDxJc08mP19RITBNeE88PSBeTyY/b1FgTzw9IF1PT1FPNysqXzcrKl9POWVRYE83KypfT09RW0FOQWtBTkFrTyY/d1EhZk9BTkFrTyEmelFNaE9BTkFrTyMoWlFgT0FOQWtPNFVRIWZPQU5Ba08mQE9RYE9BTkFrTyVbUWxPQU5Ba08mQFdRITBNek83Kyd6TyZCaVEhME16Tyw1P2FPJkR0USEwTXpPLDU/Y08mR1BRITBNek83Kyd8TyZJYlEhZk8xRzRsTyZJbFE/TXRPNysmYU8mS3BRP012Tyw1PVhPJk13UT9Ndk8sNT1aTyZOWFE/TXZPLDU9WE8mTmlRP012Tyw1PVpPJk55UT9Ndk8sNTl1TycjUFE/TXZPLDU8a08nJVNRP012Tyw1PG1PJydoUT9Ndk8sNTx7TycpXlE/TXRPNysna08nKWtRP010TzcrJ21PJyl4UWBPLDU8XU9PUU83KydgNysnYE9PUSEwTGg3KypkNysqZE8nKX1RTWpPPDxLfU9PUU8xRzR3MUc0d08nKlVRYE8xRzR3TycqYVFgTzFHNHdPJypvUWBPNysrfE8nKm9RYE83Kyt8TyEmelFNaE8xRzR5Tycqd1EhZE8xRzR5TycrUlFgTzcrK31PJytaUWBPNysoVk8nK2ZRIWRPNysoVk9PUSEwTGI3KyhUNysoVE9PUSEwTGI3KyhVNysoVU8hQ1VRcE83KyhUT0N3UWBPNysoVE8nK3BRYE83KyhWTyEmelFNaE83KyhWTyQrWVFgTzcrKFVPJyt1UWBPNysoVk9Dd1FgTzcrKFVPJyt9UU1qTzw8TndPISxUUU1oTzw8TndPT1EhMExoNyskfTcrJH1PJyxYUSFkTyw1P2ZPT1FPLUU8eC1FPHhPJyxjUSEwTXZPNysoWU8hJnpRTWhPNysoWU9PUVtBTj1nQU49Z085a1FgTzFHNVdPT1FPMUc1VzFHNVdPJyxzUWBPMUc1V08nLHhRYE83KyxWTycseFFgTzcrLFZPOXVRITBMck9BTkJXT0B6UWBPQU5CV09PUVtBTkJXQU5CV08nLVFRYE9BTkJXT09RW0FOQXNBTkFzT09RW0FOQXRBTkF0TyctVlFgTyw1P2hPT1FPLUU8ei1FPHpPJy1iUT9NdE8xRzZoT09RTyw1P2osNT9qT09RTy1FPHwtRTx8T09RWzFHM2ExRzNhTyctbFFgTyw1PVBPT1FbPDxMZjw8TGZPISZ6UU1oTzw8TGZPJj1VUWBPPDxMZk8nLXFRYE88PExmTyVbUWxPPDxMZk9PUVs8PExoPDxMaE85dVEhMExyTzw8TGhPJCVkUWBPPDxMaE85YFFgTzw8TGhPJy15UXBPMUc1Vk8nLlVRYE83KyxUT09RW0FOPV1BTj1dTzl1USEwTHJPQU49XU9PUVs8PSByPD0gck9PUVs8PSBzPD0gc08nLl5RYE88PSByTycuY1FgTzw9IHNPT1FbPDxMcTw8THFPJy5oUWBPPDxMcU8nLm1RbE88PExxT09RWzFHM3sxRzN7Tz9ZUWBPNyspbE8nLnRRYE88PEpRTycvUFE/TXRPPDxKUU9PUU88PEh5PDxIeU9PUSEwTGZBTj9mQU4/Zk9PUU9BTj9fQU4/X08kQWxRITBNeE9BTj9fT09RT0FOP09BTj9PTyVbUWxPQU4/X09PUU88PE15PDxNeU9PUVtHMjdWRzI3Vk8hJnpRTWhPRzI3Vk8jKFpRYE9HMjdWTycvWlEhZk9HMjdWTzRVUSFmT0cyN1ZPJy9iUWBPRzI3Vk8nL2pRP010Tzw8SmZPJy93UT9Ndk8xRzJgTycxbVE/TXZPLDU/YU8nM3BRP012Tyw1P2NPJzVzUT9Ndk8xRzJzTyc3dlE/TXZPMUcydU8nOXlRP010Tzw8S1hPJzpXUT9NdE88PEl7T09RTzFHMXcxRzF3TyEsVFFNaE9BTkFpT09RTzcrKmM3KypjTyc6ZVFgTzcrKmNPJzpwUWBPPD0gaE8nOnhRIWRPNysqZU9PUSEwTGI8PEtxPDxLcU8kK1lRYE88PEtxT0N3UWBPPDxLcU8nO1NRYE88PEtxTyEmelFNaE88PEtxT09RITBMYjw8S288PEtvTyFDVVFwTzw8S29PJztfUSFkTzw8S3FPT1EhMExiPDxLcDw8S3BPJztpUWBPPDxLcU8hJnpRTWhPPDxLcU8kK1lRYE88PEtwTyc7blFNak9BTkRjTyc7eFEhME12Tzw8S3RPT1FPNysqcjcrKnJPOWtRYE83KypyTyc8WVFgTzw9IHFPT1FbRzI3ckcyN3JPOXVRITBMck9HMjdyT0B6UWBPRzI3ck8hKVtRbE8xRzVTTyc8YlFgTzcrLFNPJzxqUWBPMUcya08mPVVRYE9BTkJRT09RW0FOQlFBTkJRTyEmelFNaE9BTkJRTyc8b1FgT0FOQlFPT1FbQU5CU0FOQlNPOXVRITBMck9BTkJTTyQlZFFgT0FOQlNPT1FPJyNIXycjSF9PT1FPNysqcTcrKnFPT1FbRzIyd0cyMndPT1FbQU5FXkFORV5PT1FbQU5FX0FORV9PT1FbQU5CXUFOQl1PJzx3UWBPQU5CXU9PUVs8PE1XPDxNV08hKVtRbE9BTj9sT09RT0cyNHlHMjR5TyRBbFEhME14T0cyNHlPIyhaUWBPTEQscU9PUVtMRCxxTEQscU8hJnpRTWhPTEQscU8nPHxRIWZPTEQscU8nPVRRP012TzcrJ3pPJz55UT9Ndk8sNT9hTydAfFE/TXZPLDU/Y08nQ1BRP012TzcrJ3xPJ0R1UU1qT0cyN1RPT1FPPDxNfTw8TX1PT1EhMExiQU5BXUFOQV1PJCtZUWBPQU5BXU9Dd1FgT0FOQV1PJ0VWUSFkT0FOQV1PT1EhMExiQU5BWkFOQVpPJ0VeUWBPQU5BXU8hJnpRTWhPQU5BXU8nRWlRIWRPQU5BXU9PUSEwTGJBTkFbQU5BW09PUU88PE5ePDxOXk9PUVtMRC1eTEQtXk85dVEhMExyT0xELV5PJ0VzUT9NdE83KypuT09RTycjR2YnI0dmT09RW0cyN2xHMjdsTyY9VVFgT0cyN2xPISZ6UU1oT0cyN2xPT1FbRzI3bkcyN25POXVRITBMck9HMjduT09RW0cyN3dHMjd3TydFfVE/TXRPRzI1V09PUU9MRCplTEQqZU9PUVshJCghXSEkKCFdTyMoWlFgTyEkKCFdTyEmelFNaE8hJCghXU8nRlhRITBNek9HMjdUT09RITBMYkcyNndHMjZ3TyQrWVFgT0cyNndPJ0hqUWBPRzI2d09Dd1FgT0cyNndPJ0h1USFkT0cyNndPISZ6UU1oT0cyNndPT1FbISQoIXghJCgheE9PUVtMRC1XTEQtV08mPVVRYE9MRC1XT09RW0xELVlMRC1ZT09RWyEpOUV3ISk5RXdPIyhaUWBPISk5RXdPT1EhMExiTEQsY0xELGNPJCtZUWBPTEQsY09Dd1FgT0xELGNPJ0h8UWBPTEQsY08nSVhRIWRPTEQsY09PUVshJCghciEkKCFyT09RWyEuSztjIS5LO2NPJ0lgUT9Ndk9HMjdUT09RITBMYiEkKCB9ISQoIH1PJCtZUWBPISQoIH1PQ3dRYE8hJCggfU8nS1VRYE8hJCggfU9PUSEwTGIhKTlFaSEpOUVpTyQrWVFgTyEpOUVpT0N3UWBPISk5RWlPT1EhMExiIS5LO1QhLks7VE8kK1lRYE8hLks7VE9PUSEwTGIhNC8wbyE0LzBvTyEpW1FsTycjRHpPMVBRYE8nI0VYTydLYVEhZk8nI0pyTydLaFEhTF5PJyNEdk8nS29RbE8nI0VPTydLdlEhZk8nI0NpTydOXlEhZk8nI0NpTyEpW1FsTycjRVFPJ05uUWxPLDU7Wk8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTyw1O2VPISlbUWxPLDU7ZU8hKVtRbE8sNTtlTyEpW1FsTycjSXBPKCFxUWBPLDU8aU8hKVtRbE8sNTtlTygheVFNaE8sNTtlTygkZFFNaE8sNTtlTyEpW1FsTyw1O3dPISZ6UU1oTycjR21PKCF5UU1oTycjR21PISZ6UU1oTycjR29PKCF5UU1oTycjR29PMVNRYE8nI0RaTzFTUWBPJyNEWk8hJnpRTWhPJyNHUE8oIXlRTWhPJyNHUE8hJnpRTWhPJyNHUk8oIXlRTWhPJyNHUk8hJnpRTWhPJyNHYU8oIXlRTWhPJyNHYU8hKVtRbE8sNTpqTygka1FwTycjRF9PKCR1UXBPJyNKdk8hKVtRbE8sNUBvTydOblFsTzFHMHVPKCVQUT9NdE8nI0NpTyEpW1FsTzFHMlBPISZ6UU1oTycjSXVPKCF5UU1oTycjSXVPISZ6UU1oTycjSXdPKCF5UU1oTycjSXdPKCVaUSFkTycjQ3JPISZ6UU1oTyw1PHRPKCF5UU1oTyw1PHRPJ05uUWxPMUcyUk8hKVtRbE83KyZ6TyEmelFNaE8xRzJgTygheVFNaE8xRzJgTyEmelFNaE8nI0l1TygheVFNaE8nI0l1TyEmelFNaE8nI0l3TygheVFNaE8nI0l3TyEmelFNaE8xRzJiTygheVFNaE8xRzJiTydOblFsTzcrJ21PJ05uUWxPNysmYU8hJnpRTWhPQU5BaU8oIXlRTWhPQU5BaU8oJW5RYE8nI0VvTyglc1FgTycjRW9PKCV7UWBPJyNGXU8oJlFRYE8nI0V5TygmVlFgTycjS1RPKCZiUWBPJyNLUk8oJm1RYE8sNTtaTygmclFNak8sNTxlTygmeVFgTycjR1lPKCdPUWBPJyNHWU8oJ1RRYE8sNTxlTygnXVFgTyw1PGdPKCdlUWBPLDU7Wk8oJ21RP010TzFHMWBPKCd0UWBPLDU8dE8oJ3lRYE8sNTx0TygoT1FgTyw1PHZPKChUUWBPLDU8dk8oKFlRYE8xRzJSTygoX1FgTzFHMHVPKChkUU1qTzw8S31PKChrUU1qTzw8S31PKChyUU1oTycjRnxPOWBRYE8nI0Z7T0F1UWBPJyNFbk8hKVtRbE8sNTt0TyEzb1FgTycjR1lPITNvUWBPJyNHWU8hM29RYE8nI0dbTyEzb1FgTycjR1tPISxUUU1oTzcrKGNPISxUUU1oTzcrKGNPJS56USFkTzFHMndPJS56USFkTzFHMndPISZ6UU1oTyw1PV1PISZ6UU1oTyw1PV1cIixcbiAgc3RhdGVEYXRhOiBcIigpeH5PJ3xPUyd9T1NUT1MoT1JRfk9QWU9RWU9TZk9ZIVZPYXFPZHpPZXlPbCFQT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hX1hPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXV3TyF4eE8hfF1PJFd8TyRuaU8laH1PJWohUU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUTyV5IVVPJlchV08mXiFYTyZgIVlPJmIhWk8mZCFbTyZnIV1PJm0hXk8mcyFfTyZ1IWBPJnchYU8meSFiTyZ7IWNPKFRTTyhWVE8oWVVPKGFWTyhvW09+T1d0T35QYE9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oVCFkTyhWVE8oWVVPKGFWTyhvW09+T2Ehd09zIW5PIVMhb08hYiF5TyFjIXZPIWQhdk8hfDxWTyNUIXBPI1UhcE8jViF4TyNXIXBPI1ghcE8jWyF6TyNdIXpPKFUhbE8oVlRPKFlVTyhlIW1PKG8hc09+TyhPIXtPfk9QXVhSXVhbXVhhXVhqXVhyXVghUV1YIVNdWCFdXVghbF1YIXBdWCNSXVgjU11YI2BdWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YJ3pdWChhXVgocl1YKHldWCh6XVh+TyFnJVJYflAocU9fIX1PKFYjUE8oVyF9TyhYI1BPfk9fI1FPKFgjUE8oWSNQTyhaI1FPfk94I1NPIVUjVE8oYiNUTyhjI1ZPfk9QWU9RWU9TZk9kIWpPZSFpT3BrT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oVDxaTyhWVE8oWVVPKGFWTyhvW09+TyFbI1pPIV0jV08hWShoUCFZKHZQflArfU8hXiNjT35QYE9QWU9RWU9TZk9kIWpPZSFpT3JZT3NrT3RrT3prT3xZTyFPWU8hU1dPIVdrTyFYa08hXyFlTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oVlRPKFlVTyhhVk8ob1tPfk9wI21PIVsjaU8hfF1PI2kjbE8jaiNpTyhUPFtPIWsoc1B+UC5pTyFsI29PKFQjbk9+TyF4I3NPIXxdTyVoI3RPfk8jayN1T35PIWcjdk8jayN1T35PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIV0kX08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYVZPKHIkWU8oeSN8Tyh6I31Pfk9hKGZYJ3ooZlgndyhmWCFrKGZYIVkoZlghXyhmWCVpKGZYIWcoZlh+UDFxTyNTJGRPI2AkZU8kUSRlT1AoZ1hSKGdYWyhnWGooZ1hyKGdYIVEoZ1ghUyhnWCFdKGdYIWwoZ1ghcChnWCNSKGdYI24oZ1gjbyhnWCNwKGdYI3EoZ1gjcihnWCNzKGdYI3QoZ1gjdShnWCN2KGdYI3goZ1gjeihnWCN7KGdYKGEoZ1gocihnWCh5KGdYKHooZ1ghXyhnWCVpKGdYfk9hKGdYJ3ooZ1gndyhnWCFZKGdYIWsoZ1h2KGdYIWcoZ1h+UDRVTyNgJGVPfk8kXSRoTyRfJGdPJGYkbU9+T1NmTyFfJG5PJGkkb08kayRxT35PaCVWT2olZE9rJWRPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU8lXU8hUyR7TyFfJHxPIWklYk8hbCR4TyNqJWNPJFclYE8kdCVeTyR2JV9PJHklYU8oVCRzTyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPZyheUH5PbCVbT35QN2VPIWwlZU9+TyFTJWhPIV8laU8oVCVnT35PIWclbU9+T2Elbk8neiVuT35PIVElck9+UCVbTyhVIWxPflAlW08lbiV2T35QJVtPaCVWTyFsJWVPKFQlZ08oVSFsT35PZSV9TyFsJWVPKFQlZ09+T2okUk9+TyFfJlBPKFQlZ08oVSFsTyhWVE8oWVVPYClXUH5PIVEmU08hbCZSTyVqJlZPJlQmV09+UDtTTyF4I3NPfk8lcyZZTyFTKVNYIV8pU1goVClTWH5PKFQmWk9+T2whUE8hdSZgTyVqIVFPJWwhT08lbSFPTyVuIU9PJXEhUk8lcyFTTyV2IVRPJXchVE9+T2QmZU9lJmRPIXgmYk8laCZjTyV7JmFPflA8Yk9kJmhPZXlPbCFQTyFfJmdPIXUmYE8heHhPIXxdTyVofU8lbCFPTyVtIU9PJW4hT08lcSFSTyVzIVNPJXYhVE8ldyFUTyV5IVVPfk9iJmtPI2Ambk8laiZpTyhVIWxPflA9Z08hbCZvTyF1JnNPfk8hbCNvT35PIV9YT35PYSVuTyd4JntPJ3olbk9+T2Elbk8neCdPTyd6JW5Pfk9hJW5PJ3gnUU8neiVuT35PJ3ddWCFZXVh2XVgha11YJltdWCFfXVglaV1YIWddWH5QKHFPIWInX08hYydXTyFkJ1dPKFUhbE8oVlRPKFlVT35PcydVTyFTJ1RPIVsnWE8oZSdTTyFeKGlQIV4oeFB+UEBuT24nYk8hXydgTyhUJWdPfk9lJ2dPIWwlZU8oVCVnT35PIVEmU08hbCZST35PcyFuTyFTIW9PIXw8Vk8jVCFwTyNVIXBPI1chcE8jWCFwTyhVIWxPKFZUTyhZVU8oZSFtTyhvIXNPfk8hYidtTyFjJ2xPIWQnbE8jViFwTyNbJ25PI10nbk9+UEJZT2Elbk9oJVZPIWcjdk8hbCVlTyd6JW5PKHIncE9+TyFwJ3RPI2Anck9+UENoT3Mhbk8hUyFvTyhWVE8oWVVPKGUhbU8obyFzT35PIV9YT3MobVghUyhtWCFiKG1YIWMobVghZChtWCF8KG1YI1QobVgjVShtWCNWKG1YI1cobVgjWChtWCNbKG1YI10obVgoVShtWChWKG1YKFkobVgoZShtWChvKG1Yfk8hYydsTyFkJ2xPKFUhbE9+UERXTyhQJ3hPKFEneE8oUid6T35PXyF9TyhWJ3xPKFchfU8oWCd8T35PXyNRTyhYJ3xPKFknfE8oWiNRT35PdihPT35QJVtPeCNTTyFVI1RPKGIjVE8oYyhST35PIVsoVE8hWSdXWCFZJ15YIV0nV1ghXSdeWH5QK31PIV0oVk8hWShoWH5PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIV0oVk8hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08jeCRVTyN6JFdPI3skWE8oYVZPKHIkWU8oeSN8Tyh6I31Pfk8hWShoWH5QSFJPIVkoW09+TyFZKHVYIV0odVghZyh1WCFrKHVYKHIodVh+TyNgKHVYI2sjZFghXih1WH5QSlVPI2AoXU8hWSh3WCFdKHdYfk8hXSheTyFZKHZYfk8hWShhT35PI2AkZU9+UEpVTyFeKGJPflBgT1Ijek8hUSN5TyFTI3tPIWwjeE8oYVZPUCFuYVshbmFqIW5hciFuYSFdIW5hIXAhbmEjUiFuYSNuIW5hI28hbmEjcCFuYSNxIW5hI3IhbmEjcyFuYSN0IW5hI3UhbmEjdiFuYSN4IW5hI3ohbmEjeyFuYShyIW5hKHkhbmEoeiFuYX5PYSFuYSd6IW5hJ3chbmEhWSFuYSFrIW5hdiFuYSFfIW5hJWkhbmEhZyFuYX5QS2xPIWsoY09+TyFnI3ZPI2AoZE8ocidwTyFdKHRYYSh0WCd6KHRYfk8hayh0WH5QTlhPIVMlaE8hXyVpTyF8XU8jaShpTyNqKGhPKFQlZ09+TyFdKGpPIWsoc1h+TyFrKGxPfk8hUyVoTyFfJWlPI2ooaE8oVCVnT35PUChnWFIoZ1hbKGdYaihnWHIoZ1ghUShnWCFTKGdYIV0oZ1ghbChnWCFwKGdYI1IoZ1gjbihnWCNvKGdYI3AoZ1gjcShnWCNyKGdYI3MoZ1gjdChnWCN1KGdYI3YoZ1gjeChnWCN6KGdYI3soZ1goYShnWChyKGdYKHkoZ1goeihnWH5PIWcjdk8hayhnWH5QISB1T1Iobk8hUShtTyFsI3hPI1MkZE8hfCF7YSFTIXthfk8heCF7YSVoIXthIV8he2EjaSF7YSNqIXthKFQhe2F+UCEjdk8heChyT35PUFlPUVlPU2ZPZCFqT2UhaU9wa09yWU9za090a096a098WU8hT1lPIVNXTyFXa08hWGtPIV9YTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF1IWdPIXghaE8kVyFrTyRuaU8oVCFkTyhWVE8oWVVPKGFWTyhvW09+T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTzxzTyFTJHtPIV8kfE8haT5WTyFsJHhPI2o8eU8kVyVgTyR0PHVPJHY8d08keSVhTyhUKHZPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+TyNrKHhPfk8hWyh6TyFrKGtQflAlW08oZSh8TyhvW09+TyFTKU9PIWwjeE8oZSh8TyhvW09+T1A8VU9RPFVPU2ZPZD5ST2UhaU9wa09yPFVPc2tPdGtPemtPfDxVTyFPPFVPIVNXTyFXa08hWGtPIV8hZU8haTxYTyFsWk8hbzxVTyFwPFVPIXE8VU8hczxZTyF1PF1PIXghaE8kVyFrTyRuPlBPKFQpXU8oVlRPKFlVTyhhVk8ob1tPfk8hXSRfT2EkcWEneiRxYSd3JHFhIWskcWEhWSRxYSFfJHFhJWkkcWEhZyRxYX5PbClkT35QISZ6T2glVk9wJVdPciVYT3MkdE90JHRPeiVZT3wlWk8hTyVdTyFTJHtPIV8kfE8haSViTyFsJHhPI2olY08kVyVgTyR0JV5PJHYlX08keSVhTyhUKHZPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+T2cocFB+UCEsVE8hUSlpTyFnKWhPIV8kXlgkWiReWCRdJF5YJF8kXlgkZiReWH5PIWcpaE8hXyh7WCRaKHtYJF0oe1gkXyh7WCRmKHtYfk8hUSlpT35QIS5eTyFRKWlPIV8oe1gkWih7WCRdKHtYJF8oe1gkZih7WH5PIV8pa08kWilvTyRdKWpPJF8pak8kZilwT35PIVspc09+UCEpW08kXSRoTyRfJGdPJGYpd09+T24kelghUSR6WCNTJHpYJ3kkelgoeSR6WCh6JHpYfk9nbVhnJHpYbm1YIV1tWCNgbVh+UCEwU094KXlPKGIpek8oYyl8T35PbipWTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPfk9nKX1PflAhMVdPZypXT35PaCVWT3IlWE9zJHRPdCR0T3olWU98JVpPIU88c08hUypZTyFfKlpPIWk+Vk8hbCR4TyNqPHlPJFclYE8kdDx1TyR2PHdPJHklYU8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PcCpgTyFbKl5PKFQqWE8haylPUH5QITF1TyNrKmFPfk8hbCpiT35PaCVWT3AlV09yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHNPIVMke08hXyR8TyFpPlZPIWwkeE8jajx5TyRXJWBPJHQ8dU8kdjx3TyR5JWFPKFQqZE8oVlRPKFlVTyhhJHVPKHkkfU8oeiVQT35PIVsqZ08hWSlQUH5QITN0T3Iqc09zIW5PIVMqaU8hYipxTyFjKmtPIWQqa08hbCpiTyNbKnJPJWAqbU8oVSFsTyhWVE8oWVVPKGUhbU9+TyFeKnBPflAhNWlPI1MkZE9uKGBYIVEoYFgneShgWCh5KGBYKHooYFghXShgWCNgKGBYfk9nKGBYJE8oYFh+UCE2a09uKnhPI2Aqd09nKF9YIV0oX1h+TyFdKnlPZyheWH5PaiVkT2slZE9sJWRPKFQmWk9nKF5Qfk9zKnxPfk9nKX1PKFQmWk9+TyFsK1NPfk8oVCh2T35PcCtXTyFTJWhPIVsjaU8hXyVpTyF8XU8jaSNsTyNqI2lPKFQlZ08hayhzUH5PIWcjdk8jaytYT35PIVMlaE8hWytaTyFdKF5PIV8laU8oVCVnTyFZKHZQfk9zJ1tPIVMrXU8hWytbTyhWVE8oWVVPKGUofE9+TyFeKHhQflAhOXxPIV0rXk9hKVRYJ3opVFh+T1AkW09SI3pPWyRjT2okUk9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jUiRSTyNuJE9PI28kUE8jcCRQTyNxJFBPI3IkUU8jcyRSTyN0JFJPI3UkYk8jdiRTTyN4JFVPI3okV08jeyRYTyhhVk8ociRZTyh5I3xPKHojfU9+T2EhamEhXSFqYSd6IWphJ3chamEhWSFqYSFrIWphdiFqYSFfIWphJWkhamEhZyFqYX5QITp0T1Ijek8hUSN5TyFTI3tPIWwjeE8oYVZPUCFyYVshcmFqIXJhciFyYSFdIXJhIXAhcmEjUiFyYSNuIXJhI28hcmEjcCFyYSNxIXJhI3IhcmEjcyFyYSN0IXJhI3UhcmEjdiFyYSN4IXJhI3ohcmEjeyFyYShyIXJhKHkhcmEoeiFyYX5PYSFyYSd6IXJhJ3chcmEhWSFyYSFrIXJhdiFyYSFfIXJhJWkhcmEhZyFyYX5QIT1bT1Ijek8hUSN5TyFTI3tPIWwjeE8oYVZPUCF0YVshdGFqIXRhciF0YSFdIXRhIXAhdGEjUiF0YSNuIXRhI28hdGEjcCF0YSNxIXRhI3IhdGEjcyF0YSN0IXRhI3UhdGEjdiF0YSN4IXRhI3ohdGEjeyF0YShyIXRhKHkhdGEoeiF0YX5PYSF0YSd6IXRhJ3chdGEhWSF0YSFrIXRhdiF0YSFfIXRhJWkhdGEhZyF0YX5QIT9yT2glVk9uK2dPIV8nYE8laStmT35PIWcraU9hKF1YIV8oXVgneihdWCFdKF1Yfk9hJW5PIV9YTyd6JW5Pfk9oJVZPIWwlZU9+T2glVk8hbCVlTyhUJWdPfk8hZyN2TyNrKHhPfk9iK3RPJWordU8oVCtxTyhWVE8oWVVPIV4pWFB+TyFdK3ZPYClXWH5PWyt6T35PYCt7T35PIV8mUE8oVCVnTyhVIWxPYClXUH5PJWosT09+UDtTT2glVk8jYCxTT35PaCVWT24sVk8hXyR8T35PIV8sWE9+TyFRLFpPIV9YT35PJW4ldk9+TyF4LGBPfk9lLGVPfk9iLGZPKFQjbk8oVlRPKFlVTyFeKVZQfk9lJX1Pfk8laiFRTyhUJlpPflA9Z09bLGtPYCxqT35PUFlPUVlPU2ZPZHpPZXlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFpdU8hbFpPIW9ZTyFwWU8hcVlPIXN2TyF4eE8hfF1PJG5pTyVofU8oVlRPKFlVTyhhVk8ob1tPfk8hXyFlTyF1IWdPJFcha08oVCFkT35QIUZ5T2Asak9hJW5PJ3olbk9+T1BZT1FZT1NmT2Qhak9lIWlPcGtPcllPc2tPdGtPemtPfFlPIU9ZTyFTV08hV2tPIVhrTyFfIWVPIWl1TyFsWk8hb1lPIXBZTyFxWU8hc3ZPIXghaE8kVyFrTyRuaU8oVCFkTyhWVE8oWVVPKGFWTyhvW09+T2EscE9sIU9PIXV3TyVsIU9PJW0hT08lbiFPT35QIUljTyFsJm9Pfk8mXix2T35PIV8seE9+TyZvLHpPJnEse09QJmxhUSZsYVMmbGFZJmxhYSZsYWQmbGFlJmxhbCZsYXAmbGFyJmxhcyZsYXQmbGF6JmxhfCZsYSFPJmxhIVMmbGEhVyZsYSFYJmxhIV8mbGEhaSZsYSFsJmxhIW8mbGEhcCZsYSFxJmxhIXMmbGEhdSZsYSF4JmxhIXwmbGEkVyZsYSRuJmxhJWgmbGElaiZsYSVsJmxhJW0mbGElbiZsYSVxJmxhJXMmbGEldiZsYSV3JmxhJXkmbGEmVyZsYSZeJmxhJmAmbGEmYiZsYSZkJmxhJmcmbGEmbSZsYSZzJmxhJnUmbGEmdyZsYSZ5JmxhJnsmbGEndyZsYShUJmxhKFYmbGEoWSZsYShhJmxhKG8mbGEhXiZsYSZlJmxhYiZsYSZqJmxhfk8oVC1RT35PaCFlWCFdIVJYIV4hUlghZyFSWCFnIWVYIWwhZVgjYCFSWH5PIV0hZVghXiFlWH5QIyFpTyFnLVZPI2AtVU9oKGpYIV0jaFghXiNoWCFnKGpYIWwoalh+TyFdKGpYIV4oalh+UCMjW09oJVZPIWctWE8hbCVlTyFdIWFYIV4hYVh+T3Mhbk8hUyFvTyhWVE8oWVVPKGUhbU9+T1A8VU9RPFVPU2ZPZD5ST2UhaU9wa09yPFVPc2tPdGtPemtPfDxVTyFPPFVPIVNXTyFXa08hWGtPIV8hZU8haTxYTyFsWk8hbzxVTyFwPFVPIXE8VU8hczxZTyF1PF1PIXghaE8kVyFrTyRuPlBPKFZUTyhZVU8oYVZPKG9bT35PKFQ9UU9+UCMkcU8hXS1dTyFeKGlYfk8hXi1fT35PIWctVk8jYC1VTyFdI2hYIV4jaFh+TyFdLWBPIV4oeFh+TyFeLWJPfk8hYy1jTyFkLWNPKFUhbE9+UCMkYE8hXi1mT35QJ19Pbi1pTyFfJ2BPfk8hWS1uT35PcyF7YSFiIXthIWMhe2EhZCF7YSNUIXthI1Uhe2EjViF7YSNXIXthI1ghe2EjWyF7YSNdIXthKFUhe2EoViF7YShZIXthKGUhe2EobyF7YX5QISN2TyFwLXNPI2AtcU9+UENoTyFjLXVPIWQtdU8oVSFsT35QRFdPYSVuTyNgLXFPJ3olbk9+T2Elbk8hZyN2TyNgLXFPJ3olbk9+T2Elbk8hZyN2TyFwLXNPI2AtcU8neiVuTyhyJ3BPfk8oUCd4TyhRJ3hPKFItek9+T3Yte09+TyFZJ1dhIV0nV2F+UCE6dE8hWy5QTyFZJ1dYIV0nV1h+UCVbTyFdKFZPIVkoaGF+TyFZKGhhflBIUk8hXSheTyFZKHZhfk8hUyVoTyFbLlRPIV8laU8oVCVnTyFZJ15YIV0nXlh+TyNgLlZPIV0odGEhayh0YWEodGEneih0YX5PIWcjdk9+UCMsd08hXShqTyFrKHNhfk8hUyVoTyFfJWlPI2ouWk8oVCVnT35PcC5gTyFTJWhPIVsuXU8hXyVpTyF8XU8jaS5fTyNqLl1PKFQlZ08hXSdhWCFrJ2FYfk9SLmRPIWwjeE9+T2glVk9uLmdPIV8nYE8laS5mT35PYSNjaSFdI2NpJ3ojY2kndyNjaSFZI2NpIWsjY2l2I2NpIV8jY2klaSNjaSFnI2NpflAhOnRPbj5dTyFRKk9PJ3kqUE8oeSR9Tyh6JVBPfk8jayNfYWEjX2EjYCNfYSd6I19hIV0jX2EhayNfYSFfI19hIVkjX2F+UCMvc08jayhgWFAoYFhSKGBYWyhgWGEoYFhqKGBYcihgWCFTKGBYIWwoYFghcChgWCNSKGBYI24oYFgjbyhgWCNwKGBYI3EoYFgjcihgWCNzKGBYI3QoYFgjdShgWCN2KGBYI3goYFgjeihgWCN7KGBYJ3ooYFgoYShgWChyKGBYIWsoYFghWShgWCd3KGBYdihgWCFfKGBYJWkoYFghZyhgWH5QITZrTyFdLnRPIWsoa1h+UCE6dE8hay53T35PIVkueU9+T1AkW09SI3pPIVEjeU8hUyN7TyFsI3hPIXAkW08oYVZPWyNtaWEjbWlqI21pciNtaSFdI21pI1IjbWkjbyNtaSNwI21pI3EjbWkjciNtaSNzI21pI3QjbWkjdSNtaSN2I21pI3gjbWkjeiNtaSN7I21pJ3ojbWkociNtaSh5I21pKHojbWkndyNtaSFZI21pIWsjbWl2I21pIV8jbWklaSNtaSFnI21pfk8jbiNtaX5QIzNjTyNuJE9PflAjM2NPUCRbT1Ijek9yJGFPIVEjeU8hUyN7TyFsI3hPIXAkW08jbiRPTyNvJFBPI3AkUE8jcSRQTyhhVk9bI21pYSNtaWojbWkhXSNtaSNSI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneiNtaShyI21pKHkjbWkoeiNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyNyI21pflAjNlFPI3IkUU9+UCM2UU9QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPKGFWT2EjbWkhXSNtaSN4I21pI3ojbWkjeyNtaSd6I21pKHIjbWkoeSNtaSh6I21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3YjbWl+UCM4b09QJFtPUiN6T1skY09qJFJPciRhTyFRI3lPIVMje08hbCN4TyFwJFtPI1IkUk8jbiRPTyNvJFBPI3AkUE8jcSRQTyNyJFFPI3MkUk8jdCRSTyN1JGJPI3YkU08oYVZPKHojfU9hI21pIV0jbWkjeiNtaSN7I21pJ3ojbWkociNtaSh5I21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PI3gkVU9+UCM7Vk8jeCNtaX5QIztWTyN2JFNPflAjOG9PUCRbT1Ijek9bJGNPaiRST3IkYU8hUSN5TyFTI3tPIWwjeE8hcCRbTyNSJFJPI24kT08jbyRQTyNwJFBPI3EkUE8jciRRTyNzJFJPI3QkUk8jdSRiTyN2JFNPI3gkVU8oYVZPKHkjfE8oeiN9T2EjbWkhXSNtaSN7I21pJ3ojbWkociNtaSd3I21pIVkjbWkhayNtaXYjbWkhXyNtaSVpI21pIWcjbWl+TyN6I21pflAjPXtPI3okV09+UCM9e09QXVhSXVhbXVhqXVhyXVghUV1YIVNdWCFsXVghcF1YI1JdWCNTXVgjYF1YI2tmWCNuXVgjb11YI3BdWCNxXVgjcl1YI3NdWCN0XVgjdV1YI3ZdWCN4XVgjel1YI3tdWCRRXVgoYV1YKHJdWCh5XVgoel1YIV1dWCFeXVh+TyRPXVh+UCNAak9QJFtPUiN6T1s8bU9qPGJPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI1I8Yk8jbjxfTyNvPGBPI3A8YE8jcTxgTyNyPGFPI3M8Yk8jdDxiTyN1PGxPI3Y8Y08jeDxlTyN6PGdPI3s8aE8oYVZPKHIkWU8oeSN8Tyh6I31Pfk8kTy57T35QI0J3TyNTJGRPI2A8bk8kUTxuTyRPKGdYIV4oZ1h+UCEgdU9hJ2RhIV0nZGEneidkYSd3J2RhIWsnZGEhWSdkYXYnZGEhXydkYSVpJ2RhIWcnZGF+UCE6dE9bI21pYSNtaWojbWlyI21pIV0jbWkjUiNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkneiNtaShyI21pJ3cjbWkhWSNtaSFrI21pdiNtaSFfI21pJWkjbWkhZyNtaX5PUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyNuJE9PI28kUE8jcCRQTyNxJFBPKGFWTyh5I21pKHojbWl+UCNFeU9uPl1PIVEqT08neSpQTyh5JH1PKHolUE9QI21pUiNtaSFTI21pIWwjbWkhcCNtaSNuI21pI28jbWkjcCNtaSNxI21pKGEjbWl+UCNFeU8hXS9QT2cocFh+UCExV09nL1JPfk9hJFBpIV0kUGkneiRQaSd3JFBpIVkkUGkhayRQaXYkUGkhXyRQaSVpJFBpIWckUGl+UCE6dE8kXS9TTyRfL1NPfk8kXS9UTyRfL1RPfk8hZyloTyNgL1VPIV8kY1gkWiRjWCRdJGNYJF8kY1gkZiRjWH5PIVsvVk9+TyFfKWtPJFovWE8kXSlqTyRfKWpPJGYvWU9+TyFdPGlPIV4oZlh+UCNCd08hXi9aT35PIWcpaE8kZih7WH5PJGYvXU9+T3YvXk9+UCEmek94KXlPKGIpek8oYy9hT35PIVMvZE9+Tyh5JH1PbiVhYSFRJWFhJ3klYWEoeiVhYSFdJWFhI2AlYWF+T2clYWEkTyVhYX5QI0x7Tyh6JVBPbiVjYSFRJWNhJ3klY2EoeSVjYSFdJWNhI2AlY2F+T2clY2EkTyVjYX5QI01uTyFdZlghZ2ZYIWtmWCFrJHpYKHJmWH5QITBTT3AlV08hWy9tTyFdKF5PKFQvbE8hWSh2UCFZKVBQflAhMXVPcipzTyFiKnFPIWMqa08hZCprTyFsKmJPI1sqck8lYCptTyhVIWxPKFZUTyhZVU9+T3M8fU8hUy9uTyFbK1tPIV4qcE8oZTx8TyFeKHhQflAkIFtPIWsvb09+UCMvc08hXS9wTyFnI3ZPKHIncE8haylPWH5PIWsvdU9+T25vWCFRb1gneW9YKHlvWCh6b1h+TyFnI3ZPIWtvWH5QJCNPT3Avd08hUyVoTyFbKl5PIV8laU8oVCVnTyFrKU9Qfk8jay94T35PIVkkelghXSR6WCFnJVJYflAhMFNPIV0veU8hWSlQWH5QIy9zTyFnL3tPfk8hWS99T35PcGtPKFQwT09+UC5pT2glVk9yMFRPIWcjdk8hbCVlTyhyJ3BPfk8hZytpT35PYSVuTyFdMFhPJ3olbk9+TyFeMFpPflAhNWlPIWMwW08hZDBbTyhVIWxPflAjJGBPcyFuTyFTMF1PKFZUTyhZVU8oZSFtT35PI1swX09+T2clYWEhXSVhYSNgJWFhJE8lYWF+UCExV09nJWNhIV0lY2EjYCVjYSRPJWNhflAhMVdPaiVkT2slZE9sJWRPKFQmWk9nJ21YIV0nbVh+TyFdKnlPZyheYX5PZzBoT35PbjBqTyNgMGlPZyhfYSFdKF9hfk9SMGtPIVEwa08hUzBsTyNTJGRPbn1hJ3l9YSh5fWEoen1hIV19YSNgfWF+T2d9YSRPfWF+UCQoY08hUSpPTyd5KlBPbiRzYSh5JHNhKHokc2EhXSRzYSNgJHNhfk9nJHNhJE8kc2F+UCQpX08hUSpPTyd5KlBPbiR1YSh5JHVhKHokdWEhXSR1YSNgJHVhfk9nJHVhJE8kdWF+UCQqUU8jazBvT35PZyVUYSFdJVRhI2AlVGEkTyVUYX5QITFXTyFnI3ZPfk8jazByT35PIV0rXk9hKVRhJ3opVGF+T1Ijek8hUSN5TyFTI3tPIWwjeE8oYVZPUCFyaVshcmlqIXJpciFyaSFdIXJpIXAhcmkjUiFyaSNuIXJpI28hcmkjcCFyaSNxIXJpI3IhcmkjcyFyaSN0IXJpI3UhcmkjdiFyaSN4IXJpI3ohcmkjeyFyaShyIXJpKHkhcmkoeiFyaX5PYSFyaSd6IXJpJ3chcmkhWSFyaSFrIXJpdiFyaSFfIXJpJWkhcmkhZyFyaX5QJCtvT2glVk9yJVhPcyR0T3QkdE96JVlPfCVaTyFPPHNPIVMke08hXyR8TyFpPlZPIWwkeE8jajx5TyRXJWBPJHQ8dU8kdjx3TyR5JWFPKFZUTyhZVU8oYSR1Tyh5JH1PKHolUE9+T3Awe08lXTB8TyhUMHpPflAkLlZPIWcraU9hKF1hIV8oXWEneihdYSFdKF1hfk8jazFTT35PW11YIV1mWCFeZlh+TyFdMVRPIV4pWFh+TyFeMVZPfk9bMVdPfk9iMVlPKFQrcU8oVlRPKFlVT35PIV8mUE8oVCVnT2AndVghXSd1WH5PIV0rdk9gKVdhfk8hazFdT35QITp0T1sxYE9+T2AxYU9+TyNgMWZPfk9uMWlPIV8kfE9+TyhlKHxPIV4pVVB+T2glVk9uMXJPIV8xb08laTFxT35PWzF8TyFdMXpPIV4pVlh+TyFeMX1Pfk9gMlBPYSVuTyd6JW5Pfk8oVCNuTyhWVE8oWVVPfk8jUyRkTyNgJGVPJFEkZU9QKGdYUihnWFsoZ1hyKGdYIVEoZ1ghUyhnWCFdKGdYIWwoZ1ghcChnWCNSKGdYI24oZ1gjbyhnWCNwKGdYI3EoZ1gjcihnWCNzKGdYI3QoZ1gjdShnWCN2KGdYI3goZ1gjeihnWCN7KGdYKGEoZ1gocihnWCh5KGdYKHooZ1h+T2oyU08mWzJUT2EoZ1h+UCQzcE9qMlNPI2AkZU8mWzJUT35PYTJWT35QJVtPYTJYT35PJmUyW09QJmNpUSZjaVMmY2lZJmNpYSZjaWQmY2llJmNpbCZjaXAmY2lyJmNpcyZjaXQmY2l6JmNpfCZjaSFPJmNpIVMmY2khVyZjaSFYJmNpIV8mY2khaSZjaSFsJmNpIW8mY2khcCZjaSFxJmNpIXMmY2khdSZjaSF4JmNpIXwmY2kkVyZjaSRuJmNpJWgmY2klaiZjaSVsJmNpJW0mY2klbiZjaSVxJmNpJXMmY2kldiZjaSV3JmNpJXkmY2kmVyZjaSZeJmNpJmAmY2kmYiZjaSZkJmNpJmcmY2kmbSZjaSZzJmNpJnUmY2kmdyZjaSZ5JmNpJnsmY2kndyZjaShUJmNpKFYmY2koWSZjaShhJmNpKG8mY2khXiZjaWImY2kmaiZjaX5PYjJiTyFeMmBPJmoyYU9+UGBPIV9YTyFsMmRPfk8mcSx7T1AmbGlRJmxpUyZsaVkmbGlhJmxpZCZsaWUmbGlsJmxpcCZsaXImbGlzJmxpdCZsaXombGl8JmxpIU8mbGkhUyZsaSFXJmxpIVgmbGkhXyZsaSFpJmxpIWwmbGkhbyZsaSFwJmxpIXEmbGkhcyZsaSF1JmxpIXgmbGkhfCZsaSRXJmxpJG4mbGklaCZsaSVqJmxpJWwmbGklbSZsaSVuJmxpJXEmbGklcyZsaSV2JmxpJXcmbGkleSZsaSZXJmxpJl4mbGkmYCZsaSZiJmxpJmQmbGkmZyZsaSZtJmxpJnMmbGkmdSZsaSZ3JmxpJnkmbGkmeyZsaSd3JmxpKFQmbGkoViZsaShZJmxpKGEmbGkobyZsaSFeJmxpJmUmbGliJmxpJmombGl+TyFZMmpPfk8hXSFhYSFeIWFhflAjQndPcyFuTyFTIW9PIVsycE8oZSFtTyFdJ1hYIV4nWFh+UEBuTyFdLV1PIV4oaWF+TyFdJ19YIV4nX1h+UCE5fE8hXS1gTyFeKHhhfk8hXjJ3T35QJ19PYSVuTyNgM1FPJ3olbk9+T2Elbk8hZyN2TyNgM1FPJ3olbk9+T2Elbk8hZyN2TyFwM1VPI2AzUU8neiVuTyhyJ3BPfk9hJW5PJ3olbk9+UCE6dE8hXSRfT3YkcWF+TyFZJ1dpIV0nV2l+UCE6dE8hXShWTyFZKGhpfk8hXSheTyFZKHZpfk8hWSh3aSFdKHdpflAhOnRPIV0odGkhayh0aWEodGkneih0aX5QITp0TyNgM1dPIV0odGkhayh0aWEodGkneih0aX5PIV0oak8hayhzaX5PIVMlaE8hXyVpTyF8XU8jaTNdTyNqM1tPKFQlZ09+TyFTJWhPIV8laU8jajNbTyhUJWdPfk9uM2RPIV8nYE8laTNjT35PaCVWT24zZE8hXydgTyVpM2NPfk8jayVhYVAlYWFSJWFhWyVhYWElYWFqJWFhciVhYSFTJWFhIWwlYWEhcCVhYSNSJWFhI24lYWEjbyVhYSNwJWFhI3ElYWEjciVhYSNzJWFhI3QlYWEjdSVhYSN2JWFhI3glYWEjeiVhYSN7JWFhJ3olYWEoYSVhYShyJWFhIWslYWEhWSVhYSd3JWFhdiVhYSFfJWFhJWklYWEhZyVhYX5QI0x7TyNrJWNhUCVjYVIlY2FbJWNhYSVjYWolY2FyJWNhIVMlY2EhbCVjYSFwJWNhI1IlY2EjbiVjYSNvJWNhI3AlY2EjcSVjYSNyJWNhI3MlY2EjdCVjYSN1JWNhI3YlY2EjeCVjYSN6JWNhI3slY2EneiVjYShhJWNhKHIlY2EhayVjYSFZJWNhJ3clY2F2JWNhIV8lY2ElaSVjYSFnJWNhflAjTW5PI2slYWFQJWFhUiVhYVslYWFhJWFhaiVhYXIlYWEhUyVhYSFdJWFhIWwlYWEhcCVhYSNSJWFhI24lYWEjbyVhYSNwJWFhI3ElYWEjciVhYSNzJWFhI3QlYWEjdSVhYSN2JWFhI3glYWEjeiVhYSN7JWFhJ3olYWEoYSVhYShyJWFhIWslYWEhWSVhYSd3JWFhI2AlYWF2JWFhIV8lYWElaSVhYSFnJWFhflAjL3NPI2slY2FQJWNhUiVjYVslY2FhJWNhaiVjYXIlY2EhUyVjYSFdJWNhIWwlY2EhcCVjYSNSJWNhI24lY2EjbyVjYSNwJWNhI3ElY2EjciVjYSNzJWNhI3QlY2EjdSVjYSN2JWNhI3glY2EjeiVjYSN7JWNhJ3olY2EoYSVjYShyJWNhIWslY2EhWSVjYSd3JWNhI2AlY2F2JWNhIV8lY2ElaSVjYSFnJWNhflAjL3NPI2t9YVB9YVt9YWF9YWp9YXJ9YSFsfWEhcH1hI1J9YSNufWEjb31hI3B9YSNxfWEjcn1hI3N9YSN0fWEjdX1hI3Z9YSN4fWEjen1hI3t9YSd6fWEoYX1hKHJ9YSFrfWEhWX1hJ3d9YXZ9YSFffWElaX1hIWd9YX5QJChjTyNrJHNhUCRzYVIkc2FbJHNhYSRzYWokc2FyJHNhIVMkc2EhbCRzYSFwJHNhI1Ikc2EjbiRzYSNvJHNhI3Akc2EjcSRzYSNyJHNhI3Mkc2EjdCRzYSN1JHNhI3Ykc2EjeCRzYSN6JHNhI3skc2EneiRzYShhJHNhKHIkc2EhayRzYSFZJHNhJ3ckc2F2JHNhIV8kc2ElaSRzYSFnJHNhflAkKV9PI2skdWFQJHVhUiR1YVskdWFhJHVhaiR1YXIkdWEhUyR1YSFsJHVhIXAkdWEjUiR1YSNuJHVhI28kdWEjcCR1YSNxJHVhI3IkdWEjcyR1YSN0JHVhI3UkdWEjdiR1YSN4JHVhI3okdWEjeyR1YSd6JHVhKGEkdWEociR1YSFrJHVhIVkkdWEndyR1YXYkdWEhXyR1YSVpJHVhIWckdWF+UCQqUU8jayVUYVAlVGFSJVRhWyVUYWElVGFqJVRhciVUYSFTJVRhIV0lVGEhbCVUYSFwJVRhI1IlVGEjbiVUYSNvJVRhI3AlVGEjcSVUYSNyJVRhI3MlVGEjdCVUYSN1JVRhI3YlVGEjeCVUYSN6JVRhI3slVGEneiVUYShhJVRhKHIlVGEhayVUYSFZJVRhJ3clVGEjYCVUYXYlVGEhXyVUYSVpJVRhIWclVGF+UCMvc09hI2NxIV0jY3EneiNjcSd3I2NxIVkjY3EhayNjcXYjY3EhXyNjcSVpI2NxIWcjY3F+UCE6dE8hWzNsTyFdJ1lYIWsnWVh+UCVbTyFdLnRPIWsoa2F+TyFdLnRPIWsoa2F+UCE6dE8hWTNvT35PJE8hbmEhXiFuYX5QS2xPJE8hamEhXSFqYSFeIWphflAjQndPJE8hcmEhXiFyYX5QIT1bTyRPIXRhIV4hdGF+UCE/ck9nJ11YIV0nXVh+UCEsVE8hXS9QT2cocGF+T1NmTyFfNFRPJGQ0VU9+TyFeNFlPfk92NFpPflAjL3NPYSRtcSFdJG1xJ3okbXEndyRtcSFZJG1xIWskbXF2JG1xIV8kbXElaSRtcSFnJG1xflAhOnRPIVk0XU9+UCEmek8hUzReT35PIVEqT08neSpQTyh6JVBPbidpYSh5J2lhIV0naWEjYCdpYX5PZydpYSRPJ2lhflAlLWZPIVEqT08neSpQT24na2EoeSdrYSh6J2thIV0na2EjYCdrYX5PZydrYSRPJ2thflAlLlhPKHIkWU9+UCMvc08hWWZYIVkkelghXWZYIV0kelghZyVSWCNgZlh+UCEwU09wJVdPKFQ9V09+UCExdU9wNGJPIVMlaE8hWzRhTyFfJWlPKFQlZ08hXSdlWCFrJ2VYfk8hXS9wTyFrKU9hfk8hXS9wTyFnI3ZPIWspT2F+TyFdL3BPIWcjdk8ocidwTyFrKU9hfk9nJHxpIV0kfGkjYCR8aSRPJHxpflAhMVdPIVs0ak8hWSdnWCFdJ2dYflAhM3RPIV0veU8hWSlQYX5PIV0veU8hWSlQYX5QIy9zT1BdWFJdWFtdWGpdWHJdWCFRXVghU11YIVldWCFdXVghbF1YIXBdWCNSXVgjU11YI2BdWCNrZlgjbl1YI29dWCNwXVgjcV1YI3JdWCNzXVgjdF1YI3VdWCN2XVgjeF1YI3pdWCN7XVgkUV1YKGFdWChyXVgoeV1YKHpdWH5PaiVZWCFnJVlYflAlMk9PajRvTyFnI3ZPfk9oJVZPIWcjdk8hbCVlT35PaCVWT3I0dE8hbCVlTyhyJ3BPfk9yNHlPIWcjdk8ocidwT35PcyFuTyFTNHpPKFZUTyhZVU8oZSFtT35PKHkkfU9uJWFpIVElYWkneSVhaSh6JWFpIV0lYWkjYCVhaX5PZyVhaSRPJWFpflAlNW9PKHolUE9uJWNpIVElY2kneSVjaSh5JWNpIV0lY2kjYCVjaX5PZyVjaSRPJWNpflAlNmJPZyhfaSFdKF9pflAhMVdPI2A1UU9nKF9pIV0oX2l+UCExV08hazVWT35PYSRvcSFdJG9xJ3okb3EndyRvcSFZJG9xIWskb3F2JG9xIV8kb3ElaSRvcSFnJG9xflAhOnRPIVk1Wk9+TyFdNVtPIV8pUVh+UCMvc09hJHpYIV8kelglXl1YJ3okelghXSR6WH5QITBTTyVeNV9PYW9YIV9vWCd6b1ghXW9YflAkI09PcDVgTyhUI25Pfk8lXjVfT35PYjVmTyVqNWdPKFQrcU8oVlRPKFlVTyFdJ3RYIV4ndFh+TyFdMVRPIV4pWGF+T1s1a09+T2A1bE9+T1s1cE9+T2Elbk8neiVuT35QIy9zTyFdNXVPI2A1d08hXilVWH5PIV41eE9+T3I2T09zIW5PIVMqaU8hYiF5TyFjIXZPIWQhdk8hfDxWTyNUIXBPI1UhcE8jViFwTyNXIXBPI1ghcE8jWzV9TyNdIXpPKFUhbE8oVlRPKFlVTyhlIW1PKG8hc09+TyFeNXxPflAlO2VPbjZUTyFfMW9PJWk2U09+T2glVk9uNlRPIV8xb08laTZTT35PYjZbTyhUI25PKFZUTyhZVU8hXSdzWCFeJ3NYfk8hXTF6TyFeKVZhfk8oVlRPKFlVTyhlNl5Pfk9gNmJPfk9qNmVPJls2Zk9+UE5YTyFrNmdPflAlW09hNmlPfk9hNmlPflAlW09iMmJPIV42bk8majJhT35QYE8hZzZwT35PIWc2ck9oKGppIV0oamkhXihqaSFnKGppIWwoamlyKGppKHIoaml+TyFdI2hpIV4jaGl+UCNCd08jYDZzTyFdI2hpIV4jaGl+TyFdIWFpIV4hYWl+UCNCd09hJW5PI2A2fE8neiVuT35PYSVuTyFnI3ZPI2A2fE8neiVuT35PIV0odHEhayh0cWEodHEneih0cX5QITp0TyFdKGpPIWsoc3F+TyFTJWhPIV8laU8jajdUTyhUJWdPfk8hXydgTyVpN1dPfk9uN1tPIV8nYE8laTdXT35PI2snaWFQJ2lhUidpYVsnaWFhJ2lhaidpYXInaWEhUydpYSFsJ2lhIXAnaWEjUidpYSNuJ2lhI28naWEjcCdpYSNxJ2lhI3InaWEjcydpYSN0J2lhI3UnaWEjdidpYSN4J2lhI3onaWEjeydpYSd6J2lhKGEnaWEocidpYSFrJ2lhIVknaWEndydpYXYnaWEhXydpYSVpJ2lhIWcnaWF+UCUtZk8jaydrYVAna2FSJ2thWydrYWEna2FqJ2thcidrYSFTJ2thIWwna2EhcCdrYSNSJ2thI24na2EjbydrYSNwJ2thI3Ena2EjcidrYSNzJ2thI3Qna2EjdSdrYSN2J2thI3gna2EjeidrYSN7J2thJ3ona2EoYSdrYShyJ2thIWsna2EhWSdrYSd3J2thdidrYSFfJ2thJWkna2EhZydrYX5QJS5YTyNrJHxpUCR8aVIkfGlbJHxpYSR8aWokfGlyJHxpIVMkfGkhXSR8aSFsJHxpIXAkfGkjUiR8aSNuJHxpI28kfGkjcCR8aSNxJHxpI3IkfGkjcyR8aSN0JHxpI3UkfGkjdiR8aSN4JHxpI3okfGkjeyR8aSd6JHxpKGEkfGkociR8aSFrJHxpIVkkfGkndyR8aSNgJHxpdiR8aSFfJHxpJWkkfGkhZyR8aX5QIy9zTyNrJWFpUCVhaVIlYWlbJWFpYSVhaWolYWlyJWFpIVMlYWkhbCVhaSFwJWFpI1IlYWkjbiVhaSNvJWFpI3AlYWkjcSVhaSNyJWFpI3MlYWkjdCVhaSN1JWFpI3YlYWkjeCVhaSN6JWFpI3slYWkneiVhaShhJWFpKHIlYWkhayVhaSFZJWFpJ3clYWl2JWFpIV8lYWklaSVhaSFnJWFpflAlNW9PI2slY2lQJWNpUiVjaVslY2lhJWNpaiVjaXIlY2khUyVjaSFsJWNpIXAlY2kjUiVjaSNuJWNpI28lY2kjcCVjaSNxJWNpI3IlY2kjcyVjaSN0JWNpI3UlY2kjdiVjaSN4JWNpI3olY2kjeyVjaSd6JWNpKGElY2kociVjaSFrJWNpIVklY2kndyVjaXYlY2khXyVjaSVpJWNpIWclY2l+UCU2Yk8hXSdZYSFrJ1lhflAhOnRPIV0udE8hayhraX5PJE8jY2khXSNjaSFeI2NpflAjQndPUCRbT1Ijek8hUSN5TyFTI3tPIWwjeE8hcCRbTyhhVk9bI21paiNtaXIjbWkjUiNtaSNvI21pI3AjbWkjcSNtaSNyI21pI3MjbWkjdCNtaSN1I21pI3YjbWkjeCNtaSN6I21pI3sjbWkkTyNtaShyI21pKHkjbWkoeiNtaSFdI21pIV4jbWl+TyNuI21pflAlTmRPI248X09+UCVOZE9QJFtPUiN6T3I8a08hUSN5TyFTI3tPIWwjeE8hcCRbTyNuPF9PI288YE8jcDxgTyNxPGBPKGFWT1sjbWlqI21pI1IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSRPI21pKHIjbWkoeSNtaSh6I21pIV0jbWkhXiNtaX5PI3IjbWl+UCYhbE8jcjxhT35QJiFsT1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8oYVZPI3gjbWkjeiNtaSN7I21pJE8jbWkociNtaSh5I21pKHojbWkhXSNtaSFeI21pfk8jdiNtaX5QJiR0T1AkW09SI3pPWzxtT2o8Yk9yPGtPIVEjeU8hUyN7TyFsI3hPIXAkW08jUjxiTyNuPF9PI288YE8jcDxgTyNxPGBPI3I8YU8jczxiTyN0PGJPI3U8bE8jdjxjTyhhVk8oeiN9TyN6I21pI3sjbWkkTyNtaShyI21pKHkjbWkhXSNtaSFeI21pfk8jeDxlT35QJiZ1TyN4I21pflAmJnVPI3Y8Y09+UCYkdE9QJFtPUiN6T1s8bU9qPGJPcjxrTyFRI3lPIVMje08hbCN4TyFwJFtPI1I8Yk8jbjxfTyNvPGBPI3A8YE8jcTxgTyNyPGFPI3M8Yk8jdDxiTyN1PGxPI3Y8Y08jeDxlTyhhVk8oeSN8Tyh6I31PI3sjbWkkTyNtaShyI21pIV0jbWkhXiNtaX5PI3ojbWl+UCYpVU8jejxnT35QJilVT2EjfHkhXSN8eSd6I3x5J3cjfHkhWSN8eSFrI3x5diN8eSFfI3x5JWkjfHkhZyN8eX5QITp0T1sjbWlqI21pciNtaSNSI21pI3IjbWkjcyNtaSN0I21pI3UjbWkjdiNtaSN4I21pI3ojbWkjeyNtaSRPI21pKHIjbWkhXSNtaSFeI21pfk9QJFtPUiN6TyFRI3lPIVMje08hbCN4TyFwJFtPI248X08jbzxgTyNwPGBPI3E8YE8oYVZPKHkjbWkoeiNtaX5QJixRT24+Xk8hUSpPTyd5KlBPKHkkfU8oeiVQT1AjbWlSI21pIVMjbWkhbCNtaSFwI21pI24jbWkjbyNtaSNwI21pI3EjbWkoYSNtaX5QJixRTyNTJGRPUChgWFIoYFhbKGBYaihgWG4oYFhyKGBYIVEoYFghUyhgWCFsKGBYIXAoYFgjUihgWCNuKGBYI28oYFgjcChgWCNxKGBYI3IoYFgjcyhgWCN0KGBYI3UoYFgjdihgWCN4KGBYI3ooYFgjeyhgWCRPKGBYJ3koYFgoYShgWChyKGBYKHkoYFgoeihgWCFdKGBYIV4oYFh+TyRPJFBpIV0kUGkhXiRQaX5QI0J3TyRPIXJpIV4hcml+UCQrb09nJ11hIV0nXWF+UCExV08hXjduT35PIV0nZGEhXidkYX5QI0J3TyFZN29PflAjL3NPIWcjdk8ocidwTyFdJ2VhIWsnZWF+TyFdL3BPIWspT2l+TyFdL3BPIWcjdk8haylPaX5PZyR8cSFdJHxxI2AkfHEkTyR8cX5QITFXTyFZJ2dhIV0nZ2F+UCMvc08hZzd2T35PIV0veU8hWSlQaX5QIy9zTyFdL3lPIVkpUGl+TyFZN3lPfk9oJVZPcjhPTyFsJWVPKHIncE9+T2o4UU8hZyN2T35PcjhUTyFnI3ZPKHIncE9+TyFRKk9PJ3kqUE8oeiVQT24namEoeSdqYSFdJ2phI2AnamF+T2cnamEkTydqYX5QJjVSTyFRKk9PJ3kqUE9uJ2xhKHknbGEoeidsYSFdJ2xhI2AnbGF+T2cnbGEkTydsYX5QJjV0T2coX3EhXShfcX5QITFXTyNgOFZPZyhfcSFdKF9xflAhMVdPIVk4V09+T2clT3EhXSVPcSNgJU9xJE8lT3F+UCExV09hJG95IV0kb3kneiRveSd3JG95IVkkb3khayRveXYkb3khXyRveSVpJG95IWckb3l+UCE6dE8hZzZyT35PIV01W08hXylRYX5PIV8nYE9QJFRhUiRUYVskVGFqJFRhciRUYSFRJFRhIVMkVGEhXSRUYSFsJFRhIXAkVGEjUiRUYSNuJFRhI28kVGEjcCRUYSNxJFRhI3IkVGEjcyRUYSN0JFRhI3UkVGEjdiRUYSN4JFRhI3okVGEjeyRUYShhJFRhKHIkVGEoeSRUYSh6JFRhfk8laTdXT35QJjhmTyVeOFtPYSVbaSFfJVtpJ3olW2khXSVbaX5PYSNjeSFdI2N5J3ojY3kndyNjeSFZI2N5IWsjY3l2I2N5IV8jY3klaSNjeSFnI2N5flAhOnRPWzheT35PYjhgTyhUK3FPKFZUTyhZVU9+TyFdMVRPIV4pWGl+T2A4ZE9+TyhlKHxPIV0ncFghXidwWH5PIV01dU8hXilVYX5PIV44bk9+UCU7ZU8obyFzT35QJCZZTyNbOG9Pfk8hXzFvT35PIV8xb08laThxT35Pbjh0TyFfMW9PJWk4cU9+T1s4eU8hXSdzYSFeJ3Nhfk8hXTF6TyFeKVZpfk8hazh9T35PIWs5T09+TyFrOVJPfk8hazlST35QJVtPYTlUT35PIWc5VU9+TyFrOVZPfk8hXSh3aSFeKHdpflAjQndPYSVuTyNgOV9PJ3olbk9+TyFdKHR5IWsodHlhKHR5J3oodHl+UCE6dE8hXShqTyFrKHN5fk8laTliT35QJjhmTyFfJ2BPJWk5Yk9+TyNrJHxxUCR8cVIkfHFbJHxxYSR8cWokfHFyJHxxIVMkfHEhXSR8cSFsJHxxIXAkfHEjUiR8cSNuJHxxI28kfHEjcCR8cSNxJHxxI3IkfHEjcyR8cSN0JHxxI3UkfHEjdiR8cSN4JHxxI3okfHEjeyR8cSd6JHxxKGEkfHEociR8cSFrJHxxIVkkfHEndyR8cSNgJHxxdiR8cSFfJHxxJWkkfHEhZyR8cX5QIy9zTyNrJ2phUCdqYVInamFbJ2phYSdqYWonamFyJ2phIVMnamEhbCdqYSFwJ2phI1InamEjbidqYSNvJ2phI3AnamEjcSdqYSNyJ2phI3MnamEjdCdqYSN1J2phI3YnamEjeCdqYSN6J2phI3snamEneidqYShhJ2phKHInamEhaydqYSFZJ2phJ3cnamF2J2phIV8namElaSdqYSFnJ2phflAmNVJPI2snbGFQJ2xhUidsYVsnbGFhJ2xhaidsYXInbGEhUydsYSFsJ2xhIXAnbGEjUidsYSNuJ2xhI28nbGEjcCdsYSNxJ2xhI3InbGEjcydsYSN0J2xhI3UnbGEjdidsYSN4J2xhI3onbGEjeydsYSd6J2xhKGEnbGEocidsYSFrJ2xhIVknbGEndydsYXYnbGEhXydsYSVpJ2xhIWcnbGF+UCY1dE8jayVPcVAlT3FSJU9xWyVPcWElT3FqJU9xciVPcSFTJU9xIV0lT3EhbCVPcSFwJU9xI1IlT3EjbiVPcSNvJU9xI3AlT3EjcSVPcSNyJU9xI3MlT3EjdCVPcSN1JU9xI3YlT3EjeCVPcSN6JU9xI3slT3EneiVPcShhJU9xKHIlT3EhayVPcSFZJU9xJ3clT3EjYCVPcXYlT3EhXyVPcSVpJU9xIWclT3F+UCMvc08hXSdZaSFrJ1lpflAhOnRPJE8jY3EhXSNjcSFeI2NxflAjQndPKHkkfU9QJWFhUiVhYVslYWFqJWFhciVhYSFTJWFhIWwlYWEhcCVhYSNSJWFhI24lYWEjbyVhYSNwJWFhI3ElYWEjciVhYSNzJWFhI3QlYWEjdSVhYSN2JWFhI3glYWEjeiVhYSN7JWFhJE8lYWEoYSVhYShyJWFhIV0lYWEhXiVhYX5PbiVhYSFRJWFhJ3klYWEoeiVhYX5QJkl5Tyh6JVBPUCVjYVIlY2FbJWNhaiVjYXIlY2EhUyVjYSFsJWNhIXAlY2EjUiVjYSNuJWNhI28lY2EjcCVjYSNxJWNhI3IlY2EjcyVjYSN0JWNhI3UlY2EjdiVjYSN4JWNhI3olY2EjeyVjYSRPJWNhKGElY2EociVjYSFdJWNhIV4lY2F+T24lY2EhUSVjYSd5JWNhKHklY2F+UCZMUU9uPl5PIVEqT08neSpQTyh6JVBPflAmSXlPbj5eTyFRKk9PJ3kqUE8oeSR9T35QJkxRT1Iwa08hUTBrTyFTMGxPI1MkZE9QfWFbfWFqfWFufWFyfWEhbH1hIXB9YSNSfWEjbn1hI299YSNwfWEjcX1hI3J9YSNzfWEjdH1hI3V9YSN2fWEjeH1hI3p9YSN7fWEkT31hJ3l9YShhfWEocn1hKHl9YSh6fWEhXX1hIV59YX5PIVEqT08neSpQT1Akc2FSJHNhWyRzYWokc2FuJHNhciRzYSFTJHNhIWwkc2EhcCRzYSNSJHNhI24kc2EjbyRzYSNwJHNhI3Ekc2EjciRzYSNzJHNhI3Qkc2EjdSRzYSN2JHNhI3gkc2EjeiRzYSN7JHNhJE8kc2EoYSRzYShyJHNhKHkkc2EoeiRzYSFdJHNhIV4kc2F+TyFRKk9PJ3kqUE9QJHVhUiR1YVskdWFqJHVhbiR1YXIkdWEhUyR1YSFsJHVhIXAkdWEjUiR1YSNuJHVhI28kdWEjcCR1YSNxJHVhI3IkdWEjcyR1YSN0JHVhI3UkdWEjdiR1YSN4JHVhI3okdWEjeyR1YSRPJHVhKGEkdWEociR1YSh5JHVhKHokdWEhXSR1YSFeJHVhfk9uPl5PIVEqT08neSpQTyh5JH1PKHolUE9+T1AlVGFSJVRhWyVUYWolVGFyJVRhIVMlVGEhbCVUYSFwJVRhI1IlVGEjbiVUYSNvJVRhI3AlVGEjcSVUYSNyJVRhI3MlVGEjdCVUYSN1JVRhI3YlVGEjeCVUYSN6JVRhI3slVGEkTyVUYShhJVRhKHIlVGEhXSVUYSFeJVRhflAnJ1ZPJE8kbXEhXSRtcSFeJG1xflAjQndPJE8kb3EhXSRvcSFeJG9xflAjQndPIV45b09+TyRPOXBPflAhMVdPIWcjdk8hXSdlaSFrJ2Vpfk8hZyN2TyhyJ3BPIV0nZWkhaydlaX5PIV0vcE8haylPcX5PIVknZ2khXSdnaX5QIy9zTyFdL3lPIVkpUHF+T3I5d08hZyN2TyhyJ3BPfk9bOXlPIVk5eE9+UCMvc08hWTl4T35PajpQTyFnI3ZPfk9nKF95IV0oX3l+UCExV08hXSduYSFfJ25hflAjL3NPYSVbcSFfJVtxJ3olW3EhXSVbcX5QIy9zT1s6VU9+TyFdMVRPIV4pWHF+T2A6WU9+TyNgOlpPIV0ncGEhXidwYX5PIV01dU8hXilVaX5QI0J3TyFTOl1Pfk8hXzFvTyVpOmBPfk8oVlRPKFlVTyhlOmVPfk8hXTF6TyFeKVZxfk8hazpoT35PIWs6aU9+TyFrOmpPfk8hazpqT35QJVtPI2A6bU8hXSNoeSFeI2h5fk8hXSNoeSFeI2h5flAjQndPJWk6ck9+UCY4Zk8hXydgTyVpOnJPfk8kTyN8eSFdI3x5IV4jfHl+UCNCd09QJHxpUiR8aVskfGlqJHxpciR8aSFTJHxpIWwkfGkhcCR8aSNSJHxpI24kfGkjbyR8aSNwJHxpI3EkfGkjciR8aSNzJHxpI3QkfGkjdSR8aSN2JHxpI3gkfGkjeiR8aSN7JHxpJE8kfGkoYSR8aShyJHxpIV0kfGkhXiR8aX5QJydWTyFRKk9PJ3kqUE8oeiVQT1AnaWFSJ2lhWydpYWonaWFuJ2lhcidpYSFTJ2lhIWwnaWEhcCdpYSNSJ2lhI24naWEjbydpYSNwJ2lhI3EnaWEjcidpYSNzJ2lhI3QnaWEjdSdpYSN2J2lhI3gnaWEjeidpYSN7J2lhJE8naWEoYSdpYShyJ2lhKHknaWEhXSdpYSFeJ2lhfk8hUSpPTyd5KlBPUCdrYVIna2FbJ2thaidrYW4na2FyJ2thIVMna2EhbCdrYSFwJ2thI1Ina2EjbidrYSNvJ2thI3Ana2EjcSdrYSNyJ2thI3Mna2EjdCdrYSN1J2thI3Yna2EjeCdrYSN6J2thI3sna2EkTydrYShhJ2thKHIna2EoeSdrYSh6J2thIV0na2EhXidrYX5PKHkkfU9QJWFpUiVhaVslYWlqJWFpbiVhaXIlYWkhUSVhaSFTJWFpIWwlYWkhcCVhaSNSJWFpI24lYWkjbyVhaSNwJWFpI3ElYWkjciVhaSNzJWFpI3QlYWkjdSVhaSN2JWFpI3glYWkjeiVhaSN7JWFpJE8lYWkneSVhaShhJWFpKHIlYWkoeiVhaSFdJWFpIV4lYWl+Tyh6JVBPUCVjaVIlY2lbJWNpaiVjaW4lY2lyJWNpIVElY2khUyVjaSFsJWNpIXAlY2kjUiVjaSNuJWNpI28lY2kjcCVjaSNxJWNpI3IlY2kjcyVjaSN0JWNpI3UlY2kjdiVjaSN4JWNpI3olY2kjeyVjaSRPJWNpJ3klY2koYSVjaShyJWNpKHklY2khXSVjaSFeJWNpfk8kTyRveSFdJG95IV4kb3l+UCNCd08kTyNjeSFdI2N5IV4jY3l+UCNCd08hZyN2TyFdJ2VxIWsnZXF+TyFdL3BPIWspT3l+TyFZJ2dxIV0nZ3F+UCMvc09yOnxPIWcjdk8ocidwT35PWztRTyFZO1BPflAjL3NPIVk7UE9+T2coXyFSIV0oXyFSflAhMVdPYSVbeSFfJVt5J3olW3khXSVbeX5QIy9zTyFdMVRPIV4pWHl+TyFdNXVPIV4pVXF+TyhUO1hPfk8hXzFvTyVpO1tPfk8haztfT35PJWk7ZE9+UCY4Zk9QJHxxUiR8cVskfHFqJHxxciR8cSFTJHxxIWwkfHEhcCR8cSNSJHxxI24kfHEjbyR8cSNwJHxxI3EkfHEjciR8cSNzJHxxI3QkfHEjdSR8cSN2JHxxI3gkfHEjeiR8cSN7JHxxJE8kfHEoYSR8cShyJHxxIV0kfHEhXiR8cX5QJydWTyFRKk9PJ3kqUE8oeiVQT1AnamFSJ2phWydqYWonamFuJ2phcidqYSFTJ2phIWwnamEhcCdqYSNSJ2phI24namEjbydqYSNwJ2phI3EnamEjcidqYSNzJ2phI3QnamEjdSdqYSN2J2phI3gnamEjeidqYSN7J2phJE8namEoYSdqYShyJ2phKHknamEhXSdqYSFeJ2phfk8hUSpPTyd5KlBPUCdsYVInbGFbJ2xhaidsYW4nbGFyJ2xhIVMnbGEhbCdsYSFwJ2xhI1InbGEjbidsYSNvJ2xhI3AnbGEjcSdsYSNyJ2xhI3MnbGEjdCdsYSN1J2xhI3YnbGEjeCdsYSN6J2xhI3snbGEkTydsYShhJ2xhKHInbGEoeSdsYSh6J2xhIV0nbGEhXidsYX5PUCVPcVIlT3FbJU9xaiVPcXIlT3EhUyVPcSFsJU9xIXAlT3EjUiVPcSNuJU9xI28lT3EjcCVPcSNxJU9xI3IlT3EjcyVPcSN0JU9xI3UlT3EjdiVPcSN4JU9xI3olT3EjeyVPcSRPJU9xKGElT3EociVPcSFdJU9xIV4lT3F+UCcnVk9nJWUhWiFdJWUhWiNgJWUhWiRPJWUhWn5QITFXTyFZO2hPflAjL3NPcjtpTyFnI3ZPKHIncE9+T1s7a08hWTtoT35QIy9zTyFdJ3BxIV4ncHF+UCNCd08hXSNoIVohXiNoIVp+UCNCd08jayVlIVpQJWUhWlIlZSFaWyVlIVphJWUhWmolZSFaciVlIVohUyVlIVohXSVlIVohbCVlIVohcCVlIVojUiVlIVojbiVlIVojbyVlIVojcCVlIVojcSVlIVojciVlIVojcyVlIVojdCVlIVojdSVlIVojdiVlIVojeCVlIVojeiVlIVojeyVlIVoneiVlIVooYSVlIVoociVlIVohayVlIVohWSVlIVondyVlIVojYCVlIVp2JWUhWiFfJWUhWiVpJWUhWiFnJWUhWn5QIy9zT3I7dE8hZyN2TyhyJ3BPfk8hWTt1T35QIy9zT3I7fE8hZyN2TyhyJ3BPfk8hWTt9T35QIy9zT1AlZSFaUiVlIVpbJWUhWmolZSFaciVlIVohUyVlIVohbCVlIVohcCVlIVojUiVlIVojbiVlIVojbyVlIVojcCVlIVojcSVlIVojciVlIVojcyVlIVojdCVlIVojdSVlIVojdiVlIVojeCVlIVojeiVlIVojeyVlIVokTyVlIVooYSVlIVoociVlIVohXSVlIVohXiVlIVp+UCcnVk9yPFFPIWcjdk8ocidwT35PdihmWH5QMXFPIVElck9+UCEpW08oVSFsT35QISlbTyFZZlghXWZYI2BmWH5QJTJPT1BdWFJdWFtdWGpdWHJdWCFRXVghU11YIV1dWCFdZlghbF1YIXBdWCNSXVgjU11YI2BdWCNgZlgja2ZYI25dWCNvXVgjcF1YI3FdWCNyXVgjc11YI3RdWCN1XVgjdl1YI3hdWCN6XVgje11YJFFdWChhXVgocl1YKHldWCh6XVh+TyFnZlgha11YIWtmWChyZlh+UCdMVE9QPFVPUTxVT1NmT2Q+Uk9lIWlPcGtPcjxVT3NrT3RrT3prT3w8VU8hTzxVTyFTV08hV2tPIVhrTyFfWE8haTxYTyFsWk8hbzxVTyFwPFVPIXE8VU8hczxZTyF1PF1PIXghaE8kVyFrTyRuPlBPKFQpXU8oVlRPKFlVTyhhVk8ob1tPfk8hXTxpTyFeJHFhfk9oJVZPcCVXT3IlWE9zJHRPdCR0T3olWU98JVpPIU88dE8hUyR7TyFfJHxPIWk+V08hbCR4TyNqPHpPJFclYE8kdDx2TyR2PHhPJHklYU8oVCh2TyhWVE8oWVVPKGEkdU8oeSR9Tyh6JVBPfk9sKWRPflAoIXlPciFlWChyIWVYflAjIWlPcihqWChyKGpYflAjI1tPIV5dWCFeZlh+UCdMVE8hWWZYIVkkelghXWZYIV0kelgjYGZYflAhMFNPI2s8Xk9+TyFnI3ZPI2s8Xk9+TyNgPG5Pfk9qPGJPfk8jYD1PTyFdKHdYIV4od1h+TyNgPG5PIV0odVghXih1WH5PI2s9UE9+T2c9Uk9+UCExV08jaz1YT35PI2s9WU9+T2c9Uk8oVCZaT35PIWcjdk8jaz1aT35PIWcjdk8jaz1QT35PJE89W09+UCNCd08jaz1dT35PI2s9Xk9+TyNrPWNPfk8jaz1kT35PI2s9ZU9+TyNrPWZPfk8kTz1nT35QITFXTyRPPWhPflAhMVdPbD1zT35QN2VPayNTI1QjVSNXI1gjWyNpI2ojdSRuJHQkdiR5JV0lXiVoJWklaiVxJXMldiV3JXkle34oT1QjbyFYJ3woVSNwcyNuI3FyIVEnfSRdJ30oVCRfKGV+XCIsXG4gIGdvdG86IFwiJDlZKV1QUFBQUFApXlBQKWFQKXJQK1cvXVBQUFA2bVBQN1RQUD1RUFBQQHRQQV5QQV5QUFBBXlBDZlBBXlBBXlBBXlBDalBDb1BEXlBJV1BQUElbUFBQUElbTF9QUFBMZU1WUElbUElbUFAhIGVJW1BQUElbUElbUCEjbElbUCEnUyEoWCEoYlAhKVUhKVkhKVUhLGdQUFBQUFBQIS1XIShYUFAhLWghL1lQITJpSVtJWyEybiE1eiE6aCE6aCE+Z1BQUCE+b0lbUFBQUFBQUFBQIUJPUCFDXVBQSVshRG5QSVtQSVtJW0lbSVtJW1BJWyFGUVAhSVtQIUxiUCFMZiFMcCFMdCFMdFAhSVhQIUx4IUx4UCMhT1AjIVNJW1BJWyMhWSMlX0NqQV5QQV5QQV5BXlAjJmxBXkFeIylPQV4jK3ZBXiMuU0FeQV4jLnIjMVcjMVcjMV0jMWYjMVcjMXFQUCMxV1BBXiMyWkFeIzZZQV5BXjZtUFBQIzpfUFBQIzp4Izp4UCM6eFAjO2AjOnhQUCM7ZlAjO11QIztdIzt5IztdIzxlIzxrIzxuKWFQIzxxKWFQIzx6Izx6Izx6UClhUClhUClhUClhUFApYVAjPVEjPVRQIz1UKWFQIz1YUCM9W1ApYVApYVApYVApYVApYVApYSlhUFAjPWIjPWgjPXMjPXkjPlAjPlYjPl0jPmsjPnEjPnsjP1IjP10jP2MjP3MjP3kjQGsjQH0jQVQjQVojQWkjQk8jQ3MjRFIjRFkjRXQjRlMjR3QjSFMjSFkjSGAjSGYjSHAjSHYjSHwjSVcjSWojSXBQUFBQUFBQUFBQUCNJdlBQUFBQUFAjSmsjTXgkIGIkIGkkIHFQUFAkJ11QJCdmJCpfJDB4JDB7JDFPJDF9JDJRJDJYJDJhUCQyZyQyalAkM1ckM1skNFMkNWIkNWckNX1QUCQ2UyQ2WSQ2XiQ2YSQ2ZSQ2aSQ3ZSQ3fCQ4ZSQ4aSQ4bCQ4byQ4eSQ4fCQ5USQ5VVIhfFJvcU9Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfWSF2USdgLWUxbzV7USV0dlElfHlRJlR8USZqIVZTJ1chZS1dUSdmIWlTJ2whciF5VSprJHwqWipvUStvJX1TK3wmViZXUSxkJmRRLWMnX1EtbSdnUS11J21RMFsqcVExYixPUTF5LGVSPHs8WSVTZE9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJnImdCZ1JncmeydUJ2IncihUKFYoXShkKHgoeilPKX0qaStYK10scCxzLHgtaS1xLlAuVi50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czbDR6NlQ2ZTZmNmk2fDh0OVQ5X1MjcV08ViFyKV8kWiRuJ1gpcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1UrUCVdPHM8dFErdCZQUSxmJmdRLG0mb1EweCtnUTB9K2lRMVkrdVEyUixrUTNgLmdRNWAwfFE1ZjFUUTZbMXpRN1kzZFE4YDVnUjllN1snUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlMhUyFuUSFyIXYheSF6JHwnVydfJ2AnbCdtJ24qaypvKnEqci1dLWMtZS11MFswXzFvNXs1fSVbJHRpI3YkYiRjJGQkeCR7JU8lUSVeJV8lYyl5KlIqVCpWKlkqYSpnKncqeCtmK2ksUyxWLmYvUC9kL20veC95L3swYDBiMGkwajBvMWYxaTFxM2M0XjRfNGo0bzVRNVs1XzZTN1c3djhROFY4WzhxOWI5cDl5OlA6YDpyO1E7WztkO2s8bDxtPG88cDxxPHI8dTx2PHc8eDx5PHo9Uz1UPVU9Vj1YPVk9XT1ePV89YD1hPWI9Yz1kPWc9aD5QPlg+WT5dPl5RJlh8USdVIWVTJ1slaS1gUSt0JlBRLFAmV1EsZiZnUTBuK1NRMVkrdVExXyt7UTJRLGpRMlIsa1E1ZjFUUTVvMWFRNlsxelE2XzF8UTZgMlBROGA1Z1E4YzVsUTh8NmJROlg4ZFE6Zjh5UTtWOllSPH0qWnJuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUixoJmsmel5PUFhZc3R1dnd6IVohYCFnIWohbyNTI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+Uj5TWyNdV1ojVyNaJ1goVCFiJWptI2gjaSNsJHglZSVoKF4oaChpKGoqWSpeKmIrWitbK14sby1WLlQuWi5bLl0uXy9tL3AyZDNbM100YTZyN1RRJXd4USV7eVcmUXwmViZXLE9RJl8hVFEnYyFoUSdlIWlRKHEjc1MrbiV8JX1RK3ImUFEsXyZiUSxjJmRTLWwnZidnUS5pKHJRMVIrb1ExWCt1UTFaK3ZRMV4relExdCxgUzF4LGQsZVEyfC1tUTVlMVRRNWkxV1E1bjFgUTZaMXlROF81Z1E4YjVrUThmNXBROlQ4XlI7VDpVIVUkemkkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WSFeJXl5IWkhdSV7JXwlfSdWJ2UnZidnJ2sndSpqK24rby1ZLWwtbS10MFIwVTFSMnUyfDNUNHI0czR2N305e1EraCV3USxUJltRLFcmXVEsYiZkUS5oKHFRMXMsX1UxdyxjLGQsZVEzZS5pUTZVMXRTNlkxeDF5UTh4NlojZj5UI3YkYiRjJHgkeyl5KlYqWSpnK2YraSxTLFYuZi9kL20veS97MWYxaTFxM2M0XjRqNG81WzVfNlM3Vzd2OFE4WzhxOWI5eTpQOmA6cjtRO1s7ZDtrPG88cTx1PHc8eT1TPVU9WD1dPV89YT1jPWc+XT5ebz5VPGw8bTxwPHI8djx4PHo9VD1WPVk9Xj1gPWI9ZD1oVyVUaSVWKnk+UFMmWyFRJmlRJl0hUlEmXiFTVSp9JVslZD1zUixSJlklXSVTaSN2JGIkYyRkJHgkeyVPJVElXiVfJWMpeSpSKlQqVipZKmEqZyp3KngrZitpLFMsVi5mL1AvZC9tL3gveS97MGAwYjBpMGowbzFmMWkxcTNjNF40XzRqNG81UTVbNV82UzdXN3Y4UThWOFs4cTliOXA5eTpQOmA6cjtRO1s7ZDtrPGw8bTxvPHA8cTxyPHU8djx3PHg8eTx6PVM9VD1VPVY9WD1ZPV09Xj1fPWA9YT1iPWM9ZD1nPWg+UD5YPlk+XT5eVCl6JHUpe1YrUCVdPHM8dFcnWyFlJWkqWi1gUyh9I3kjelErYyVyUSt5JlNTLmIobShuUTFqLFhRNVQwa1I4aTV1J1FrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TJGkkXmMjWSNlJXElcyV1KFMoWSh0KHkpUilTKVQpVSlWKVcpWClZKVopWyleKWApYilnKXErZCt4LVoteC19LlMuVS5zLnYuei58Ln0vTy9iMHAyazJuM08zVjNrM3AzcTNyM3MzdDN1M3YzdzN4M3kzejN7M3w0UDRRNFg1WDVjNnU2ezdRN2E3YjdrN2w4azlYOV05ZzltOW46bztXO2A8Vz12VCNUViNVJ1JrT1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4lbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnWCdiJ3IoVChWKF0oZCh4KHopTylzKX0qaStYK10rZyxwLHMseC1VLVgtaS1xLlAuVi5nLnQuey9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUSdZIWVSMnEtXSFXIW5RIWUhciF2IXkheiR8J1cnXydgJ2wnbSduKloqaypvKnEqci1dLWMtZS11MFswXzFvNXs1fVIxbCxabnFPWHN0IVojZCVtJnImdCZ1Jncscyx4MlsyX1EmeSFeUSd2IXhTKHMjdTxeUStsJXpRLF0mX1EsXiZhUS1qJ2RRLXcnb1Mucih4PVBTMHErWD1aUTFQK21RMW4sW1EyYyx6UTJlLHtRMm0tV1Eyei1rUTJ9LW9TNVkwcj1lUTVhMVFTNWQxUz1mUTZ0Mm9RNngye1E2fTNTUThdNWJROVk2dlE5WjZ5UTleN09SOmw5ViRkJF1jI1kjZSVzJXUoUyhZKHQoeSlSKVMpVClVKVYpVylYKVkpWilbKV4pYCliKWcpcStkK3gtWi14LX0uUy5VLnMudi56Ln0vTy9iMHAyazJuM08zVjNrM3AzcTNyM3MzdDN1M3YzdzN4M3kzejN7M3w0UDRRNFg1WDVjNnU2ezdRN2E3YjdrN2w4azlYOV05ZzltOW46bztXO2A8Vz12UyhvI3AnaVEpUCN6UytiJXEufFMuYyhuKHBSM14uZCdRa09QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWiRfJGEkZSRuJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1MjcV08VlEmdCFYUSZ1IVlRJnchW1EmeCFdUjJaLHZRJ2EhaFErZSV3US1oJ2NTLmUocStoUTJ4LWdXM2IuaC5pMHcweVE2dzJ5VzdVM18zYTNlNV5VOWE3VjdYN1pVOnE5YzlkOWZTO2I6cDpzUTtwO2NSO3g7cVUhd1EnYC1lVDV5MW81eyFRX09YWmBzdCFWIVojZCNoJWUlbSZpJmsmciZ0JnUmdyhqLHMseC5bMlsyX10hcFEhcidgLWUxbzV7VCNxXTxWJV57T1BXWFlac3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRfJGEkZSVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1MofSN5I3pTLmIobShuIXM9bCRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVSRmZClfLG1TKHAjcCdpVSp2JVIodzRPVTBtK08ubjdnUTVeMHhRN1YzYFE5ZDdZUjpzOWVtIXRRIXIhdiF5IXonYCdsJ20nbi1lLXUxbzV7NX1RJ3QhdVMoZiNnMlVTLXMnayd3US9zKl1RMFIqalEzVS12UTRmL3RRNHIwVFE0czBVUTR4MF5RN3I0YFM3fTR0NHZTOFI0eTR7UTlyN3NROXY3eVE5ezhPUTpROFRTOns5dzl4UztnOnw7UFM7cztoO2lTO3s7dDt1UzxQO3w7fVI8UzxRUSN3YlEncyF1UyhlI2cyVVMoZyNtK1dRK1klZlEraiV4UStwJk9VLXInayd0J3dRLlcoZlUvcipdKmAvd1EwUypqUTBWKmxRMU8ra1ExdSxhUzNSLXMtdlEzWi5gUzRlL3MvdFE0bjBQUzRxMFIwXlE0dTBXUTZXMXZRN1AzVVM3cTRgNGJRN3U0ZlU3fDRyNHg0e1E4UDR3UTh2NlhTOXE3cjdzUTl1N3lROX04UlE6TzhTUTpjOHdROnk5clM6ejl2OXhRO1M6UVE7XjpkUztmOns7UFM7cjtnO2hTO3o7czt1UzxPO3s7fVE8UjxQUTxUPFNRPW89alE9ez10Uj18PXVWIXdRJ2AtZSVeYU9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXStnLHAscyx4LWktcS5QLlYuZy50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czZDNsNHo2VDZlNmY2aTZ8N1s4dDlUOV9TI3d6IWohcj1pJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNSPW8+UiVeYk9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXStnLHAscyx4LWktcS5QLlYuZy50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czZDNsNHo2VDZlNmY2aTZ8N1s4dDlUOV9RJWZqIV4leHkhaSF1JXslfCV9J1YnZSdmJ2cnayd1KmorbitvLVktbC1tLXQwUjBVMVIydTJ8M1Q0cjRzNHY3fTl7UyZPeiFqUStrJXlRLGEmZFcxdixiLGMsZCxlVTZYMXcxeDF5Uzh3Nlk2WlE6ZDh4IXI9aiRaJG4nWClzLVUtWC9WMnA0VDV3NnM6WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TUT10PlFSPXU+UiVRZU9QWFlzdHV2dyFaIWAhZyFvI1MjZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJnImdCZ1JncmeydUJ2IncihWKF0oZCh4KHopTyl9KmkrWCtdK2cscCxzLHgtaS1xLlAuVi5nLnQuey9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhM1EzVzNkM2w0ejZUNmU2ZjZpNnw3Wzh0OVQ5X1kjYldaI1cjWihUIWIlam0jaCNpI2wkeCVlJWgoXihoKGkoaipZKl4qYitaK1srXixvLVYuVC5aLlsuXS5fL20vcDJkM1szXTRhNnI3VFEsbiZvIXA9ayRaJG4pcy1VLVgvVjJwNFQ1dzZzOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1I9bidYVSddIWUlaSpaUjJzLWAlU2RPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJF8kYSRlJW0ldCZSJmsmbiZyJnQmdSZ3JnsnVCdiJ3IoVChWKF0oZCh4KHopTyl9KmkrWCtdLHAscyx4LWktcS5QLlYudC57L24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEzUTNXM2w0ejZUNmU2ZjZpNnw4dDlUOV8hcilfJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNRLG0mb1EweCtnUTNgLmdRN1kzZFI5ZTdbIWIkVGMjWSVxKFMoWSh0KHkpWilbKWApZyt4LXgtfS5TLlUucy52L2IwcDNPM1YzazN7NVg1YzZ7N1E3YTldOm88VyFQPGQpXilxLVoufDJrMm4zcDN5M3o0UDRYNnU3YjdrN2w4azlYOWc5bTluO1c7YD12IWYkVmMjWSVxKFMoWSh0KHkpVylYKVopWylgKWcreC14LX0uUy5VLnMudi9iMHAzTzNWM2szezVYNWM2ezdRN2E5XTpvPFchVDxmKV4pcS1aLnwyazJuM3AzdjN3M3kzejRQNFg2dTdiN2s3bDhrOVg5ZzltOW47VztgPXYhXiRaYyNZJXEoUyhZKHQoeSlgKWcreC14LX0uUy5VLnMudi9iMHAzTzNWM2szezVYNWM2ezdRN2E5XTpvPFdRNF8va3o+UyleKXEtWi58MmsybjNwNFA0WDZ1N2I3azdsOGs5WDlnOW05bjtXO2A9dlE+WD5aUj5ZPlsnUWtPUFdYWVpzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1YvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTJwM1EzVzNkM2w0VDR6NXc2VDZlNmY2aTZzNnw3Wzh0OVQ5XzpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlNTJG9oJHBSNFUvVSdYZ09QV1hZWmhzdHV2dyFaIWAhZyFvI1MjVyNaI2QjbyN1I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFokXyRhJGUkbiRwJW0ldCZSJmsmbiZvJnImdCZ1JncmeydUJ1gnYidyKFQoVihdKGQoeCh6KU8pcyl9KmkrWCtdK2cscCxzLHgtVS1YLWktcS5QLlYuZy50LnsvVS9WL24wXTBsMHIxUzFyMlMyVDJWMlgyWzJfMmEycDNRM1czZDNsNFQ0ejV3NlQ2ZTZmNmk2czZ8N1s4dDlUOV86WjptPFU8WDxZPF08XjxfPGA8YTxiPGM8ZDxlPGY8ZzxoPGk8azxuPHs9Tz1QPVI9Wj1bPWU9Zj5TVCRrZiRxUSRpZlMpaiRsKW5SKXYkcVQkamYkcVQpbCRsKW4nWGhPUFdYWVpoc3R1dnchWiFgIWchbyNTI1cjWiNkI28jdSN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRaJF8kYSRlJG4kcCVtJXQmUiZrJm4mbyZyJnQmdSZ3JnsnVCdYJ2IncihUKFYoXShkKHgoeilPKXMpfSppK1grXStnLHAscyx4LVUtWC1pLXEuUC5WLmcudC57L1UvVi9uMF0wbDByMVMxcjJTMlQyVjJYMlsyXzJhMnAzUTNXM2QzbDRUNHo1dzZUNmU2ZjZpNnM2fDdbOHQ5VDlfOlo6bTxVPFg8WTxdPF48XzxgPGE8YjxjPGQ8ZTxmPGc8aDxpPGs8bjx7PU89UD1SPVo9Wz1lPWY+U1Qkb2gkcFEkcmhSKXUkcCVeak9QV1hZWnN0dXZ3IVohYCFnIW8jUyNXI1ojZCNvI3UjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkXyRhJGUlbSV0JlImayZuJm8mciZ0JnUmdyZ7J1QnYidyKFQoVihdKGQoeCh6KU8pfSppK1grXStnLHAscyx4LWktcS5QLlYuZy50LnsvbjBdMGwwcjFTMXIyUzJUMlYyWDJbMl8yYTNRM1czZDNsNHo2VDZlNmY2aTZ8N1s4dDlUOV8hcz5RJFokbidYKXMtVS1YL1YycDRUNXc2czpaOm08VTxYPFk8XTxePF88YDxhPGI8YzxkPGU8ZjxnPGg8aTxrPG48ez1PPVA9Uj1aPVs9ZT1mPlMjZ2xPUFhac3QhWiFgIW8jUyNkI28jeyRuJW0mayZuJm8mciZ0JnUmdyZ7J1QnYilPKXMqaStdK2cscCxzLHgtaS5nL1YvbjBdMGwxcjJTMlQyVjJYMlsyXzJhM2Q0VDR6NlQ2ZTZmNmk3Wzh0OVQhVSVSaSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZI2YodyN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+XlErVCVhUS9jKk9vNE88bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWghVSR5aSRkJU8lUSVeJV8lYypSKlQqYSp3KngvUC94MGAwYjBpMGowbzRfNVE4VjlwPlA+WD5ZUSpjJHpVKmwkfCpaKm9RK1UlYlEwVyptI2Y9cSN2JGIkYyR4JHspeSpWKlkqZytmK2ksUyxWLmYvZC9tL3kvezFmMWkxcTNjNF40ajRvNVs1XzZTN1c3djhROFs4cTliOXk6UDpgOnI7UTtbO2Q7azxvPHE8dTx3PHk9Uz1VPVg9XT1fPWE9Yz1nPl0+Xm49cjxsPG08cDxyPHY8eDx6PVQ9Vj1ZPV49YD1iPWQ9aFE9dz5UUT14PlVRPXk+VlI9ej5XIVUlUmkkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WSNmKHcjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5vNE88bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWhub09Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfUypmJHsqWVEtUidPUS1TJ1FSNGkveSVbJVNpI3YkYiRjJGQkeCR7JU8lUSVeJV8lYyl5KlIqVCpWKlkqYSpnKncqeCtmK2ksUyxWLmYvUC9kL20veC95L3swYDBiMGkwajBvMWYxaTFxM2M0XjRfNGo0bzVRNVs1XzZTN1c3djhROFY4WzhxOWI5cDl5OlA6YDpyO1E7WztkO2s8bDxtPG88cDxxPHI8dTx2PHc8eDx5PHo9Uz1UPVU9Vj1YPVk9XT1ePV89YD1hPWI9Yz1kPWc9aD5QPlg+WT5dPl5RLFUmXVExaCxXUTVzMWdSOGg1dFYqbiR8Kloqb1UqbiR8Kloqb1Q1ejFvNXtTMFAqaS9uUTR3MF1UOFM0ejpdUStqJXhRMFYqbFExTytrUTF1LGFRNlcxdlE4djZYUTpjOHdSO146ZCFVJU9pJGQlTyVRJV4lXyVjKlIqVCphKncqeC9QL3gwYDBiMGkwajBvNF81UThWOXA+UD5YPll4KlIkdillKlMqdStWL3YwZDBlNFI0ZzVSNVM1VzdwOFU6Ujp4PXA9fT5PUzBgKnQwYSNmPG8jdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5uPHA8bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWghZD1TKHUpYypbKmUuai5tLnEvXy9rL3wwdjFlM2g0WzRoNGw1cjddN2A3dzd6OFg4Wjl0OXw6Uzp9O1I7ZTtqO3Y+Wj5bYD1UM303YzdmN2o5aDp0Onc7eVM9Xy5sM2lUPWA3ZTlrIVUlUWkkZCVPJVElXiVfJWMqUipUKmEqdyp4L1AveDBgMGIwaTBqMG80XzVROFY5cD5QPlg+WXwqVCR2KWUqVSp0K1YvZy92MGQwZTRSNGc0fDVSNVM1VzdwOFU6Ujp4PXA9fT5PUzBiKnUwYyNmPHEjdiRiJGMkeCR7KXkqVipZKmcrZitpLFMsVi5mL2QvbS95L3sxZjFpMXEzYzReNGo0bzVbNV82UzdXN3Y4UThbOHE5Yjl5OlA6YDpyO1E7WztkO2s8bzxxPHU8dzx5PVM9VT1YPV09Xz1hPWM9Zz5dPl5uPHI8bDxtPHA8cjx2PHg8ej1UPVY9WT1ePWA9Yj1kPWghaD1VKHUpYypbKmUuay5sLnEvXy9rL3wwdjFlM2YzaDRbNGg0bDVyN103XjdgN3c3ejhYOFo5dDl8OlM6fTtSO2U7ajt2Plo+W2Q9VjN9N2Q3ZTdqOWg5aTp0OnU6dzt5Uz1hLm0zalQ9YjdmOWxybk9Yc3QhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1EmZiFVUixwJm9ybk9Yc3QhViFaI2QlbSZpJnImdCZ1Jncscyx4MlsyX1ImZiFVUSxZJl5SMWQsUnNuT1hzdCFWIVojZCVtJmkmciZ0JnUmdyxzLHgyWzJfUTFwLF9TNlIxczF0VThwNlA2UTZVUzpfOHI4c1M7WTpeOmFRO207WlI7dztuUSZtIVZSLGkmaVI2XzF8UjpmOHlXJlF8JlYmVyxPUjFaK3ZRJnIhV1IscyZzUix5JnhUMl0seDJfUix9JnlRLHwmeVIyZix9USd5IXtSLXkneVNzT3RRI2RYVCVwcyNkUSNPVFIneyNPUSNSVVInfSNSUSl7JHVSL2Ape1EjVVZSKFEjVVEjWFdVKFcjWChYLlFRKFgjWVIuUShZUS1eJ1lSMnItXlEudSh5UzNtLnUzblIzbi52US1lJ2BSMnYtZVkhclEnYC1lMW81e1InaiFyUS9RKWVSNFMvUVUjX1claCpZVShfI18oYC5SUShgI2BSLlIoWlEtYSddUjJ0LWF0YE9Yc3QhViFaI2QlbSZpJmsmciZ0JnUmdyxzLHgyWzJfUyNoWiVlVSNyYCNoLltSLlsoalEoayNqUS5YKGdXLmEoay5YM1g3UlEzWC5ZUjdSM1lRKW4kbFIvVyluUSRwaFIpdCRwUSRgY1UpYSRgLXw8alEtfDxXUjxqKXFRL3EqXVc0Yy9xNGQ3dDlzVTRkL3Ivcy90Uzd0NGU0ZlI5czd1JGUqUSR2KHUpYyllKlsqZSp0KnUrUStSK1YubC5tLm8ucC5xL18vZy9pL2svdi98MGQwZTB2MWUzZjNnM2gzfTRSNFs0ZzRoNGw0fDVPNVI1UzVXNXI3XTdeN183YDdlN2Y3aDdpN2o3cDd3N3o4VThYOFo5aDlpOWo5dDl8OlI6Uzp0OnU6djp3Ong6fTtSO2U7ajt2O3k9cD19Pk8+Wj5bUS96KmVVNGsvejRtN3hRNG0vfFI3eDRsUypvJHwqWlIwWSpveCpTJHYpZSp0KnUrVi92MGQwZTRSNGc1UjVTNVc3cDhVOlI6eD1wPX0+TyFkLmoodSljKlsqZS5sLm0ucS9fL2svfDB2MWUzaDRbNGg0bDVyN103YDd3N3o4WDhaOXQ5fDpTOn07UjtlO2o7dj5aPltVL2gqUy5qN2NhN2MzfTdlN2Y3ajloOnQ6dzt5UTBhKnRRM2kubFU0fTBhM2k5a1I5azdlfCpVJHYpZSp0KnUrVi9nL3YwZDBlNFI0ZzR8NVI1UzVXN3A4VTpSOng9cD19Pk8haC5rKHUpYypbKmUubC5tLnEvXy9rL3wwdjFlM2YzaDRbNGg0bDVyN103XjdgN3c3ejhYOFo5dDl8OlM6fTtSO2U7ajt2Plo+W1UvaipVLms3ZGU3ZDN9N2U3ZjdqOWg5aTp0OnU6dzt5UTBjKnVRM2oubVU1UDBjM2o5bFI5bDdmUSp6JVVSMGcqelE1XTB2UjhZNV1RK18la1IwdStfUTV2MWpTOGo1djpbUjpbOGtRLFsmX1IxbSxbUTV7MW9SOG01e1ExeyxmUzZdMXs4elI4ejZfUTFVK3JXNWgxVTVqOGE6VlE1ajFYUThhNWlSOlY4YlErdyZRUjFbK3dRMl8seFI2bTJfWXJPWHN0I2RRJnYhWlErYSVtUSxyJnJRLHQmdFEsdSZ1USx3JndRMlksc1MyXSx4Ml9SNmwyW1Elb3BRJnohX1EmfSFhUSdQIWJRJ1IhY1EncSF1UStgJWxRK2wlelEsUSZYUSxoJm1RLVAmfFctcCdrJ3MndCd3US13J29RMFgqblExUCttUTFjLFBTMk8saSxsUTJnLU9RMmgtUlEyaS1TUTJ9LW9XM1Atci1zLXYteFE1YTFRUTVtMV9RNXExZVE2VjF1UTZhMlFRNmsyWlU2ejNPM1IzVVE2fTNTUThdNWJROGU1b1E4ZzVyUThsNXpROHU2V1E4ezZgUzlbNns3UFE5XjdPUTpXOGNROmI4dlE6Zzh8UTpuOV1RO1U6WFE7XTpjUTthOm9RO2w7VlI7bzteUSV6eVEnZCFpUSdvIXVVK20leyV8JX1RLVcnVlUtaydlJ2YnZ1MtbydrJ3VRMFEqalMxUStuK29RMm8tWVMyey1sLW1RM1MtdFM0cDBSMFVRNWIxUlE2djJ1UTZ5MnxRN08zVFU3ezRyNHM0dlE5ejd9UjtPOXtTJHdpPlBSKnslVlUlVWklVj5QUjBmKnlRJHZpUyh1I3YraVMpYyRiJGNRKWUkZFEqWyR4UyplJHsqWVEqdCVPUSp1JVFRK1ElXlErUiVfUStWJWNRLmw8b1EubTxxUS5vPHVRLnA8d1EucTx5US9fKXlRL2cqUlEvaSpUUS9rKlZRL3YqYVMvfCpnL21RMGQqd1EwZSp4bDB2K2YsVi5mMWkxcTNjNlM3VzhxOWI6YDpyO1s7ZFExZSxTUTNmPVNRM2c9VVEzaD1YUzN9PGw8bVE0Ui9QUzRbL2Q0XlE0Zy94UTRoL3lRNGwve1E0fDBgUTVPMGJRNVIwaVE1UzBqUTVXMG9RNXIxZlE3XT1dUTdePV9RN189YVE3YD1jUTdlPHBRN2Y8clE3aDx2UTdpPHhRN2o8elE3cDRfUTd3NGpRN3o0b1E4VTVRUThYNVtROFo1X1E5aD1ZUTlpPVRROWo9VlE5dDd2UTl8OFFROlI4VlE6UzhbUTp0PV5ROnU9YFE6dj1iUTp3PWRROng5cFE6fTl5UTtSOlBRO2U9Z1E7ajtRUTt2O2tRO3k9aFE9cD5QUT19PlhRPk8+WVE+Wj5dUj5bPl5RK08lXVEubjxzUjdnPHRucE9Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfUSFmUFMjZlojb1EmfCFgVydoIW8qaTBdNHpRKFAjU1EpUSN7USlyJG5TLGwmayZuUSxxJm9RLU8me1MtVCdUL25RLWcnYlEueClPUS9bKXNRMHMrXVEweStnUTJXLHBRMnktaVEzYS5nUTRXL1ZRNVUwbFE2UTFyUTZjMlNRNmQyVFE2aDJWUTZqMlhRNm8yYVE3WjNkUTdtNFRROHM2VFE5UDZlUTlRNmZROVM2aVE5ZjdbUTphOHRSOms5VCNbY09QWFpzdCFaIWAhbyNkI28jeyVtJmsmbiZvJnImdCZ1JncmeydUJ2IpTyppK10rZyxwLHMseC1pLmcvbjBdMGwxcjJTMlQyVjJYMlsyXzJhM2Q0ejZUNmU2ZjZpN1s4dDlUUSNZV1EjZVlRJXF1USVzdlMldXchZ1MoUyNXKFZRKFkjWlEodCN1USh5I3hRKVIkT1EpUyRQUSlUJFFRKVUkUlEpViRTUSlXJFRRKVgkVVEpWSRWUSlaJFdRKVskWFEpXiRaUSlgJF9RKWIkYVEpZyRlVylxJG4pcy9WNFRRK2QldFEreCZSUy1aJ1gycFEteCdyUy19KFQuUFEuUyhdUS5VKGRRLnMoeFEudih6US56PFVRLnw8WFEufTxZUS9PPF1RL2IpfVEwcCtYUTJrLVVRMm4tWFEzTy1xUTNWLlZRM2sudFEzcDxeUTNxPF9RM3I8YFEzczxhUTN0PGJRM3U8Y1EzdjxkUTN3PGVRM3g8ZlEzeTxnUTN6PGhRM3sue1EzfDxrUTRQPG5RNFE8e1E0WDxpUTVYMHJRNWMxU1E2dT1PUTZ7M1FRN1EzV1E3YTNsUTdiPVBRN2s9UlE3bD1aUThrNXdROVg2c1E5XTZ8UTlnPVtROW09ZVE5bj1mUTpvOV9RO1c6WlE7YDptUTxXI1NSPXY+U1IjW1dSJ1ohZWwhdFEhciF2IXkheidgJ2wnbSduLWUtdTFvNXs1fVMnViFlLV1VKmokfCpaKm9TLVknVydfUzBVKmsqcVEwXipyUTJ1LWNRNHYwW1I0ezBfUih7I3hRIWZRVC1kJ2AtZV0hcVEhcidgLWUxbzV7USNwXVInaTxWUilmJGRZIXVRJ2AtZTFvNXtRJ2shclMndSF2IXlTJ3chejV9Uy10J2wnbVEtdiduUjNULXVUI2taJWVTI2paJWVTJWttLG9VKGcjaCNpI2xTLlkoaChpUS5eKGpRMHQrXlEzWS5aVTNaLlsuXS5fUzdTM1szXVI5YDdUZCNeVyNXI1olaChUKF4qWStaLlQvbXIjZ1ptI2gjaSNsJWUoaChpKGorXi5aLlsuXS5fM1szXTdUUypdJHgqYlEvdCpeUTJVLG9RMmwtVlE0YC9wUTZxMmRRN3M0YVE5VzZyVD1tJ1grW1YjYVclaCpZVSNgVyVoKllTKFUjVyheVShaI1orWi9tUy1bJ1grW1QuTyhULlRWJ14hZSVpKlpRJGxmUil4JHFUKW0kbCluUjRWL1VUKl8keCpiVCpoJHsqWVEwdytmUTFnLFZRM18uZlE1dDFpUTZQMXFRN1gzY1E4cjZTUTljN1dROl44cVE6cDliUTtaOmBRO2M6clE7bjtbUjtxO2RucU9Yc3QhWiNkJW0mciZ0JnUmdyxzLHgyWzJfUSZsIVZSLGgmaXRtT1hzdCFVIVYhWiNkJW0maSZyJnQmdSZ3LHMseDJbMl9SLG8mb1QlbG0sb1IxayxYUixnJmdRJlV8Uyt9JlYmV1IxXixPUitzJlBUJnAhVyZzVCZxIVcmc1QyXix4Ml9cIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBBcml0aE9wIEFyaXRoT3AgPy4gSlNYU3RhcnRUYWcgTGluZUNvbW1lbnQgQmxvY2tDb21tZW50IFNjcmlwdCBIYXNoYmFuZyBFeHBvcnREZWNsYXJhdGlvbiBleHBvcnQgU3RhciBhcyBWYXJpYWJsZU5hbWUgU3RyaW5nIEVzY2FwZSBmcm9tIDsgZGVmYXVsdCBGdW5jdGlvbkRlY2xhcmF0aW9uIGFzeW5jIGZ1bmN0aW9uIFZhcmlhYmxlRGVmaW5pdGlvbiA+IDwgVHlwZVBhcmFtTGlzdCBpbiBvdXQgY29uc3QgVHlwZURlZmluaXRpb24gZXh0ZW5kcyBUaGlzVHlwZSB0aGlzIExpdGVyYWxUeXBlIEFyaXRoT3AgTnVtYmVyIEJvb2xlYW5MaXRlcmFsIFRlbXBsYXRlVHlwZSBJbnRlcnBvbGF0aW9uRW5kIEludGVycG9sYXRpb24gSW50ZXJwb2xhdGlvblN0YXJ0IE51bGxUeXBlIG51bGwgVm9pZFR5cGUgdm9pZCBUeXBlb2ZUeXBlIHR5cGVvZiBNZW1iZXJFeHByZXNzaW9uIC4gUHJvcGVydHlOYW1lIFsgVGVtcGxhdGVTdHJpbmcgRXNjYXBlIEludGVycG9sYXRpb24gc3VwZXIgUmVnRXhwIF0gQXJyYXlFeHByZXNzaW9uIFNwcmVhZCAsIH0geyBPYmplY3RFeHByZXNzaW9uIFByb3BlcnR5IGFzeW5jIGdldCBzZXQgUHJvcGVydHlEZWZpbml0aW9uIEJsb2NrIDogTmV3VGFyZ2V0IG5ldyBOZXdFeHByZXNzaW9uICkgKCBBcmdMaXN0IFVuYXJ5RXhwcmVzc2lvbiBkZWxldGUgTG9naWNPcCBCaXRPcCBZaWVsZEV4cHJlc3Npb24geWllbGQgQXdhaXRFeHByZXNzaW9uIGF3YWl0IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIENsYXNzRXhwcmVzc2lvbiBjbGFzcyBDbGFzc0JvZHkgTWV0aG9kRGVjbGFyYXRpb24gRGVjb3JhdG9yIEAgTWVtYmVyRXhwcmVzc2lvbiBQcml2YXRlUHJvcGVydHlOYW1lIENhbGxFeHByZXNzaW9uIFR5cGVBcmdMaXN0IENvbXBhcmVPcCA8IGRlY2xhcmUgUHJpdmFjeSBzdGF0aWMgYWJzdHJhY3Qgb3ZlcnJpZGUgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbiBQcm9wZXJ0eURlY2xhcmF0aW9uIHJlYWRvbmx5IGFjY2Vzc29yIE9wdGlvbmFsIFR5cGVBbm5vdGF0aW9uIEVxdWFscyBTdGF0aWNCbG9jayBGdW5jdGlvbkV4cHJlc3Npb24gQXJyb3dGdW5jdGlvbiBQYXJhbUxpc3QgUGFyYW1MaXN0IEFycmF5UGF0dGVybiBPYmplY3RQYXR0ZXJuIFBhdHRlcm5Qcm9wZXJ0eSBQcml2YWN5IHJlYWRvbmx5IEFycm93IE1lbWJlckV4cHJlc3Npb24gQmluYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEJpdE9wIENvbXBhcmVPcCBpbnN0YW5jZW9mIHNhdGlzZmllcyBDb21wYXJlT3AgQml0T3AgQml0T3AgQml0T3AgTG9naWNPcCBMb2dpY09wIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBMb2dpY09wIExvZ2ljT3AgQXNzaWdubWVudEV4cHJlc3Npb24gVXBkYXRlT3AgUG9zdGZpeEV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gSW5zdGFudGlhdGlvbkV4cHJlc3Npb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIER5bmFtaWNJbXBvcnQgaW1wb3J0IEltcG9ydE1ldGEgSlNYRWxlbWVudCBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYU2VsZkNsb3NpbmdUYWcgSlNYSWRlbnRpZmllciBKU1hCdWlsdGluIEpTWElkZW50aWZpZXIgSlNYTmFtZXNwYWNlZE5hbWUgSlNYTWVtYmVyRXhwcmVzc2lvbiBKU1hTcHJlYWRBdHRyaWJ1dGUgSlNYQXR0cmlidXRlIEpTWEF0dHJpYnV0ZVZhbHVlIEpTWEVzY2FwZSBKU1hFbmRUYWcgSlNYT3BlblRhZyBKU1hGcmFnbWVudFRhZyBKU1hUZXh0IEpTWEVzY2FwZSBKU1hTdGFydENsb3NlVGFnIEpTWENsb3NlVGFnIFByZWZpeENhc3QgPCBBcnJvd0Z1bmN0aW9uIFR5cGVQYXJhbUxpc3QgU2VxdWVuY2VFeHByZXNzaW9uIEluc3RhbnRpYXRpb25FeHByZXNzaW9uIEtleW9mVHlwZSBrZXlvZiBVbmlxdWVUeXBlIHVuaXF1ZSBJbXBvcnRUeXBlIEluZmVycmVkVHlwZSBpbmZlciBUeXBlTmFtZSBQYXJlbnRoZXNpemVkVHlwZSBGdW5jdGlvblNpZ25hdHVyZSBQYXJhbUxpc3QgTmV3U2lnbmF0dXJlIEluZGV4ZWRUeXBlIFR1cGxlVHlwZSBMYWJlbCBBcnJheVR5cGUgUmVhZG9ubHlUeXBlIE9iamVjdFR5cGUgTWV0aG9kVHlwZSBQcm9wZXJ0eVR5cGUgSW5kZXhTaWduYXR1cmUgUHJvcGVydHlEZWZpbml0aW9uIENhbGxTaWduYXR1cmUgVHlwZVByZWRpY2F0ZSBhc3NlcnRzIGlzIE5ld1NpZ25hdHVyZSBuZXcgVW5pb25UeXBlIExvZ2ljT3AgSW50ZXJzZWN0aW9uVHlwZSBMb2dpY09wIENvbmRpdGlvbmFsVHlwZSBQYXJhbWV0ZXJpemVkVHlwZSBDbGFzc0RlY2xhcmF0aW9uIGFic3RyYWN0IGltcGxlbWVudHMgdHlwZSBWYXJpYWJsZURlY2xhcmF0aW9uIGxldCB2YXIgdXNpbmcgVHlwZUFsaWFzRGVjbGFyYXRpb24gSW50ZXJmYWNlRGVjbGFyYXRpb24gaW50ZXJmYWNlIEVudW1EZWNsYXJhdGlvbiBlbnVtIEVudW1Cb2R5IE5hbWVzcGFjZURlY2xhcmF0aW9uIG5hbWVzcGFjZSBtb2R1bGUgQW1iaWVudERlY2xhcmF0aW9uIGRlY2xhcmUgR2xvYmFsRGVjbGFyYXRpb24gZ2xvYmFsIENsYXNzRGVjbGFyYXRpb24gQ2xhc3NCb2R5IEFtYmllbnRGdW5jdGlvbkRlY2xhcmF0aW9uIEV4cG9ydEdyb3VwIFZhcmlhYmxlTmFtZSBWYXJpYWJsZU5hbWUgSW1wb3J0RGVjbGFyYXRpb24gZGVmZXIgSW1wb3J0R3JvdXAgRm9yU3RhdGVtZW50IGZvciBGb3JTcGVjIEZvckluU3BlYyBGb3JPZlNwZWMgb2YgV2hpbGVTdGF0ZW1lbnQgd2hpbGUgV2l0aFN0YXRlbWVudCB3aXRoIERvU3RhdGVtZW50IGRvIElmU3RhdGVtZW50IGlmIGVsc2UgU3dpdGNoU3RhdGVtZW50IHN3aXRjaCBTd2l0Y2hCb2R5IENhc2VMYWJlbCBjYXNlIERlZmF1bHRMYWJlbCBUcnlTdGF0ZW1lbnQgdHJ5IENhdGNoQ2xhdXNlIGNhdGNoIEZpbmFsbHlDbGF1c2UgZmluYWxseSBSZXR1cm5TdGF0ZW1lbnQgcmV0dXJuIFRocm93U3RhdGVtZW50IHRocm93IEJyZWFrU3RhdGVtZW50IGJyZWFrIENvbnRpbnVlU3RhdGVtZW50IGNvbnRpbnVlIERlYnVnZ2VyU3RhdGVtZW50IGRlYnVnZ2VyIExhYmVsZWRTdGF0ZW1lbnQgRXhwcmVzc2lvblN0YXRlbWVudCBTaW5nbGVFeHByZXNzaW9uIFNpbmdsZUNsYXNzSXRlbVwiLFxuICBtYXhUZXJtOiAzODAsXG4gIGNvbnRleHQ6IHRyYWNrTmV3bGluZSxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiaXNvbGF0ZVwiLCAtOCw1LDYsMTQsMzcsMzksNTEsNTMsNTUsXCJcIl0sXG4gICAgW1wiZ3JvdXBcIiwgLTI2LDksMTcsMTksNjgsMjA3LDIxMSwyMTUsMjE2LDIxOCwyMjEsMjI0LDIzNCwyMzcsMjQzLDI0NSwyNDcsMjQ5LDI1MiwyNTgsMjY0LDI2NiwyNjgsMjcwLDI3MiwyNzQsMjc1LFwiU3RhdGVtZW50XCIsLTM0LDEzLDE0LDMyLDM1LDM2LDQyLDUxLDU0LDU1LDU3LDYyLDcwLDcyLDc2LDgwLDgyLDg0LDg1LDExMCwxMTEsMTIwLDEyMSwxMzYsMTM5LDE0MSwxNDIsMTQzLDE0NCwxNDUsMTQ3LDE0OCwxNjcsMTY5LDE3MSxcIkV4cHJlc3Npb25cIiwtMjMsMzEsMzMsMzcsNDEsNDMsNDUsMTczLDE3NSwxNzcsMTc4LDE4MCwxODEsMTgyLDE4NCwxODUsMTg2LDE4OCwxODksMTkwLDIwMSwyMDMsMjA1LDIwNixcIlR5cGVcIiwtMyw4OCwxMDMsMTA5LFwiQ2xhc3NJdGVtXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDIzLFwiPFwiLDM4LFwiSW50ZXJwb2xhdGlvblN0YXJ0XCIsNTYsXCJbXCIsNjAsXCJ7XCIsNzMsXCIoXCIsMTYwLFwiSlNYU3RhcnRDbG9zZVRhZ1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCAtMiwyNCwxNjgsXCI+XCIsNDAsXCJJbnRlcnBvbGF0aW9uRW5kXCIsNTAsXCJdXCIsNjEsXCJ9XCIsNzQsXCIpXCIsMTY1LFwiSlNYRW5kVGFnXCJdXG4gIF0sXG4gIHByb3BTb3VyY2VzOiBbanNIaWdobGlnaHRdLFxuICBza2lwcGVkTm9kZXM6IFswLDUsNiwyNzhdLFxuICByZXBlYXROb2RlQ291bnQ6IDM3LFxuICB0b2tlbkRhdGE6IFwiJEZxMDdbUiFiT1glWlhZK2dZWi15WlsrZ1tdJVpdXi5jXnAlWnBxK2dxci9tcnMzY3N0Ol90dUVydXZKU3Z3TGt3eCEgWXh5ISdpeXohKHN6eyEpfXt8ISxxfH0hLk99IU8hLHEhTyFQIS9ZIVAhUSE5aiFRIVIjOk8hUiFbIzxfIVshXSNJXyFdIV4jSmshXiFfI0t1IV8hYCQhWyFgIWEkJHYhYSFiJCpUIWIhYyQsciFjIX1FciF9I08kLXwjTyNQJC9XI1AjUSQ0byNRI1IkNXkjUiNTRXIjUyNUJDdXI1QjbyQ4YiNvI3AkPHIjcCNxJD1oI3EjciQ+eCNyI3MkQFUjcyRmJVokZiRnK2ckZyNCWUVyI0JZI0JaJEFgI0JaJElTRXIkSVMkSV8kQWAkSV8kSXxFciRJfCRJfSREayRJfSRKTyREayRKTyRKVEVyJEpUJEpVJEFgJEpVJEtWRXIkS1YkS1ckQWAkS1cmRlVFciZGVSZGViRBYCZGVjsnU0VyOydTOz1gSXw8JWw/SFRFcj9IVD9IVSRBYD9IVU9FcihuJWRfJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiZqJmhUJGkmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjJmomelA7PWA8JWwmYyd8J1VdJGkmaihaIWJPWSZ9WVomY1p3Jn13eCZjeCFeJn0hXiFfJ30hXyNPJn0jTyNQJmMjUCNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn0hYihTVShaIWJPWSd9WncnfXgjTyd9I1A7J1MnfTsnUzs9YChmPCVsTyd9IWIoaVA7PWA8JWwnfSd8KG9QOz1gPCVsJn0nWyh5XSRpJmooV3BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNvKHIjbyNwKXIjcDsnUyhyOydTOz1gKmE8JWxPKHJwKXdVKFdwT1kpclpyKXJzI08pciNQOydTKXI7J1M7PWAqWjwlbE8pcnAqXlA7PWA8JWwpcidbKmRQOz1gPCVsKHIjUypuWChXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnI1MrXlA7PWA8JWwqZyhuK2RQOz1gPCVsJVowN1srcnEkaSZqKFdwKFohYid8MC9sT1glWlhZK2dZWiZjWlsrZ1twJVpwcStncXIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3AkZiVaJGYkZytnJGcjQlklWiNCWSNCWitnI0JaJElTJVokSVMkSV8rZyRJXyRKVCVaJEpUJEpVK2ckSlUkS1YlWiRLViRLVytnJEtXJkZVJVomRlUmRlYrZyZGVjsnUyVaOydTOz1gK2E8JWw/SFQlWj9IVD9IVStnP0hVTyVaMDdbLlNUKFgjUyRpJmonfTAvbE8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjMDdbLm5fJGkmaihXcChaIWInfTAvbE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKTNwL3hgJGkmaiFwKSxRKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYDB6IWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXMVZgI3YoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYDJYIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXMmRfI3YoQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0F0M2xfKFYnOmYkaSZqKFohYk9ZNGtZWjVxWnI0a3JzN25zdzRrd3g1cXghXjRrIV4hXzhwIV8jTzRrI08jUDVxI1AjbzRrI28jcDhwI3A7J1M0azsnUzs9YDpYPCVsTzRrKF40cl8kaSZqKFohYk9ZNGtZWjVxWnI0a3JzN25zdzRrd3g1cXghXjRrIV4hXzhwIV8jTzRrI08jUDVxI1AjbzRrI28jcDhwI3A7J1M0azsnUzs9YDpYPCVsTzRrJno1dlgkaSZqT3I1cXJzNmNzIV41cSFeIV82eSFfI281cSNvI3A2eSNwOydTNXE7J1M7PWA3aDwlbE81cSZ6NmpUJGRgJGkmak8hXiZjIV8jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjYDZ8VE9yNnlyczddczsnUzZ5OydTOz1gN2I8JWxPNnlgN2JPJGRgYDdlUDs9YDwlbDZ5Jno3a1A7PWA8JWw1cSheN3ddJGRgJGkmaihaIWJPWSZ9WVomY1p3Jn13eCZjeCFeJn0hXiFfJ30hXyNPJn0jTyNQJmMjUCNvJn0jbyNwJ30jcDsnUyZ9OydTOz1gKGw8JWxPJn0hcjh1WihaIWJPWThwWVo2eVpyOHByczloc3c4cHd4Nnl4I084cCNPI1A2eSNQOydTOHA7J1M7PWA6UjwlbE84cCFyOW9VJGRgKFohYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hcjpVUDs9YDwlbDhwKF46W1A7PWA8JWw0ayU5WzpoaCRpJmooV3AoWiFiT1klWllaJmNacSVacXI8U3JzJn1zdCVadHVDcnV3JVp3eChyeCFeJVohXiFfKmchXyFjJVohYyF9Q3IhfSNPJVojTyNQJmMjUCNSJVojUiNTQ3IjUyNUJVojVCNvQ3IjbyNwKmcjcCRnJVokZzsnU0NyOydTOz1gRWw8JWxPQ3IocjxfX1dTJGkmaihXcChaIWJPWTxTWVomY1pyPFNycz1ec3c8U3d4QG54IV48UyFeIV9CbSFfI088UyNPI1A+YCNQI288UyNvI3BCbSNwOydTPFM7J1M7PWBDbDwlbE88UyhRPWddV1MkaSZqKFohYk9ZPV5ZWiZjWnc9Xnd4PmB4IV49XiFeIV8/cSFfI089XiNPI1A+YCNQI289XiNvI3A/cSNwOydTPV47J1M7PWBAaDwlbE89XiZuPmdYV1MkaSZqT1k+YFlaJmNaIV4+YCFeIV8/UyFfI28+YCNvI3A/UyNwOydTPmA7J1M7PWA/azwlbE8+YFM/WFNXU09ZP1NaOydTP1M7J1M7PWA/ZTwlbE8/U1M/aFA7PWA8JWw/UyZuP25QOz1gPCVsPmAhZj94V1dTKFohYk9ZP3Fadz9xd3g/U3gjTz9xI08jUD9TI1A7J1M/cTsnUzs9YEBiPCVsTz9xIWZAZVA7PWA8JWw/cShRQGtQOz1gPCVsPV4nYEB3XVdTJGkmaihXcE9ZQG5ZWiZjWnJAbnJzPmBzIV5AbiFeIV9BcCFfI09AbiNPI1A+YCNQI29AbiNvI3BBcCNwOydTQG47J1M7PWBCZzwlbE9AbnRBd1dXUyhXcE9ZQXBackFwcnM/U3MjT0FwI08jUD9TI1A7J1NBcDsnUzs9YEJhPCVsT0FwdEJkUDs9YDwlbEFwJ2BCalA7PWA8JWxAbiNXQnZZV1MoV3AoWiFiT1lCbVpyQm1ycz9xc3dCbXd4QXB4I09CbSNPI1A/UyNQOydTQm07J1M7PWBDZjwlbE9CbSNXQ2lQOz1gPCVsQm0ockNvUDs9YDwlbDxTJTlbQ31pJGkmaihvJTFsKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdCVadHVDcnV3JVp3eChyeCFRJVohUSFbQ3IhWyFeJVohXiFfKmchXyFjJVohYyF9Q3IhfSNPJVojTyNQJmMjUCNSJVojUiNTQ3IjUyNUJVojVCNvQ3IjbyNwKmcjcCRnJVokZzsnU0NyOydTOz1gRWw8JWxPQ3IlOVtFb1A7PWA8JWxDcjA3W0ZSayRpJmooV3AoWiFiJF0jdChULDJqKGUkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGclWiRnOydTRXI7J1M7PWBJfDwlbE9FcitkSFJrJGkmaihXcChaIWIkXSN0T1klWllaJmNaciVacnMmfXN0JVp0dUd2dXclWnd4KHJ4fSVafSFPR3YhTyFRJVohUSFbR3YhWyFeJVohXiFfKmchXyFjJVohYyF9R3YhfSNPJVojTyNQJmMjUCNSJVojUiNTR3YjUyNUJVojVCNvR3YjbyNwKmcjcCRnJVokZzsnU0d2OydTOz1gSXY8JWxPR3YrZEl5UDs9YDwlbEd2MDdbSlBQOz1gPCVsRXIoS1dKX2AkaSZqKFdwKFohYiNwKENoT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1dLbF8kaSZqJFEoQ2goV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVosI3hMdmEoeitKWSRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN2JVp2d017d3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXTldgJGkmaiN6KENoKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0F0ISBjXyhZJztXJGkmaihXcE9ZISFiWVohI2haciEhYnJzISNoc3chIWJ3eCEkeHghXiEhYiFeIV8hJXohXyNPISFiI08jUCEjaCNQI28hIWIjbyNwISV6I3A7J1MhIWI7J1M7PWAhJ2M8JWxPISFiJ2whIWlfJGkmaihXcE9ZISFiWVohI2haciEhYnJzISNoc3chIWJ3eCEkeHghXiEhYiFeIV8hJXohXyNPISFiI08jUCEjaCNQI28hIWIjbyNwISV6I3A7J1MhIWI7J1M7PWAhJ2M8JWxPISFiJnohI21YJGkmak93ISNod3g2Y3ghXiEjaCFeIV8hJFkhXyNvISNoI28jcCEkWSNwOydTISNoOydTOz1gISRyPCVsTyEjaGAhJF1UT3chJFl3eDddeDsnUyEkWTsnUzs9YCEkbDwlbE8hJFlgISRvUDs9YDwlbCEkWSZ6ISR1UDs9YDwlbCEjaCdsISVSXSRkYCRpJmooV3BPWShyWVomY1pyKHJycyZjcyFeKHIhXiFfKXIhXyNPKHIjTyNQJmMjUCNvKHIjbyNwKXIjcDsnUyhyOydTOz1gKmE8JWxPKHIhUSEmUFooV3BPWSElellaISRZWnIhJXpycyEkWXN3ISV6d3ghJnJ4I08hJXojTyNQISRZI1A7J1MhJXo7J1M7PWAhJ108JWxPISV6IVEhJnlVJGRgKFdwT1kpclpyKXJzI08pciNQOydTKXI7J1M7PWAqWjwlbE8pciFRISdgUDs9YDwlbCEleidsISdmUDs9YDwlbCEhYi81fCEndF8hbC8uXiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVojJlUhKU9fIWshTGYkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaLSFuISpbYiRpJmooV3AoWiFiKFUlJmYjcShDaE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnh6JVp6eyErZHshXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXIStvYCRpJmooV3AoWiFiI24oQ2hPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWis7eCEsfGAkaSZqKFdwKFohYnIrNFlPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiwkVSEuWl8hXStKZiRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowN1shL2VjJGkmaihXcChaIWIhUS4yXk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEwcCFQIVElWiFRIVshM1khWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVojJXwhMHlhJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhMk8hUCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVojJXwhMlpfIVshTF4kaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkITNlZyRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyEzWSFbIV4lWiFeIV8qZyFfIWclWiFnIWghNHwhaCNPJVojTyNQJmMjUCNSJVojUiNTITNZI1MjWCVaI1gjWSE0fCNZI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE1VmckaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnh7JVp7fCE2bnx9JVp9IU8hNm4hTyFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCE2d2MkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyE4UyFbIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MhOFMjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQhOF9jJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyE5dWYkaSZqKFdwKFohYiNvKENoT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4eiE7Wnp7Iy19eyFQITtaIVAhUSMvZCFRIV4hO1ohXiFfIyhpIV8hYCM3UyFgIWEjOGkhYSF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7Wj9PITtmYiRpJmooV3AoWiFiIVg3YE9ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUxjeCFQITtaIVAhUSMmYCFRIV4hO1ohXiFfIyhpIV8hfSE7WiF9I08jLGYjTyNQIUR5I1AjbyE7WiNvI3AjKGkjcDsnUyE7WjsnUzs9YCMtdzwlbE8hO1o+XiE8d2AkaSZqKFohYiFYN2BPWSE8bllaJmNadyE8bnd4IT15eCFQITxuIVAhUSFFcSFRIV4hPG4hXiFfIUdyIV8hfSE8biF9I08hS1MjTyNQIUR5I1AjbyE8biNvI3AhR3IjcDsnUyE8bjsnUzs9YCFMXTwlbE8hPG48eiE+UV4kaSZqIVg3YE9ZIT15WVomY1ohUCE9eSFQIVEhPnwhUSFeIT15IV4hXyFAYyFfIX0hPXkhfSNPIUNXI08jUCFEeSNQI28hPXkjbyNwIUBjI3A7J1MhPXk7J1M7PWAhRWs8JWxPIT15PHohP1RkJGkmaiFYN2BPIV4mYyFfI1cmYyNXI1ghPnwjWCNaJmMjWiNbIT58I1sjXSZjI10jXiE+fCNeI2EmYyNhI2IhPnwjYiNnJmMjZyNoIT58I2gjaSZjI2kjaiE+fCNqI2shPnwjayNtJmMjbSNuIT58I24jbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjN2AhQGhYIVg3YE9ZIUBjWiFQIUBjIVAhUSFBVCFRIX0hQGMhfSNPIUFyI08jUCFCcSNQOydTIUBjOydTOz1gIUNRPCVsTyFAYzdgIUFZVyFYN2AjVyNYIUFUI1ojWyFBVCNdI14hQVQjYSNiIUFUI2cjaCFBVCNpI2ohQVQjaiNrIUFUI20jbiFBVDdgIUF1Vk9ZIUFyWiNPIUFyI08jUCFCWyNQI1EhQGMjUTsnUyFBcjsnUzs9YCFCazwlbE8hQXI3YCFCX1NPWSFBclo7J1MhQXI7J1M7PWAhQms8JWxPIUFyN2AhQm5QOz1gPCVsIUFyN2AhQnRTT1khQGNaOydTIUBjOydTOz1gIUNRPCVsTyFAYzdgIUNUUDs9YDwlbCFAYzx6IUNdWyRpJmpPWSFDV1laJmNaIV4hQ1chXiFfIUFyIV8jTyFDVyNPI1AhRFIjUCNRIT15I1EjbyFDVyNvI3AhQXIjcDsnUyFDVzsnUzs9YCFEczwlbE8hQ1c8eiFEV1gkaSZqT1khQ1dZWiZjWiFeIUNXIV4hXyFBciFfI28hQ1cjbyNwIUFyI3A7J1MhQ1c7J1M7PWAhRHM8JWxPIUNXPHohRHZQOz1gPCVsIUNXPHohRU9YJGkmak9ZIT15WVomY1ohXiE9eSFeIV8hQGMhXyNvIT15I28jcCFAYyNwOydTIT15OydTOz1gIUVrPCVsTyE9eTx6IUVuUDs9YDwlbCE9eT5eIUV6bCRpJmooWiFiIVg3YE9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI1cmfSNXI1ghRXEjWCNaJn0jWiNbIUVxI1sjXSZ9I10jXiFFcSNeI2EmfSNhI2IhRXEjYiNnJn0jZyNoIUVxI2gjaSZ9I2kjaiFFcSNqI2shRXEjayNtJn0jbSNuIUVxI24jbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9OHIhR3laKFohYiFYN2BPWSFHclp3IUdyd3ghQGN4IVAhR3IhUCFRIUhsIVEhfSFHciF9I08hSlUjTyNQIUJxI1A7J1MhR3I7J1M7PWAhSnw8JWxPIUdyOHIhSHNlKFohYiFYN2BPWSd9WncnfXgjTyd9I1AjVyd9I1cjWCFIbCNYI1onfSNaI1shSGwjWyNdJ30jXSNeIUhsI14jYSd9I2EjYiFIbCNiI2cnfSNnI2ghSGwjaCNpJ30jaSNqIUhsI2ojayFIbCNrI20nfSNtI24hSGwjbjsnUyd9OydTOz1gKGY8JWxPJ304ciFKWlgoWiFiT1khSlVadyFKVXd4IUFyeCNPIUpVI08jUCFCWyNQI1EhR3IjUTsnUyFKVTsnUzs9YCFKdjwlbE8hSlU4ciFKeVA7PWA8JWwhSlU4ciFLUFA7PWA8JWwhR3I+XiFLWl4kaSZqKFohYk9ZIUtTWVomY1p3IUtTd3ghQ1d4IV4hS1MhXiFfIUpVIV8jTyFLUyNPI1AhRFIjUCNRITxuI1EjbyFLUyNvI3AhSlUjcDsnUyFLUzsnUzs9YCFMVjwlbE8hS1M+XiFMWVA7PWA8JWwhS1M+XiFMYFA7PWA8JWwhPG49bCFMbGAkaSZqKFdwIVg3YE9ZIUxjWVomY1pyIUxjcnMhPXlzIVAhTGMhUCFRIU1uIVEhXiFMYyFeIV8jIG8hXyF9IUxjIX0jTyMlUCNPI1AhRHkjUCNvIUxjI28jcCMgbyNwOydTIUxjOydTOz1gIyZZPCVsTyFMYz1sIU13bCRpJmooV3AhWDdgT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjVyhyI1cjWCFNbiNYI1oociNaI1shTW4jWyNdKHIjXSNeIU1uI14jYShyI2EjYiFNbiNiI2cociNnI2ghTW4jaCNpKHIjaSNqIU1uI2ojayFNbiNrI20ociNtI24hTW4jbiNvKHIjbyNwKXIjcDsnUyhyOydTOz1gKmE8JWxPKHI4USMgdlooV3AhWDdgT1kjIG9aciMgb3JzIUBjcyFQIyBvIVAhUSMhaSFRIX0jIG8hfSNPIyRSI08jUCFCcSNQOydTIyBvOydTOz1gIyR5PCVsTyMgbzhRIyFwZShXcCFYN2BPWSlyWnIpcnMjTylyI1AjVylyI1cjWCMhaSNYI1opciNaI1sjIWkjWyNdKXIjXSNeIyFpI14jYSlyI2EjYiMhaSNiI2cpciNnI2gjIWkjaCNpKXIjaSNqIyFpI2ojayMhaSNrI20pciNtI24jIWkjbjsnUylyOydTOz1gKlo8JWxPKXI4USMkV1goV3BPWSMkUlpyIyRScnMhQXJzI08jJFIjTyNQIUJbI1AjUSMgbyNROydTIyRSOydTOz1gIyRzPCVsTyMkUjhRIyR2UDs9YDwlbCMkUjhRIyR8UDs9YDwlbCMgbz1sIyVXXiRpJmooV3BPWSMlUFlaJmNaciMlUHJzIUNXcyFeIyVQIV4hXyMkUiFfI08jJVAjTyNQIURSI1AjUSFMYyNRI28jJVAjbyNwIyRSI3A7J1MjJVA7J1M7PWAjJlM8JWxPIyVQPWwjJlZQOz1gPCVsIyVQPWwjJl1QOz1gPCVsIUxjP08jJmtuJGkmaihXcChaIWIhWDdgT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNXJVojVyNYIyZgI1gjWiVaI1ojWyMmYCNbI10lWiNdI14jJmAjXiNhJVojYSNiIyZgI2IjZyVaI2cjaCMmYCNoI2klWiNpI2ojJmAjaiNrIyZgI2sjbSVaI20jbiMmYCNuI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjlkIyhyXShXcChaIWIhWDdgT1kjKGlaciMoaXJzIUdyc3cjKGl3eCMgb3ghUCMoaSFQIVEjKWshUSF9IyhpIX0jTyMrYCNPI1AhQnEjUDsnUyMoaTsnUzs9YCMsYDwlbE8jKGk5ZCMpdGgoV3AoWiFiIVg3YE9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUCNXKmcjVyNYIylrI1gjWipnI1ojWyMpayNbI10qZyNdI14jKWsjXiNhKmcjYSNiIylrI2IjZypnI2cjaCMpayNoI2kqZyNpI2ojKWsjaiNrIylrI2sjbSpnI20jbiMpayNuOydTKmc7J1M7PWArWjwlbE8qZzlkIytnWihXcChaIWJPWSMrYFpyIytgcnMhSlVzdyMrYHd4IyRSeCNPIytgI08jUCFCWyNQI1EjKGkjUTsnUyMrYDsnUzs9YCMsWTwlbE8jK2A5ZCMsXVA7PWA8JWwjK2A5ZCMsY1A7PWA8JWwjKGk/TyMsb2AkaSZqKFdwKFohYk9ZIyxmWVomY1pyIyxmcnMhS1NzdyMsZnd4IyVQeCFeIyxmIV4hXyMrYCFfI08jLGYjTyNQIURSI1AjUSE7WiNRI28jLGYjbyNwIytgI3A7J1MjLGY7J1M7PWAjLXE8JWxPIyxmP08jLXRQOz1gPCVsIyxmP08jLXpQOz1gPCVsITtaMDdbIy5bYiRpJmooV3AoWiFiKE8wL2whWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7WjA3WyMvb18kaSZqKFdwKFohYlQwL2xPWSMvZFlaJmNaciMvZHJzIzBuc3cjL2R3eCM0T3ghXiMvZCFeIV8jNX0hXyNPIy9kI08jUCMxcCNQI28jL2QjbyNwIzV9I3A7J1MjL2Q7J1M7PWAjNnw8JWxPIy9kMDZqIzB3XSRpJmooWiFiVDAvbE9ZIzBuWVomY1p3IzBud3gjMXB4IV4jMG4hXiFfIzNSIV8jTyMwbiNPI1AjMXAjUCNvIzBuI28jcCMzUiNwOydTIzBuOydTOz1gIzN4PCVsTyMwbjA1VyMxd1gkaSZqVDAvbE9ZIzFwWVomY1ohXiMxcCFeIV8jMmQhXyNvIzFwI28jcCMyZCNwOydTIzFwOydTOz1gIzJ7PCVsTyMxcDAvbCMyaVNUMC9sT1kjMmRaOydTIzJkOydTOz1gIzJ1PCVsTyMyZDAvbCMyeFA7PWA8JWwjMmQwNVcjM09QOz1gPCVsIzFwMDFPIzNZVyhaIWJUMC9sT1kjM1JadyMzUnd4IzJkeCNPIzNSI08jUCMyZCNQOydTIzNSOydTOz1gIzNyPCVsTyMzUjAxTyMzdVA7PWA8JWwjM1IwNmojM3tQOz1gPCVsIzBuMDV4IzRYXSRpJmooV3BUMC9sT1kjNE9ZWiZjWnIjNE9ycyMxcHMhXiM0TyFeIV8jNVEhXyNPIzRPI08jUCMxcCNQI28jNE8jbyNwIzVRI3A7J1MjNE87J1M7PWAjNXc8JWxPIzRPMDBeIzVYVyhXcFQwL2xPWSM1UVpyIzVRcnMjMmRzI08jNVEjTyNQIzJkI1A7J1MjNVE7J1M7PWAjNXE8JWxPIzVRMDBeIzV0UDs9YDwlbCM1UTA1eCM1elA7PWA8JWwjNE8wMXAjNldZKFdwKFohYlQwL2xPWSM1fVpyIzV9cnMjM1JzdyM1fXd4IzVReCNPIzV9I08jUCMyZCNQOydTIzV9OydTOz1gIzZ2PCVsTyM1fTAxcCM2eVA7PWA8JWwjNX0wN1sjN1BQOz1gPCVsIy9kKTNoIzdhYiRpJmokUShDaChXcChaIWIhWDdgT1khO1pZWiZjWnIhO1pycyE8bnN3ITtad3ghTGN4IVAhO1ohUCFRIyZgIVEhXiE7WiFeIV8jKGkhXyF9ITtaIX0jTyMsZiNPI1AhRHkjUCNvITtaI28jcCMoaSNwOydTITtaOydTOz1gIy13PCVsTyE7WkF0Izh2YiRaI3QkaSZqKFdwKFohYiFYN2BPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFMY3ghUCE7WiFQIVEjJmAhUSFeITtaIV4hXyMoaSFfIX0hO1ohfSNPIyxmI08jUCFEeSNQI28hO1ojbyNwIyhpI3A7J1MhO1o7J1M7PWAjLXc8JWxPITtaJ0FkIzpacCRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjPF8hWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM8XyNTI1UlWiNVI1YjP2kjViNYJVojWCNZITR8I1kjYiVaI2IjYyM+XyNjI2QjQnEjZCNsJVojbCNtI0VzI20jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkIzxqayRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjPF8hWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM8XyNTI1glWiNYI1khNHwjWSNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkIz5qXyRpJmooV3AoWiFicyc5dE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkIz9yZCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSI0FRIVIhUyNBUSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjQVEjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonQWQjQV1mJGkmaihXcChaIWJzJzl0T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSI0FRIVIhUyNBUSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjQVEjUyNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJ0FkI0J6YyRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZI0RWIVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNEViNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNEYmUkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjRFYhWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0RWI1MjYiVaI2IjYyM+XyNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNFfGckaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNHZSFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjR2UhaSNPJVojTyNQJmMjUCNSJVojUiNTI0dlI1MjVCVaI1QjWiNHZSNaI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWidBZCNHcGkkaSZqKFdwKFohYnMnOXRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjR2UhWyFeJVohXiFfKmchXyFjJVohYyFpI0dlIWkjTyVaI08jUCZjI1AjUiVaI1IjUyNHZSNTI1QlWiNUI1ojR2UjWiNiJVojYiNjIz5fI2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKil4I0lsXyFnJGIkaSZqJE8pTHYoV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopWyNKdl9hbCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowNGYjTFNeaCMpYCNSLTxVKFdwKFohYiRuN2BPWSpnWnIqZ3JzJ31zdypnd3gpcnghUCpnIVAhUSNNTyFRIV4qZyFeIV8jTXQhXyFgJCBmIWAjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKG4jTVhYJGsmaihXcChaIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKEVsI019WiNyKENoKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCFfKmchXyFgI05wIWAjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnKEVsI055WCRRKENoKFdwKFohYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcoRWwkIG9YI3MoQ2goV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyopeCQhZ2EjYCohWSRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCFhJCNsIWEjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtbJCN3XyNrKENsJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiopeCQlVmFnISpyI3MoQ2gkZiN8JGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAkJlshYCFhJCdmIWEjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCZnXyNzKENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLVyQncWEjcihDaCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCFhJCh2IWEjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJClSYCNyKENoJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihLZCQqYGEocihDdCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFhJVohYSFiJCtlIWIjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKEtXJCtwYCRpJmojeyhDaChXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjYCQsfV8hfCRJcCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVowNGYkLlhfIVMwLHYkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKG4kL11aJGkmak8hXiQwTyFeIV8kMGYhXyNpJDBPI2kjaiQwayNqI2wkME8jbCNtJDJeI20jbyQwTyNvI3AkMGYjcDsnUyQwTzsnUzs9YCQ0aTwlbE8kME8obiQwVlRfI1MkaSZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQwa09fI1MobiQwcFskaSZqTyFRJmMhUSFbJDFmIVshXiZjIV8hYyZjIWMhaSQxZiFpI1QmYyNUI1okMWYjWiNvJmMjbyNwJDN8I3A7J1MmYzsnUzs9YCZ3PCVsTyZjKG4kMWtaJGkmak8hUSZjIVEhWyQyXiFbIV4mYyFfIWMmYyFjIWkkMl4haSNUJmMjVCNaJDJeI1ojbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjKG4kMmNaJGkmak8hUSZjIVEhWyQzVSFbIV4mYyFfIWMmYyFjIWkkM1UhaSNUJmMjVCNaJDNVI1ojbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjKG4kM1paJGkmak8hUSZjIVEhWyQwTyFbIV4mYyFfIWMmYyFjIWkkME8haSNUJmMjVCNaJDBPI1ojbyZjI3A7J1MmYzsnUzs9YCZ3PCVsTyZjI1MkNFBSIVEhWyQ0WSFjIWkkNFkjVCNaJDRZI1MkNF1TIVEhWyQ0WSFjIWkkNFkjVCNaJDRZI3EjciQwZihuJDRsUDs9YDwlbCQwTyMxWyQ0el8hWSMpbCRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooS1ckNlVgI3goQ2gkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKztwJDdjXyRpJmooV3AoWiFiKGErNFFPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWjA3WyQ4cWskaSZqKFdwKFohYihULDJqJF8jdChlJElbT1klWllaJmNaciVacnMmfXN0JVp0dSQ4YnV3JVp3eChyeH0lWn0hTyQ6ZiFPIVElWiFRIVskOGIhWyFeJVohXiFfKmchXyFjJVohYyF9JDhiIX0jTyVaI08jUCZjI1AjUiVaI1IjUyQ4YiNTI1QlWiNUI28kOGIjbyNwKmcjcCRnJVokZzsnUyQ4YjsnUzs9YCQ8bDwlbE8kOGIrZCQ6cWskaSZqKFdwKFohYiRfI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDpmdXclWnd4KHJ4fSVafSFPJDpmIU8hUSVaIVEhWyQ6ZiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOmYhfSNPJVojTyNQJmMjUCNSJVojUiNTJDpmI1MjVCVaI1QjbyQ6ZiNvI3AqZyNwJGclWiRnOydTJDpmOydTOz1gJDxmPCVsTyQ6ZitkJDxpUDs9YDwlbCQ6ZjA3WyQ8b1A7PWA8JWwkOGIjSmYkPHtYIV8jSGIoV3AoWiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZywjeCQ9c2EoeStKWSRpJmooV3AoWiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCNxJCtlI3E7J1MlWjsnUzs9YCthPCVsTyVaKT52JD9WXyFeKENkdkJyJGkmaihXcChaIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWj9PJEBhXyFxN2AkaSZqKFdwKFohYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaMDdbJEFxfCRpJmooV3AoWiFiJ3wwL2wkXSN0KFQsMmooZSRJW09YJVpYWStnWVomY1pbK2dbcCVacHErZ3FyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQWAjQlokSVNFciRJUyRJXyRBYCRJXyRKVEVyJEpUJEpVJEFgJEpVJEtWRXIkS1YkS1ckQWAkS1cmRlVFciZGVSZGViRBYCZGVjsnU0VyOydTOz1gSXw8JWw/SFRFcj9IVD9IVSRBYD9IVU9FcjA3WyREfGskaSZqKFdwKFohYid9MC9sJF0jdChULDJqKGUkSVtPWSVaWVomY1pyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGclWiRnOydTRXI7J1M7PWBJfDwlbE9FclwiLFxuICB0b2tlbml6ZXJzOiBbbm9TZW1pY29sb24sIG5vU2VtaWNvbG9uVHlwZSwgb3BlcmF0b3JUb2tlbiwganN4LCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIGluc2VydFNlbWljb2xvbiwgbmV3IExvY2FsVG9rZW5Hcm91cChcIiRTflJSdHVbI08jUGcjUyNUI3x+X1AjbyNwYn5nT3h+fmpWTyNpIVAjaSNqIVUjaiNsIVAjbCNtIXEjbTsnUyFQOydTOz1gI3Y8JWxPIVB+IVVPIVV+fiFYUyFRIVshZSFjIWkhZSNUI1ohZSNvI3AjWn4haFIhUSFbIXEhYyFpIXEjVCNaIXF+IXRSIVEhWyF9IWMhaSF9I1QjWiF9fiNRUiFRIVshUCFjIWkhUCNUI1ohUH4jXlIhUSFbI2chYyFpI2cjVCNaI2d+I2pTIVEhWyNnIWMhaSNnI1QjWiNnI3EjciFQfiN5UDs9YDwlbCFQfiRSTyhjfn5cIiwgMTQxLCAzNDApLCBuZXcgTG9jYWxUb2tlbkdyb3VwKFwian5SUVlaWHp7Xn5eTyhRfn5hUCFQIVFkfmlPKFJ+flwiLCAyNSwgMzIzKV0sXG4gIHRvcFJ1bGVzOiB7XCJTY3JpcHRcIjpbMCw3XSxcIlNpbmdsZUV4cHJlc3Npb25cIjpbMSwyNzZdLFwiU2luZ2xlQ2xhc3NJdGVtXCI6WzIsMjc3XX0sXG4gIGRpYWxlY3RzOiB7anN4OiAwLCB0czogMTUxNzV9LFxuICBkeW5hbWljUHJlY2VkZW5jZXM6IHtcIjgwXCI6MSxcIjgyXCI6MSxcIjk0XCI6MSxcIjE2OVwiOjEsXCIxOTlcIjoxfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogMzI3LCBnZXQ6ICh2YWx1ZSkgPT4gc3BlY19pZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX0se3Rlcm06IDM0MywgZ2V0OiAodmFsdWUpID0+IHNwZWNfd29yZFt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiA5NSwgZ2V0OiAodmFsdWUpID0+IHNwZWNfTGVzc1RoYW5bdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMTUyMDFcbn0pO1xuXG5leHBvcnQgeyBwYXJzZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */ && this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && (this.buffer[index - 4] != 0 /* Term.Err */ || this.buffer[index - 1] < 0)) {\n                let mustMove = false;\n                for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove)\n                    while (index > 0 && this.buffer[index - 2] > end) {\n                        // Move this record forward\n                        this.buffer[index] = this.buffer[index - 4];\n                        this.buffer[index + 1] = this.buffer[index - 3];\n                        this.buffer[index + 2] = this.buffer[index - 2];\n                        this.buffer[index + 3] = this.buffer[index - 1];\n                        index -= 4;\n                        if (size > 4)\n                            size -= 4;\n                    }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead <= this.lookAhead)\n            return false;\n        this.emitLookAhead();\n        this.lookAhead = lookAhead;\n        return true;\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */\n    acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */) {\n                newStacks.sort((a, b) => b.score - a.score);\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; j < 10 /* Rec.ForceReduceLimit */ && force.forceReduce(); j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5Rzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJEQUEyRCxJQUFJLFNBQVMsRUFBRSxtQ0FBbUM7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUVBQXFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FB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Ly9haS1hcHAtYnVpbGRlci13ZWIvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanM/MjU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgVHJlZSwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5BIHBhcnNlIHN0YWNrLiBUaGVzZSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwYXJzZXIgdG8gdHJhY2tcbnBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xudGhhdCBleHRlcm5hbCBjb2RlIHN1Y2ggYXMgYSB0b2tlbml6ZXIgY2FuIHVzZSB0byBnZXQgaW5mb3JtYXRpb25cbmFib3V0IHRoZSBwYXJzZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGFjayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGFyc2UgdGhhdCB0aGlzIHN0YWNrIGlzIHBhcnQgb2YgQGludGVybmFsXG4gICAgKi9cbiAgICBwLCBcbiAgICAvKipcbiAgICBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgdG9wIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhY2ssIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8vIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgbmV4dCByZWR1Y2Ugc2hvdWxkIHRha2UgcGxhY2UuIFRoaXNcbiAgICAvLyBjYW4gYmUgbGVzcyB0aGFuIGB0aGlzLnBvc2Agd2hlbiBza2lwcGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIGFkZGVkIHRvIHRoZSBzdGFjayAod2hpY2ggc2hvdWxkIGJlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5leHRcbiAgICAvLyByZWR1Y3Rpb24pXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2VQb3MsIFxuICAgIC8qKlxuICAgIFRoZSBpbnB1dCBwb3NpdGlvbiB1cCB0byB3aGljaCB0aGlzIHN0YWNrIGhhcyBwYXJzZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIGFuZCBlcnJvci1yZWNvdmVyeSBwZW5hbHRpZXNcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvLyBUaGUgYmFzZSBvZmZzZXQgb2YgdGhlIGJ1ZmZlci4gV2hlbiBzdGFja3MgYXJlIHNwbGl0LCB0aGUgc3BsaXRcbiAgICAvLyBpbnN0YW5jZSBzaGFyZWQgdGhlIGJ1ZmZlciBoaXN0b3J5IHdpdGggaXRzIHBhcmVudCB1cCB0b1xuICAgIC8vIGBidWZmZXJCYXNlYCwgd2hpY2ggaXMgdGhlIGFic29sdXRlIG9mZnNldCAoaW5jbHVkaW5nIHRoZVxuICAgIC8vIG9mZnNldCBvZiBwcmV2aW91cyBzcGxpdHMpIGludG8gdGhlIGJ1ZmZlciBhdCB3aGljaCB0aGlzIHN0YWNrXG4gICAgLy8gc3RhcnRzIHdyaXRpbmcuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXJCYXNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1ckNvbnRleHQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9va0FoZWFkID0gMCwgXG4gICAgLy8gQSBwYXJlbnQgc3RhY2sgZnJvbSB3aGljaCB0aGlzIHdhcyBzcGxpdCBvZmYsIGlmIGFueS4gVGhpcyBpc1xuICAgIC8vIHNldCB1cCBzbyB0aGF0IGl0IGFsd2F5cyBwb2ludHMgdG8gYSBzdGFjayB0aGF0IGhhcyBzb21lXG4gICAgLy8gYWRkaXRpb25hbCBidWZmZXIgY29udGVudCwgbmV2ZXIgdG8gYSBzdGFjayB3aXRoIGFuIGVxdWFsXG4gICAgLy8gYGJ1ZmZlckJhc2VgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGFyZW50KSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHJlZHVjZVBvcztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuYnVmZmVyQmFzZSA9IGJ1ZmZlckJhc2U7XG4gICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IGN1ckNvbnRleHQ7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gbG9va0FoZWFkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc3RhcnQocCwgc3RhdGUsIHBvcyA9IDApIHtcbiAgICAgICAgbGV0IGN4ID0gcC5wYXJzZXIuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhwLCBbXSwgc3RhdGUsIHBvcywgcG9zLCAwLCBbXSwgMCwgY3ggPyBuZXcgU3RhY2tDb250ZXh0KGN4LCBjeC5zdGFydCkgOiBudWxsLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICBhbnkuIEl0cyB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBjb250ZXh0IHRyYWNrZXIncyB0eXBlXG4gICAgcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gICAgdHJhY2tlci5cbiAgICAqL1xuICAgIGdldCBjb250ZXh0KCkgeyByZXR1cm4gdGhpcy5jdXJDb250ZXh0ID8gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQgOiBudWxsOyB9XG4gICAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAgIC8vIGFzIHRoZSBidWZmZXIgYmFzZSBhdCB0aGF0IHBvaW50LlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0eXBlID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCBsb29rYWhlYWRSZWNvcmQgPSB0aGlzLnJlZHVjZVBvcyA8IHRoaXMucG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLyAmJiB0aGlzLnNldExvb2tBaGVhZCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBkUHJlYyA9IHBhcnNlci5keW5hbWljUHJlY2VkZW5jZSh0eXBlKTtcbiAgICAgICAgaWYgKGRQcmVjKVxuICAgICAgICAgICAgdGhpcy5zY29yZSArPSBkUHJlYztcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhdGUsIHR5cGUsIHRydWUpLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICAvLyBaZXJvLWRlcHRoIHJlZHVjdGlvbnMgYXJlIGEgc3BlY2lhbCBjYXNl4oCUdGhleSBhZGQgc3R1ZmYgdG9cbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IHBvcHBpbmcgYW55dGhpbmcgb2ZmLlxuICAgICAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSh0eXBlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIGxvb2thaGVhZFJlY29yZCA/IDggOiA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgc2l6ZSA9IHRoaXMucmVkdWNlUG9zIC0gc3RhcnQ7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdHJ5IGFuZCBkZXRlY3Qgb3Zlcmx5IGRlZXAgbGVmdC1hc3NvY2lhdGl2ZVxuICAgICAgICAvLyB0cmVlcywgd2hpY2ggd2lsbCBub3QgaW5jcmVhc2UgdGhlIHBhcnNlIHN0YWNrIGRlcHRoIGFuZCB0aHVzXG4gICAgICAgIC8vIHdvbid0IGJlIGNhdWdodCBieSB0aGUgcmVndWxhciBzdGFjay1kZXB0aCBsaW1pdCBjaGVjay5cbiAgICAgICAgaWYgKHNpemUgPj0gMjAwMCAvKiBSZWNvdmVyLk1pbkJpZ1JlZHVjdGlvbiAqLyAmJiAhKChfYSA9IHRoaXMucC5wYXJzZXIubm9kZVNldC50eXBlc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMV0gOiAwLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBtdXN0U2luayA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtdXN0U2luayB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiAodGhpcy5idWZmZXJbaW5kZXggLSA0XSAhPSAwIC8qIFRlcm0uRXJyICovIHx8IHRoaXMuYnVmZmVyW2luZGV4IC0gMV0gPCAwKSkge1xuICAgICAgICAgICAgICAgIGxldCBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBpbmRleDsgc2NhbiA+IDAgJiYgdGhpcy5idWZmZXJbc2NhbiAtIDJdID4gZW5kOyBzY2FuIC09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3NjYW4gLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobXVzdE1vdmUpXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGlzIHJlY29yZCBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gdGhpcy5idWZmZXJbaW5kZXggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNoaWZ0KGFjdGlvbiwgdHlwZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChhY3Rpb24gJiAyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5wb3MgfHwgdHlwZSA8PSBwYXJzZXIubWF4Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gcGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0eXBlLCBzdGFydCwgZW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRDb250ZXh0KHR5cGUsIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0eXBlIDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IGFuIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHkoYWN0aW9uLCBuZXh0LCBuZXh0U3RhcnQsIG5leHRFbmQpIHtcbiAgICAgICAgaWYgKGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zaGlmdChhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCk7XG4gICAgfVxuICAgIC8vIEFkZCBhIHByZWJ1aWx0IChyZXVzZWQpIG5vZGUgaW50byB0aGUgYnVmZmVyLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXNlTm9kZSh2YWx1ZSwgbmV4dCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnAucmV1c2VkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5wLnJldXNlZFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucC5yZXVzZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zID0gc3RhcnQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbmRleCwgc3RhcnQsIHRoaXMucmVkdWNlUG9zLCAtMSAvKiBzaXplID09IC0xIG1lYW5zIHRoaXMgaXMgYSByZXVzZWQgdmFsdWUgKi8pO1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJldXNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCB2YWx1ZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldCh0aGlzLnBvcyAtIHZhbHVlLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgdGhlIHN0YWNrLiBEdWUgdG8gdGhlIGJ1ZmZlciBzaGFyaW5nIGFuZCB0aGUgZmFjdFxuICAgIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gICAgLy8gZXhwZW5zaXZlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXJCeURlbGV0ZShuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBpc05vZGUgPSBuZXh0IDw9IHRoaXMucC5wYXJzZXIubWF4Tm9kZTtcbiAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKG5leHQsIHRoaXMucG9zLCBuZXh0RW5kLCA0KTtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIFJlY292ZXIuRGVsZXRlICovO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGUgZ2l2ZW4gdGVybSB3b3VsZCBiZSBhYmxlIHRvIGJlIHNoaWZ0ZWQgKG9wdGlvbmFsbHlcbiAgICBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICBleHRlcm5hbCB0b2tlbml6ZXJzIHRoYXQgd2FudCB0byBtYWtlIHN1cmUgdGhleSBvbmx5IHByb3ZpZGUgYVxuICAgIGdpdmVuIHRva2VuIHdoZW4gaXQgYXBwbGllcy5cbiAgICAqL1xuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKSB8fCB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzaW0uc3RhdGUsIHRlcm0pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5SW5zZXJ0KG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID49IDMwMCAvKiBSZWNvdmVyLk1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxIHx8IHRoaXMuc3RhY2subGVuZ3RoID49IDEyMCAvKiBSZWNvdmVyLkRhbXBlbkluc2VydFN0YWNrRGVwdGggKi8pIHtcbiAgICAgICAgICAgIGxldCBiZXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgczsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHMgPSBuZXh0U3RhdGVzW2kgKyAxXSkgIT0gdGhpcy5zdGF0ZSAmJiB0aGlzLnAucGFyc2VyLmhhc0FjdGlvbihzLCBuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoIDwgMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLyA8PCAxICYmIGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVzdC5zb21lKCh2LCBpKSA9PiAoaSAmIDEpICYmIHYgPT0gcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IGJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCA0IC8qIFJlY292ZXIuTWF4TmV4dCAqLzsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHMgPT0gdGhpcy5zdGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICBzdGFjay5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgc3RhY2sucG9zLCBzdGFjay5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgc3RhY2suc2NvcmUgLT0gMjAwIC8qIFJlY292ZXIuSW5zZXJ0ICovO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgICAvLyBiZSBkb25lLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yY2VSZWR1Y2UoKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgcmVkdWNlID0gcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA1IC8qIFBhcnNlU3RhdGUuRm9yY2VkUmVkdWNlICovKTtcbiAgICAgICAgaWYgKChyZWR1Y2UgJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJzZXIudmFsaWRBY3Rpb24odGhpcy5zdGF0ZSwgcmVkdWNlKSkge1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gcmVkdWNlID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovLCB0ZXJtID0gcmVkdWNlICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBiYWNrdXAgPSB0aGlzLmZpbmRGb3JjZWRSZWR1Y3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFja3VwID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZWR1Y2UgPSBiYWNrdXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY29yZSAtPSAxMDAgLyogUmVjb3Zlci5SZWR1Y2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2UocmVkdWNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBzY2FuIHRocm91Z2ggdGhlIGF1dG9tYXRvbiB0byBmaW5kIHNvbWUga2luZCBvZiByZWR1Y3Rpb25cbiAgICB0aGF0IGNhbiBiZSBhcHBsaWVkLiBVc2VkIHdoZW4gdGhlIHJlZ3VsYXIgRm9yY2VkUmVkdWNlIGZpZWxkXG4gICAgaXNuJ3QgYSB2YWxpZCBhY3Rpb24uIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZEZvcmNlZFJlZHVjdGlvbigpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnAsIHNlZW4gPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAoc3RhdGUsIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmNsdWRlcyhzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuYWxsQWN0aW9ucyhzdGF0ZSwgKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gJiAoMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyB8IDEzMTA3MiAvKiBBY3Rpb24uR290b0ZsYWcgKi8pKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJEZXB0aCA9IChhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIC0gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gckRlcHRoICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPj0gMCAmJiBwYXJzZXIuZ2V0R290byh0aGlzLnN0YWNrW3RhcmdldF0sIHRlcm0sIGZhbHNlKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAockRlcHRoIDw8IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovKSB8IDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovIHwgdGVybTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZXhwbG9yZShhY3Rpb24sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwbG9yZSh0aGlzLnN0YXRlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAyIC8qIFN0YXRlRmxhZy5BY2NlcHRpbmcgKi8pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VSZWR1Y2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgdG9wIHN0YXRlLCBzaW5jZSBhbnkgb3RoZXIgc3RhdGVzIG11c3QgYmUgYWJsZSB0byBjb250aW51ZVxuICAgIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXN0YXJ0IHRoZSBzdGFjayAocHV0IGl0IGJhY2sgaW4gaXRzIHN0YXJ0IHN0YXRlKS4gT25seSBzYWZlXG4gICAgd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgc3RhdGUpLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrWzBdO1xuICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2FtZVN0YXRlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG90aGVyLnN0YXRlIHx8IHRoaXMuc3RhY2subGVuZ3RoICE9IG90aGVyLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tbaV0gIT0gb3RoZXIuc3RhY2tbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwYXJzZXIgdXNlZCBieSB0aGlzIHN0YWNrLlxuICAgICovXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBkaWFsZWN0IChieSBudW1lcmljIElELCBhcyBleHBvcnRlZCBmcm9tXG4gICAgdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICAgKi9cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdENvbnRleHQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC0zKVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1ckNvbnRleHQuaGFzaCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtMyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW1pdExvb2tBaGVhZCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTQpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMubG9va0FoZWFkLCB0aGlzLnBvcywgdGhpcy5wb3MsIC00KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ICE9IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgbmV3Q3ggPSBuZXcgU3RhY2tDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChuZXdDeC5oYXNoICE9IHRoaXMuY3VyQ29udGV4dC5oYXNoKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY3VyQ29udGV4dCA9IG5ld0N4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkIDw9IHRoaXMubG9va0FoZWFkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuIGVuZGluZyBhdCBhIHNwZWNpZmljIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgYWNjZXB0VG9rZW5Ubyh0b2tlbiwgZW5kUG9zKSB7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmRQb3M7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8sIG5ld1N0YWNrcy5sZW5ndGggLSAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGlmIChkZWZhdWx0UmVkdWNlID4gMCkge1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlKGRlZmF1bHRSZWR1Y2UpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3BhcnNlci5nZXROYW1lKGRlZmF1bHRSZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDg0MDAgLyogUmVjLkN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gNjAwMCAvKiBSZWMuQ3V0VG8gKi8gJiYgc3RhY2suZm9yY2VSZWR1Y2UoKSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLnRva2Vucy5nZXRBY3Rpb25zKHN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSBhY3Rpb25zW2krK10sIHRlcm0gPSBhY3Rpb25zW2krK10sIGVuZCA9IGFjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaSA9PSBhY3Rpb25zLmxlbmd0aCB8fCAhc3BsaXQ7XG4gICAgICAgICAgICBsZXQgbG9jYWxTdGFjayA9IGxhc3QgPyBzdGFjayA6IHN0YWNrLnNwbGl0KCk7XG4gICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudG9rZW5zLm1haW5Ub2tlbjtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBtYWluID8gbWFpbi5zdGFydCA6IGxvY2FsU3RhY2sucG9zLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMCA/IFwic2hpZnRcIlxuICAgICAgICAgICAgICAgICAgICA6IGByZWR1Y2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovKX1gfSBmb3IgJHtwYXJzZXIuZ2V0TmFtZSh0ZXJtKX0gQCAke3N0YXJ0fSR7bG9jYWxTdGFjayA9PSBzdGFjayA/IFwiXCIgOiBcIiwgc3BsaXRcIn0pYCk7XG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsU3RhY2sucG9zID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgc3RhY2tzLnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3BsaXQucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkdmFuY2UgYSBnaXZlbiBzdGFjayBmb3J3YXJkIGFzIGZhciBhcyBpdCB3aWxsIGdvLiBSZXR1cm5zIHRoZVxuICAgIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgICAvLyBmb3J3YXJkIGFuZCB3YXMgZ2l2ZW4gdG8gYHB1c2hTdGFja0RlZHVwYC5cbiAgICBhZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgcG9zID0gc3RhY2sucG9zO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBudWxsLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhY2sucG9zID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuUmVjb3Zlcnkoc3RhY2tzLCB0b2tlbnMsIG5ld1N0YWNrcykge1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBudWxsLCByZXN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXSwgdG9rZW4gPSB0b2tlbnNbaSA8PCAxXSwgdG9rZW5FbmQgPSB0b2tlbnNbKGkgPDwgMSkgKyAxXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoc3RhY2suZGVhZEVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIChyZXN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5hZHZhbmNlRnVsbHkoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlID0gc3RhY2suc3BsaXQoKSwgZm9yY2VCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTAgLyogUmVjLkZvcmNlUmVkdWNlTGltaXQgKi8gJiYgZm9yY2UuZm9yY2VSZWR1Y2UoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucmVjb3ZlckJ5RGVsZXRlKHRva2VuLCB0b2tlbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIHJlY292ZXItZGVsZXRlICR7dGhpcy5wYXJzZXIuZ2V0TmFtZSh0b2tlbil9KWApO1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmlzaGVkIHx8IGZpbmlzaGVkLnNjb3JlIDwgc3RhY2suc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgc3RhY2sncyBidWZmZXIgdG8gYSBzeW50YXggdHJlZS5cbiAgICBzdGFja1RvVHJlZShzdGFjaykge1xuICAgICAgICBzdGFjay5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gVHJlZS5idWlsZCh7IGJ1ZmZlcjogU3RhY2tCdWZmZXJDdXJzb3IuY3JlYXRlKHN0YWNrKSxcbiAgICAgICAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBsZW5ndGg6IHN0YWNrLnBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICAgICAgICBtaW5SZXBlYXRUeXBlOiB0aGlzLnBhcnNlci5taW5SZXBlYXRUZXJtIH0pO1xuICAgIH1cbiAgICBzdGFja0lEKHN0YWNrKSB7XG4gICAgICAgIGxldCBpZCA9IChzdGFja0lEcyB8fCAoc3RhY2tJRHMgPSBuZXcgV2Vha01hcCkpLmdldChzdGFjayk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBzdGFja0lEcy5zZXQoc3RhY2ssIGlkID0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5uZXh0U3RhY2tJRCsrKSk7XG4gICAgICAgIHJldHVybiBpZCArIHN0YWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1N0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3NbaV07XG4gICAgICAgIGlmIChvdGhlci5wb3MgPT0gc3RhY2sucG9zICYmIG90aGVyLnNhbWVTdGF0ZShzdGFjaykpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3NbaV0uc2NvcmUgPCBzdGFjay5zY29yZSlcbiAgICAgICAgICAgICAgICBuZXdTdGFja3NbaV0gPSBzdGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG59XG5jbGFzcyBEaWFsZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGZsYWdzLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIGFsbG93cyh0ZXJtKSB7IHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW3Rlcm1dID09IDA7IH1cbn1cbmNvbnN0IGlkID0geCA9PiB4O1xuLyoqXG5Db250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbmluZGVudGF0aW9uIGluIHRoZSBQeXRob24gZ3JhbW1hciwgb3IgcGFyZW50IGVsZW1lbnRzIGluIHRoZSBYTUxcbmdyYW1tYXIpIG5lZWRlZCBieSBleHRlcm5hbCB0b2tlbml6ZXJzLiBZb3UgZGVjbGFyZSB0aGVtIGluIGFcbmdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuXG5Db250ZXh0IHZhbHVlcyBzaG91bGQgYmUgaW1tdXRhYmxlLCBhbmQgY2FuIGJlIHVwZGF0ZWQgKHJlcGxhY2VkKVxub24gc2hpZnQgb3IgcmVkdWNlIGFjdGlvbnMuXG5cblRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbnR5cGUuXG4qL1xuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8qKlxuICAgIERlZmluZSBhIGNvbnRleHQgdHJhY2tlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHNwZWMuc3RhcnQ7XG4gICAgICAgIHRoaXMuc2hpZnQgPSBzcGVjLnNoaWZ0IHx8IGlkO1xuICAgICAgICB0aGlzLnJlZHVjZSA9IHNwZWMucmVkdWNlIHx8IGlkO1xuICAgICAgICB0aGlzLnJldXNlID0gc3BlYy5yZXVzZSB8fCBpZDtcbiAgICAgICAgdGhpcy5oYXNoID0gc3BlYy5oYXNoIHx8ICgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBzcGVjLnN0cmljdCAhPT0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG5Ib2xkcyB0aGUgcGFyc2UgdGFibGVzIGZvciBhIGdpdmVuIGdyYW1tYXIsIGFzIGdlbmVyYXRlZCBieVxuYGxlemVyLWdlbmVyYXRvcmAsIGFuZCBwcm92aWRlcyBbbWV0aG9kc10oI2NvbW1vbi5QYXJzZXIpIHRvIHBhcnNlXG5jb250ZW50IHdpdGguXG4qL1xuY2xhc3MgTFJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxNCAvKiBGaWxlLlZlcnNpb24gKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUGFyc2VyIHZlcnNpb24gKCR7c3BlYy52ZXJzaW9ufSkgZG9lc24ndCBtYXRjaCBydW50aW1lIHZlcnNpb24gKCR7MTQgLyogRmlsZS5WZXJzaW9uICovfSlgKTtcbiAgICAgICAgbGV0IG5vZGVOYW1lcyA9IHNwZWMubm9kZU5hbWVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbm9kZU5hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnJlcGVhdE5vZGVDb3VudDsgaSsrKVxuICAgICAgICAgICAgbm9kZU5hbWVzLnB1c2goXCJcIik7XG4gICAgICAgIGxldCB0b3BUZXJtcyA9IE9iamVjdC5rZXlzKHNwZWMudG9wUnVsZXMpLm1hcChyID0+IHNwZWMudG9wUnVsZXNbcl1bMV0pO1xuICAgICAgICBsZXQgbm9kZVByb3BzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZVByb3BzLnB1c2goW10pO1xuICAgICAgICBmdW5jdGlvbiBzZXRQcm9wKG5vZGVJRCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5vZGVQcm9wc1tub2RlSURdLnB1c2goW3Byb3AsIHByb3AuZGVzZXJpYWxpemUoU3RyaW5nKHZhbHVlKSldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYy5ub2RlUHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wU3BlYyBvZiBzcGVjLm5vZGVQcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcFNwZWNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBOb2RlUHJvcFtwcm9wXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wU291cmNlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uc3BlYy5wcm9wU291cmNlcyk7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHRva2VuQXJyYXkgPSBkZWNvZGVBcnJheShzcGVjLnRva2VuRGF0YSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplclNwZWNzID0gc3BlYy5zcGVjaWFsaXplZCB8fCBbXTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplZCA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNwZWNpYWxpemVyU3BlY3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVkW2ldID0gdGhpcy5zcGVjaWFsaXplclNwZWNzW2ldLnRlcm07XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcChnZXRTcGVjaWFsaXplcik7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZXMsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGVjb2RlQXJyYXkoc3BlYy5zdGF0ZURhdGEpO1xuICAgICAgICB0aGlzLmdvdG8gPSBkZWNvZGVBcnJheShzcGVjLmdvdG8pO1xuICAgICAgICB0aGlzLm1heFRlcm0gPSBzcGVjLm1heFRlcm07XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IHNwZWMudG9rZW5pemVycy5tYXAodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyBuZXcgVG9rZW5Hcm91cCh0b2tlbkFycmF5LCB2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgIHRoaXMudG9wUnVsZXMgPSBzcGVjLnRvcFJ1bGVzO1xuICAgICAgICB0aGlzLmRpYWxlY3RzID0gc3BlYy5kaWFsZWN0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljUHJlY2VkZW5jZXMgPSBzcGVjLmR5bmFtaWNQcmVjZWRlbmNlcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnRva2VuUHJlY1RhYmxlID0gc3BlYy50b2tlblByZWM7XG4gICAgICAgIHRoaXMudGVybU5hbWVzID0gc3BlYy50ZXJtTmFtZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tYXhOb2RlID0gdGhpcy5ub2RlU2V0LnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KCk7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3BSdWxlc1tPYmplY3Qua2V5cyh0aGlzLnRvcFJ1bGVzKVswXV07XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSBuZXcgUGFyc2UodGhpcywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgICAgICAgcGFyc2UgPSB3KHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiB0aGlzIHN0YXRlIGhhcyBhbiBhY3Rpb24gZm9yIGEgZ2l2ZW4gdGVybWluYWwgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNBY3Rpb24oc3RhdGUsIHRlcm1pbmFsKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCBzZXQgPyAyIC8qIFBhcnNlU3RhdGUuU2tpcCAqLyA6IDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKSwgbmV4dDs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IGRhdGFbaV0pID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZGF0YVtpID0gcGFpcihkYXRhLCBpICsgMildO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyKGRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IHRlcm1pbmFsIHx8IG5leHQgPT0gMCAvKiBUZXJtLkVyciAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlU2xvdChzdGF0ZSwgc2xvdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbKHN0YXRlICogNiAvKiBQYXJzZVN0YXRlLlNpemUgKi8pICsgc2xvdF07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVGbGFnKHN0YXRlLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDAgLyogUGFyc2VTdGF0ZS5GbGFncyAqLykgJiBmbGFnKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsaWRBY3Rpb24oc3RhdGUsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFsbEFjdGlvbnMoc3RhdGUsIGEgPT4gYSA9PSBhY3Rpb24gPyB0cnVlIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWxsQWN0aW9ucyhzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGxldCBkZWZsdCA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBkZWZsdCA/IGFjdGlvbihkZWZsdCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOyByZXN1bHQgPT0gbnVsbDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYWN0aW9uKHBhaXIodGhpcy5kYXRhLCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgc3RhdGVzIHRoYXQgY2FuIGZvbGxvdyB0aGlzIG9uZSB0aHJvdWdoIHNoaWZ0IGFjdGlvbnMgb3JcbiAgICBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRTdGF0ZXMoc3RhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLyA+PiAxNikpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZGF0YVtpXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgICBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIGtlcHQgZnJvbSB0aGUgb3JpZ2luYWwgcGFyc2VyLlxuICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICAvLyBIaWRlb3VzIHJlZmxlY3Rpb24tYmFzZWQga2x1ZGdlIHRvIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgYVxuICAgICAgICAvLyBzbGlnaHRseSBtb2RpZmllZCBjb3B5IG9mIGEgcGFyc2VyLlxuICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShMUlBhcnNlci5wcm90b3R5cGUpLCB0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9wcylcbiAgICAgICAgICAgIGNvcHkubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uY29uZmlnLnByb3BzKTtcbiAgICAgICAgaWYgKGNvbmZpZy50b3ApIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy50b3BSdWxlc1tjb25maWcudG9wXTtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCB0b3AgcnVsZSBuYW1lICR7Y29uZmlnLnRvcH1gKTtcbiAgICAgICAgICAgIGNvcHkudG9wID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnRva2VuaXplcnMpXG4gICAgICAgICAgICBjb3B5LnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbmZpZy50b2tlbml6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gZm91bmQudG8gOiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcuc3BlY2lhbGl6ZXJzKSB7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVycyA9IHRoaXMuc3BlY2lhbGl6ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyU3BlY3MgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKChzLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnNwZWNpYWxpemVycy5maW5kKHIgPT4gci5mcm9tID09IHMuZXh0ZXJuYWwpO1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIGxldCBzcGVjID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzKSwgeyBleHRlcm5hbDogZm91bmQudG8gfSk7XG4gICAgICAgICAgICAgICAgY29weS5zcGVjaWFsaXplcnNbaV0gPSBnZXRTcGVjaWFsaXplcihzcGVjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29udGV4dFRyYWNrZXIpXG4gICAgICAgICAgICBjb3B5LmNvbnRleHQgPSBjb25maWcuY29udGV4dFRyYWNrZXI7XG4gICAgICAgIGlmIChjb25maWcuZGlhbGVjdClcbiAgICAgICAgICAgIGNvcHkuZGlhbGVjdCA9IHRoaXMucGFyc2VEaWFsZWN0KGNvbmZpZy5kaWFsZWN0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpY3QgIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuc3RyaWN0ID0gY29uZmlnLnN0cmljdDtcbiAgICAgICAgaWYgKGNvbmZpZy53cmFwKVxuICAgICAgICAgICAgY29weS53cmFwcGVycyA9IGNvcHkud3JhcHBlcnMuY29uY2F0KGNvbmZpZy53cmFwKTtcbiAgICAgICAgaWYgKGNvbmZpZy5idWZmZXJMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgIGNvcHkuYnVmZmVyTGVuZ3RoID0gY29uZmlnLmJ1ZmZlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIGFueSBbcGFyc2Ugd3JhcHBlcnNdKCNsci5QYXJzZXJDb25maWcud3JhcClcbiAgICBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBwYXJzZXIuXG4gICAgKi9cbiAgICBoYXNXcmFwcGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbmFtZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0ZXJtLiBUaGlzIHdpbGwgb25seVxuICAgIHdvcmsgZm9yIGFsbCB0ZXJtcyB3aGVuIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCB3aXRoIHRoZVxuICAgIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICBzdG9yZWQuXG4gICAgKi9cbiAgICBnZXROYW1lKHRlcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybU5hbWVzID8gdGhpcy50ZXJtTmFtZXNbdGVybV0gOiBTdHJpbmcodGVybSA8PSB0aGlzLm1heE5vZGUgJiYgdGhpcy5ub2RlU2V0LnR5cGVzW3Rlcm1dLm5hbWUgfHwgdGVybSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgdHlwZXMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVvZlRlcm0oKSB7IHJldHVybiB0aGlzLm1heE5vZGUgKyAxOyB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGdldCB0b3BOb2RlKCkgeyByZXR1cm4gdGhpcy5ub2RlU2V0LnR5cGVzW3RoaXMudG9wWzFdXTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJzZURpYWxlY3QoZGlhbGVjdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5kaWFsZWN0cyksIGZsYWdzID0gdmFsdWVzLm1hcCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChkaWFsZWN0KVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBkaWFsZWN0LnNwbGl0KFwiIFwiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHZhbHVlcy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpZCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBmbGFnc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghZmxhZ3NbaV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaWFsZWN0c1t2YWx1ZXNbaV1dLCBpZDsgKGlkID0gdGhpcy5kYXRhW2orK10pICE9IDY1NTM1IC8qIFNlcS5FbmQgKi87KVxuICAgICAgICAgICAgICAgICAgICAoZGlzYWJsZWQgfHwgKGRpc2FibGVkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tYXhUZXJtICsgMSkpKVtpZF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpYWxlY3QoZGlhbGVjdCwgZmxhZ3MsIGRpc2FibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yLiBOb3QgYXZhaWxhYmxlIHRvXG4gICAgdXNlciBjb2RlLiBAaGlkZVxuICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUlBhcnNlcihzcGVjKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYWlyKGRhdGEsIG9mZikgeyByZXR1cm4gZGF0YVtvZmZdIHwgKGRhdGFbb2ZmICsgMV0gPDwgMTYpOyB9XG5mdW5jdGlvbiBmaW5kRmluaXNoZWQoc3RhY2tzKSB7XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IHN0YWNrLnAuc3RvcHBlZEF0O1xuICAgICAgICBpZiAoKHN0YWNrLnBvcyA9PSBzdGFjay5wLnN0cmVhbS5lbmQgfHwgc3RvcHBlZCAhPSBudWxsICYmIHN0YWNrLnBvcyA+IHN0b3BwZWQpICYmXG4gICAgICAgICAgICBzdGFjay5wLnBhcnNlci5zdGF0ZUZsYWcoc3RhY2suc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykgJiZcbiAgICAgICAgICAgICghYmVzdCB8fCBiZXN0LnNjb3JlIDwgc3RhY2suc2NvcmUpKVxuICAgICAgICAgICAgYmVzdCA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldFNwZWNpYWxpemVyKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5leHRlcm5hbCkge1xuICAgICAgICBsZXQgbWFzayA9IHNwZWMuZXh0ZW5kID8gMSAvKiBTcGVjaWFsaXplLkV4dGVuZCAqLyA6IDAgLyogU3BlY2lhbGl6ZS5TcGVjaWFsaXplICovO1xuICAgICAgICByZXR1cm4gKHZhbHVlLCBzdGFjaykgPT4gKHNwZWMuZXh0ZXJuYWwodmFsdWUsIHN0YWNrKSA8PCAxKSB8IG1hc2s7XG4gICAgfVxuICAgIHJldHVybiBzcGVjLmdldDtcbn1cblxuZXhwb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBJbnB1dFN0cmVhbSwgTFJQYXJzZXIsIExvY2FsVG9rZW5Hcm91cCwgU3RhY2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;